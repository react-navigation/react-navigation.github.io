"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[87386],{72304:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"configuring-links","title":"Configuring links","description":"In this guide, we will configure React Navigation to handle external links. This is necessary if you want to:","source":"@site/versioned_docs/version-5.x/configuring-links.md","sourceDirName":".","slug":"/configuring-links","permalink":"/docs/5.x/configuring-links","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-5.x/configuring-links.md","tags":[],"version":"5.x","frontMatter":{"id":"configuring-links","title":"Configuring links","sidebar_label":"Configuring links"},"sidebar":"docs","previous":{"title":"Deep linking","permalink":"/docs/5.x/deep-linking"},"next":{"title":"Web support","permalink":"/docs/5.x/web-support"}}');var a=t(74848),s=t(28453),o=t(29571);const r={id:"configuring-links",title:"Configuring links",sidebar_label:"Configuring links",rawMarkdown:"---\nid: configuring-links\ntitle: Configuring links\nsidebar_label: Configuring links\n---\n\nIn this guide, we will configure React Navigation to handle external links. This is necessary if you want to:\n\n1. Handle deep links in React Native apps on Android and iOS\n2. Enable URL integration in browser when using on web\n3. Use [`<Link />`](link.md) or [`useLinkTo`](use-link-to.md) to navigate using paths.\n\nMake sure that you have [configured deep links](deep-linking.md) in your app before proceeding. If you have an Android or iOS app, remember to specify the [`prefixes`](navigation-container.md#linkingprefixes) option.\n\nThe `NavigationContainer` accepts a [`linking`](navigation-container.md#linking) prop that makes it easier to handle incoming links. The 2 of the most important properties you can specify in the `linking` prop are `prefixes` and `config`:\n\n```js\nimport { NavigationContainer } from '@react-navigation/native';\n\nconst linking = {\n  prefixes: [\n    /* your linking prefixes */\n  ],\n  config: {\n    /* configuration for matching screens with paths */\n  },\n};\n\nfunction App() {\n  return (\n    <NavigationContainer linking={linking} fallback={<Text>Loading...</Text>}>\n      {/* content */}\n    </NavigationContainer>\n  );\n}\n```\n\nWhen you specify the `linking` prop, React Navigation will handle incoming links automatically. On Android and iOS, it'll use React Native's [`Linking` module](https://reactnative.dev/docs/linking) to handle incoming links, both when the app was opened with the link, and when new links are received when the app is open. On the Web, it'll use the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to sync the URL with the browser.\n\n> Note: Currently there seems to be bug ([facebook/react-native#25675](https://github.com/facebook/react-native/issues/25675)) which results in it never resolving on Android. We add a timeout to avoid getting stuck forever, but it means that the link might not be handled in some cases.\n\nYou can also pass a [`fallback`](navigation-container.md#fallback) prop to `NavigationContainer` which controls what's displayed when React Navigation is trying to resolve the initial deep link URL.\n\n## Mapping path to route names\n\nTo handle a link, you need to translate it to a valid [navigation state](navigation-state.md) and vice versa. For example, the path `/rooms/chat?user=jane` may be translated to a state object like this:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'rooms',\n      state: {\n        routes: [\n          {\n            name: 'chat',\n            params: { user: 'jane' },\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\nBy default, React Navigation will use the path segments as the route name when parsing the URL. But directly translating path segments to route names may not be the expected behavior.\n\nFor example, you might want to parse the path `/feed/latest` to something like:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Chat',\n      params: {\n        sort: 'latest',\n      },\n    },\n  ];\n}\n```\n\nYou can specify the [`config`](navigation-container.md#linkingconfig) option in `linking` to control how the deep link is parsed to suit your needs.\n\n```js\nconst config = {\n  screens: {\n    Chat: 'feed/:sort',\n    Profile: 'user',\n  },\n};\n```\n\nHere `Chat` is the name of the screen that handles the URL `/feed`, and `Profile` handles the URL `/user`.\n\nThe config option can then be passed in the `linking` prop to the container:\n\n```js\nimport { NavigationContainer } from '@react-navigation/native';\n\nconst config = {\n  screens: {\n    Chat: 'feed/:sort',\n    Profile: 'user',\n  },\n};\n\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n  config,\n};\n\nfunction App() {\n  return (\n    <NavigationContainer linking={linking} fallback={<Text>Loading...</Text>}>\n      {/* content */}\n    </NavigationContainer>\n  );\n}\n```\n\nThe config object must match the navigation structure for your app. For example, the above configuration is if you have `Chat` and `Profile` screens in the navigator at the root:\n\n```js\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name=\"Chat\" component={ChatScreen} />\n      <Stack.Screen name=\"Profile\" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\nIf your `Chat` screen is inside a nested navigator, we'd need to account for that. For example, consider the following structure where your `Profile` screen is at the root, but the `Chat` screen is nested inside `Home`:\n\n```js\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name=\"Home\" component={HomeScreen} />\n      <Stack.Screen name=\"Profile\" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n\nfunction HomeScreen() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name=\"Chat\" component={ChatScreen} />\n    </Tab.Navigator>\n  );\n}\n```\n\nFor above structure, our configuration will look like this:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      screens: {\n        Chat: 'feed/:sort',\n      },\n    },\n    Profile: 'user',\n  },\n};\n```\n\nSimilarly, any nesting needs to be reflected in the configuration. See [handling nested navigators](#handling-nested-navigators) for more details.\n\n## Passing params\n\nA common use case is to pass params to a screen to pass some data. For example, you may want the `Profile` screen to have an `id` param to know which user's profile it is. It's possible to pass params to a screen through a URL when handling deep links.\n\nBy default, query params are parsed to get the params for a screen. For example, with the above example, the URL `/user?id=wojciech` will pass the `id` param to the `Profile` screen.\n\nYou can also customize how the params are parsed from the URL. Let's say you want the URL to look like `/user/wojciech` where the `id` param is `wojciech` instead of having the `id` in query params. You can do this by specifying `user/:id` for the `path`. **When the path segment starts with `:`, it'll be treated as a param**. For example, the URL `/user/wojciech` would resolve to `Profile` screen with the string `wojciech` as a value of the `id` param and will be available in `route.params.id` in `Profile` screen.\n\nBy default, all params are treated as strings. You can also customize how to parse them by specifying a function in the `parse` property to parse the param, and a function in the `stringify` property to convert it back to a string.\n\nIf you wanted to resolve `/user/wojciech/settings` to result in the params `{ id: 'user-wojciech' section: 'settings' }`, you could make `Profile`'s config to look like this:\n\n```js\nconst config = {\n  screens: {\n    Profile: {\n      path: 'user/:id/:section',\n      parse: {\n        id: (id) => `user-${id}`,\n      },\n      stringify: {\n        id: (id) => id.replace(/^user-/, ''),\n      },\n    },\n  },\n};\n```\n\nThis will result in something like:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-wojciech', section: 'settings' },\n    },\n  ],\n};\n```\n\n## Marking params as optional\n\nSometimes a param may or may not be present in the URL depending on certain conditions. For example, in the above scenario, you may not always have the section parameter in the URL, i.e. both `/user/wojciech/settings` and `/user/wojciech` should go to the `Profile` screen, but the `section` param (with the value `settings` in this case) may or may not be present.\n\nIn this case, you would need to mark the `section` param as optional. You can do it by adding the `?` suffix after the param name:\n\n```js\nconst config = {\n  screens: {\n    Profile: {\n      path: 'user/:id/:section?',\n      parse: {\n        id: (id) => `user-${id}`,\n      },\n      stringify: {\n        id: (id) => id.replace(/^user-/, ''),\n      },\n    },\n  },\n};\n```\n\nWith the URL `/users/wojciech`, this will result in:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-wojciech' },\n    },\n  ],\n};\n```\n\nIf the URL contains a `section` param, e.g. `/users/wojciech/settings`, this will result in the following with the same config:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-wojciech', section: 'settings' },\n    },\n  ],\n};\n```\n\n## Handling nested navigators\n\nSometimes you'll have the target navigator nested in other navigators which aren't part of the deep link. For example, let's say your navigation structure looks like this:\n\n```js\nfunction Home() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name=\"Profile\" component={Profile} />\n      <Tab.Screen name=\"Feed\" component={Feed} />\n    </Tab.Navigator>\n  );\n}\n\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name=\"Home\" component={Home} />\n      <Stack.Screen name=\"Settings\" component={Settings} />\n    </Stack.Navigator>\n  );\n}\n```\n\nHere you have a stack navigator in the root, and inside the `Home` screen of the root stack, you have a tab navigator with various screens. With this structure, let's say you want the path `/users/:id` to go to the `Profile` screen. You can express the nested config like so:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n```\n\nIn this config, you specify that the `Profile` screen should be resolved for the `users/:id` pattern and it's nested inside the `Home` screen. Then parsing `users/jane` will result in the following state object:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        routes: [\n          {\n            name: 'Profile',\n            params: { id: 'jane' },\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\nIt's important to note that the state object must match the hierarchy of nested navigators. Otherwise the state will be discarded.\n\n## Handling unmatched routes or 404\n\nIf your app is opened with an invalid URL, most of the times you'd want to show an error page with some information. On the web, this is commonly known as 404 - or page not found error.\n\nTo handle this, you'll need to define a catch-all route that will be rendered if no other routes match the path. You can do it by specifying `*` for the path matching pattern.\n\nFor example:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: 'settings',\n      },\n    },\n    NotFound: '*',\n  },\n};\n```\n\nHere, we have defined a route named `NotFound` and set it to match `*` aka everything. If the path didn't match `user/:id` or `settings`, it'll be matched by this route.\n\nSo, a path like `/library` or `/settings/notification` will resolve to the following state object:\n\n```js\nconst state = {\n  routes: [{ name: 'NotFound' }],\n};\n```\n\nYou can even go more specific, for example, say if you want to show a different screen for invalid paths under `/settings`, you can specify such a pattern under `Settings`:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: {\n          path: 'settings',\n          screens: {\n            InvalidSettings: '*',\n          },\n        },\n      },\n    },\n    NotFound: '*',\n  },\n};\n```\n\nWith this configuration, the path `/settings/notification` will resolve to the following state object:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        index: 1,\n        routes: [\n          { name: 'Feed' },\n          {\n            name: 'Settings',\n            state: {\n              routes: [{ name: 'InvalidSettings' }],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\nWhen doing server rendering, you'd also want to return correct status code for 404 errors. See [server rendering docs](server-rendering.md#handling-404-or-other-status-codes) for a guide on how to handle it.\n\n## Rendering an initial route\n\nSometimes you want to ensure that a certain screen will always be present as the first screen in the navigator's state. You can use the `initialRouteName` property to specify the screen to use for the initial screen.\n\nIn the above example, if you want the `Feed` screen to be the initial route in the navigator under `Home`, your config will look like this:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: 'settings',\n      },\n    },\n  },\n};\n```\n\nThen, the path `/users/42` will resolve to the following state object:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        index: 1,\n        routes: [\n          { name: 'Feed' },\n          {\n            name: 'Profile',\n            params: { id: '42' },\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\nIt's not possible to pass params to the initial screen through the URL. So make sure that your initial route doesn't need any params or specify `initialParams` to pass required params.\n\nIn this case, any params in the URL are only passed to the `Profile` screen which matches the path pattern `users/:id`, and the `Feed` screen doesn't receive any params. If you want to have the same params in the `Feed` screen, you can specify a [custom `getStateFromPath` function](navigation-container.md#linkinggetstatefrompath) and copy those params.\n\nSimilarly, if you want to access params of a parent screen from a child screen, you can use [React Context](https://reactjs.org/docs/context.html) to expose them.\n\n## Matching exact paths\n\nBy default, paths defined for each screen are matched against the URL relative to their parent screen's path. Consider the following config:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: 'feed',\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n```\n\nHere, you have a `path` property defined for the `Home` screen, as well as the child `Profile` screen. The profile screen specifies the path `users/:id`, but since it's nested inside a screen with the path `feed`, it'll try to match the pattern `feed/users/:id`.\n\nThis will result in the URL `/feed` navigating to `Home` screen, and `/feed/users/cal` navigating to the `Profile` screen.\n\nIn this case, it makes more sense to navigate to the `Profile` screen using a URL like `/users/cal`, rather than `/feed/users/cal`. To achieve this, you can override the relative matching behavior to `exact` matching:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: 'feed',\n      screens: {\n        Profile: {\n          path: 'users/:id',\n          exact: true,\n        },\n      },\n    },\n  },\n};\n```\n\nWith `exact` property set to `true`, `Profile` will ignore the parent screen's `path` config and you'll be able to navigate to `Profile` using a URL like `users/cal`.\n\n## Omitting a screen from path\n\nSometimes, you may not want to have the route name of a screen in the path. For example, let's say you have a `Home` screen and our [navigation state](navigation-state.md) looks like this:\n\n```js\nconst state = {\n  routes: [{ name: 'Home' }],\n};\n```\n\nWhen this state is serialized to a path with the following config, you'll get `/home`:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: 'home',\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n```\n\nBut it'll be nicer if the URL was just `/` when visiting the home screen. You can specify an empty string as path or not specify a path at all, and React Navigation won't add the screen to the path (think of it like adding empty string to the path, which doesn't change anything):\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: '',\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n```\n\n## Serializing and parsing params\n\nSince URLs are strings, any params you have for routes are also converted to strings when constructing the path.\n\nFor example, say you have a state like following:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Chat',\n      params: { at: 1589842744264 },\n    },\n  ];\n}\n```\n\nIt'll be converted to `chat/1589842744264` with the following config:\n\n```js\nconst config = {\n  screens: {\n    Chat: 'chat/:date',\n  },\n};\n```\n\nWhen parsing this path, you'll get the following state:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Chat',\n      params: { date: '1589842744264' },\n    },\n  ];\n}\n```\n\nHere, the `date` param was parsed as a string because React Navigation doesn't know that it's supposed to be a timestamp, and hence number. You can customize it by providing a custom function to use for parsing:\n\n```js\nconst config = {\n  screens: {\n    Chat: {\n      path: 'chat/:date',\n      parse: {\n        date: Number,\n      },\n    },\n  },\n};\n```\n\nYou can also provide a custom function to serialize the params. For example, let's say that you want to use a DD-MM-YYYY format in the path instead of a timestamp:\n\n```js\nconst config = {\n  screens: {\n    Chat: {\n      path: 'chat/:date',\n      parse: {\n        date: (date) => new Date(date).getTime(),\n      },\n      stringify: {\n        date: (date) => {\n          const d = new Date(date);\n\n          return d.getFullYear() + '-' + d.getMonth() + '-' + d.getDate();\n        },\n      },\n    },\n  },\n};\n```\n\nDepending on your requirements, you can use this functionality to parse and stringify more complex data.\n\n## Advanced cases\n\nFor some advanced cases, specifying the mapping may not be sufficient. To handle such cases, you can specify a custom function to parse the URL into a state object ([`getStateFromPath`](navigation-container.md#linkinggetstatefrompath)), and a custom function to serialize the state object into an URL ([`getPathFromState`](navigation-container.md#linkinggetpathfromstate)).\n\nExample:\n\n```js\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n  config: {\n    screens: {\n      Chat: 'feed/:sort',\n    },\n  },\n  getStateFromPath(path, options) {\n    // Return a state object here\n    // You can also reuse the default logic by importing `getStateFromPath` from `@react-navigation/native`\n  },\n  getPathFromState(state, config) {\n    // Return a path string here\n    // You can also reuse the default logic by importing `getPathFromState` from `@react-navigation/native`\n  },\n};\n```\n\n## Updating config\n\nOlder versions of React Navigation had a slightly different configuration format for linking. The old config allowed a simple key value pair in the object regardless of nesting of navigators:\n\n```js\nconst config = {\n  Home: 'home',\n  Feed: 'feed',\n  Profile: 'profile',\n  Settings: 'settings',\n};\n```\n\nLet's say, your `Feed` and `Profile` screens are nested inside `Home`. Even if you don't have such a nesting with the above configuration, as long as the URL was `/home/profile`, it would work. Furthermore, it would also treat path segments and route names the same, which means that you could deep link to a screen that's not specified in the configuration. For example, if you have a `Albums` screen inside `Home`, the deep link `/home/Albums` would navigate to that screen. While that may be desirable in some cases, there's no way to prevent access to specific screens. This approach also makes it impossible to have something like a 404 screen since any route name is a valid path.\n\nLatest versions of React Navigation use a different config format which is stricter in this regard:\n\n- The shape of the config must match the shape of the nesting in the navigation structure\n- Only screens defined in the config will be eligible for deep linking\n\nSo, you'd refactor the above config to the following format:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: 'home',\n      screens: {\n        Feed: 'feed',\n        Profile: 'profile',\n      },\n    },\n    Settings: 'settings',\n  },\n};\n```\n\nHere, there's a new `screens` property to the configuration object, and the `Feed` and `Profile` configs are now nested under `Home` to match the navigation structure.\n\nIf you have the old format, it will continue to work without any changes. However, you won't be able to specify a wildcard pattern to handle unmatched screens or prevent screens from being deep linked. The old format will be removed in the next major release. So we recommend to migrate to the new format when you can.\n\n## Playground\n\nYou can play around with customizing the config and path below, and see how the path is parsed.\n\nimport LinkingTester from '@site/src/components/LinkingTester'\n\n<LinkingTester />\n\n## Example App\n\nIn the example app, you will use the Expo managed workflow. The guide will focus on creating the deep linking configuration and not on creating the components themselves, but you can always check the full implementation in the [github repo](https://github.com/react-navigation/deep-linking-example).\n\nFirst, you need to decide the navigation structure of your app. To keep it simple, the main navigator will be bottom-tabs navigator with two screens. Its first screen will be a simple stack navigator, called `HomeStack`, with two screens: `Home` and `Profile`, and the second tabs screen will be just a simple one without any nested navigators, called `Settings`:\n\n```bash\nBottomTabs\n\u251c\u2500\u2500 Stack (HomeStack)\n\u2502\xa0\xa0 \u251c\u2500\u2500 Home\n\u2502\xa0\xa0 \u2514\u2500\u2500 Profile\n\u2514\u2500\u2500 Settings\n```\n\nAfter creating the navigation structure, you can create a config for deep linking, which will contain mappings for each screen to a path segment. For example:\n\n```js\nconst config = {\n  screens: {\n    HomeStack: {\n      screens: {\n        Home: 'home',\n        Profile: 'user',\n      },\n    },\n    Settings: 'settings',\n  },\n};\n```\n\nAs you can see, `Home` and `Profile` are nested in the `screens` property of `HomeStack`. This means that when you pass the `/home` URL, it will be resolved to a `HomeStack`->`Home` state object (similarly for `/user` it would be `HomeStack`->`Profile`). The nesting in this object should match the nesting of our navigators.\n\nHere, the `HomeStack` property contains a config object. The config can go as deep as you want, e.g. if `Home` was a navigator, you could make it an object with `screens` property, and put more screens or navigators inside it, making the URL string much more readable.\n\nWhat if you wanted a specific screen to used as the initial screen in the navigator? For example, if you had a URL that would open `Home` screen, you would like to be able to navigate to `Profile` from it by using navigation's `navigation.goBack()` method. It is possible by defining `initialRouteName` for a navigator. It would look like this:\n\n```js\nconst config = {\n  screens: {\n    HomeStack: {\n      initialRouteName: 'Profile',\n      screens: {\n        Home: 'home',\n        Profile: 'user',\n      },\n    },\n    Settings: 'settings',\n  },\n};\n```\n"},c=void 0,l={},h=[{value:"Mapping path to route names",id:"mapping-path-to-route-names",level:2},{value:"Passing params",id:"passing-params",level:2},{value:"Marking params as optional",id:"marking-params-as-optional",level:2},{value:"Handling nested navigators",id:"handling-nested-navigators",level:2},{value:"Handling unmatched routes or 404",id:"handling-unmatched-routes-or-404",level:2},{value:"Rendering an initial route",id:"rendering-an-initial-route",level:2},{value:"Matching exact paths",id:"matching-exact-paths",level:2},{value:"Omitting a screen from path",id:"omitting-a-screen-from-path",level:2},{value:"Serializing and parsing params",id:"serializing-and-parsing-params",level:2},{value:"Advanced cases",id:"advanced-cases",level:2},{value:"Updating config",id:"updating-config",level:2},{value:"Playground",id:"playground",level:2},{value:"Example App",id:"example-app",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"In this guide, we will configure React Navigation to handle external links. This is necessary if you want to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Handle deep links in React Native apps on Android and iOS"}),"\n",(0,a.jsx)(n.li,{children:"Enable URL integration in browser when using on web"}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.a,{href:"/docs/5.x/link",children:(0,a.jsx)(n.code,{children:"<Link />"})})," or ",(0,a.jsx)(n.a,{href:"/docs/5.x/use-link-to",children:(0,a.jsx)(n.code,{children:"useLinkTo"})})," to navigate using paths."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Make sure that you have ",(0,a.jsx)(n.a,{href:"/docs/5.x/deep-linking",children:"configured deep links"})," in your app before proceeding. If you have an Android or iOS app, remember to specify the ",(0,a.jsx)(n.a,{href:"/docs/5.x/navigation-container#linkingprefixes",children:(0,a.jsx)(n.code,{children:"prefixes"})})," option."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"NavigationContainer"})," accepts a ",(0,a.jsx)(n.a,{href:"/docs/5.x/navigation-container#linking",children:(0,a.jsx)(n.code,{children:"linking"})})," prop that makes it easier to handle incoming links. The 2 of the most important properties you can specify in the ",(0,a.jsx)(n.code,{children:"linking"})," prop are ",(0,a.jsx)(n.code,{children:"prefixes"})," and ",(0,a.jsx)(n.code,{children:"config"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { NavigationContainer } from '@react-navigation/native';\n\nconst linking = {\n  prefixes: [\n    /* your linking prefixes */\n  ],\n  config: {\n    /* configuration for matching screens with paths */\n  },\n};\n\nfunction App() {\n  return (\n    <NavigationContainer linking={linking} fallback={<Text>Loading...</Text>}>\n      {/* content */}\n    </NavigationContainer>\n  );\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When you specify the ",(0,a.jsx)(n.code,{children:"linking"})," prop, React Navigation will handle incoming links automatically. On Android and iOS, it'll use React Native's ",(0,a.jsxs)(n.a,{href:"https://reactnative.dev/docs/linking",children:[(0,a.jsx)(n.code,{children:"Linking"})," module"]})," to handle incoming links, both when the app was opened with the link, and when new links are received when the app is open. On the Web, it'll use the ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/History_API",children:"History API"})," to sync the URL with the browser."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["Note: Currently there seems to be bug (",(0,a.jsx)(n.a,{href:"https://github.com/facebook/react-native/issues/25675",children:"facebook/react-native#25675"}),") which results in it never resolving on Android. We add a timeout to avoid getting stuck forever, but it means that the link might not be handled in some cases."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["You can also pass a ",(0,a.jsx)(n.a,{href:"/docs/5.x/navigation-container#fallback",children:(0,a.jsx)(n.code,{children:"fallback"})})," prop to ",(0,a.jsx)(n.code,{children:"NavigationContainer"})," which controls what's displayed when React Navigation is trying to resolve the initial deep link URL."]}),"\n",(0,a.jsx)(n.h2,{id:"mapping-path-to-route-names",children:"Mapping path to route names"}),"\n",(0,a.jsxs)(n.p,{children:["To handle a link, you need to translate it to a valid ",(0,a.jsx)(n.a,{href:"/docs/5.x/navigation-state",children:"navigation state"})," and vice versa. For example, the path ",(0,a.jsx)(n.code,{children:"/rooms/chat?user=jane"})," may be translated to a state object like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'rooms',\n      state: {\n        routes: [\n          {\n            name: 'chat',\n            params: { user: 'jane' },\n          },\n        ],\n      },\n    },\n  ],\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"By default, React Navigation will use the path segments as the route name when parsing the URL. But directly translating path segments to route names may not be the expected behavior."}),"\n",(0,a.jsxs)(n.p,{children:["For example, you might want to parse the path ",(0,a.jsx)(n.code,{children:"/feed/latest"})," to something like:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Chat',\n      params: {\n        sort: 'latest',\n      },\n    },\n  ];\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can specify the ",(0,a.jsx)(n.a,{href:"/docs/5.x/navigation-container#linkingconfig",children:(0,a.jsx)(n.code,{children:"config"})})," option in ",(0,a.jsx)(n.code,{children:"linking"})," to control how the deep link is parsed to suit your needs."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Chat: 'feed/:sort',\n    Profile: 'user',\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here ",(0,a.jsx)(n.code,{children:"Chat"})," is the name of the screen that handles the URL ",(0,a.jsx)(n.code,{children:"/feed"}),", and ",(0,a.jsx)(n.code,{children:"Profile"})," handles the URL ",(0,a.jsx)(n.code,{children:"/user"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The config option can then be passed in the ",(0,a.jsx)(n.code,{children:"linking"})," prop to the container:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { NavigationContainer } from '@react-navigation/native';\n\nconst config = {\n  screens: {\n    Chat: 'feed/:sort',\n    Profile: 'user',\n  },\n};\n\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n  config,\n};\n\nfunction App() {\n  return (\n    <NavigationContainer linking={linking} fallback={<Text>Loading...</Text>}>\n      {/* content */}\n    </NavigationContainer>\n  );\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The config object must match the navigation structure for your app. For example, the above configuration is if you have ",(0,a.jsx)(n.code,{children:"Chat"})," and ",(0,a.jsx)(n.code,{children:"Profile"})," screens in the navigator at the root:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'function App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Chat" component={ChatScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If your ",(0,a.jsx)(n.code,{children:"Chat"})," screen is inside a nested navigator, we'd need to account for that. For example, consider the following structure where your ",(0,a.jsx)(n.code,{children:"Profile"})," screen is at the root, but the ",(0,a.jsx)(n.code,{children:"Chat"})," screen is nested inside ",(0,a.jsx)(n.code,{children:"Home"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'function App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n\nfunction HomeScreen() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Chat" component={ChatScreen} />\n    </Tab.Navigator>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"For above structure, our configuration will look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      screens: {\n        Chat: 'feed/:sort',\n      },\n    },\n    Profile: 'user',\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, any nesting needs to be reflected in the configuration. See ",(0,a.jsx)(n.a,{href:"#handling-nested-navigators",children:"handling nested navigators"})," for more details."]}),"\n",(0,a.jsx)(n.h2,{id:"passing-params",children:"Passing params"}),"\n",(0,a.jsxs)(n.p,{children:["A common use case is to pass params to a screen to pass some data. For example, you may want the ",(0,a.jsx)(n.code,{children:"Profile"})," screen to have an ",(0,a.jsx)(n.code,{children:"id"})," param to know which user's profile it is. It's possible to pass params to a screen through a URL when handling deep links."]}),"\n",(0,a.jsxs)(n.p,{children:["By default, query params are parsed to get the params for a screen. For example, with the above example, the URL ",(0,a.jsx)(n.code,{children:"/user?id=wojciech"})," will pass the ",(0,a.jsx)(n.code,{children:"id"})," param to the ",(0,a.jsx)(n.code,{children:"Profile"})," screen."]}),"\n",(0,a.jsxs)(n.p,{children:["You can also customize how the params are parsed from the URL. Let's say you want the URL to look like ",(0,a.jsx)(n.code,{children:"/user/wojciech"})," where the ",(0,a.jsx)(n.code,{children:"id"})," param is ",(0,a.jsx)(n.code,{children:"wojciech"})," instead of having the ",(0,a.jsx)(n.code,{children:"id"})," in query params. You can do this by specifying ",(0,a.jsx)(n.code,{children:"user/:id"})," for the ",(0,a.jsx)(n.code,{children:"path"}),". ",(0,a.jsxs)(n.strong,{children:["When the path segment starts with ",(0,a.jsx)(n.code,{children:":"}),", it'll be treated as a param"]}),". For example, the URL ",(0,a.jsx)(n.code,{children:"/user/wojciech"})," would resolve to ",(0,a.jsx)(n.code,{children:"Profile"})," screen with the string ",(0,a.jsx)(n.code,{children:"wojciech"})," as a value of the ",(0,a.jsx)(n.code,{children:"id"})," param and will be available in ",(0,a.jsx)(n.code,{children:"route.params.id"})," in ",(0,a.jsx)(n.code,{children:"Profile"})," screen."]}),"\n",(0,a.jsxs)(n.p,{children:["By default, all params are treated as strings. You can also customize how to parse them by specifying a function in the ",(0,a.jsx)(n.code,{children:"parse"})," property to parse the param, and a function in the ",(0,a.jsx)(n.code,{children:"stringify"})," property to convert it back to a string."]}),"\n",(0,a.jsxs)(n.p,{children:["If you wanted to resolve ",(0,a.jsx)(n.code,{children:"/user/wojciech/settings"})," to result in the params ",(0,a.jsx)(n.code,{children:"{ id: 'user-wojciech' section: 'settings' }"}),", you could make ",(0,a.jsx)(n.code,{children:"Profile"}),"'s config to look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Profile: {\n      path: 'user/:id/:section',\n      parse: {\n        id: (id) => `user-${id}`,\n      },\n      stringify: {\n        id: (id) => id.replace(/^user-/, ''),\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"This will result in something like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-wojciech', section: 'settings' },\n    },\n  ],\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"marking-params-as-optional",children:"Marking params as optional"}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes a param may or may not be present in the URL depending on certain conditions. For example, in the above scenario, you may not always have the section parameter in the URL, i.e. both ",(0,a.jsx)(n.code,{children:"/user/wojciech/settings"})," and ",(0,a.jsx)(n.code,{children:"/user/wojciech"})," should go to the ",(0,a.jsx)(n.code,{children:"Profile"})," screen, but the ",(0,a.jsx)(n.code,{children:"section"})," param (with the value ",(0,a.jsx)(n.code,{children:"settings"})," in this case) may or may not be present."]}),"\n",(0,a.jsxs)(n.p,{children:["In this case, you would need to mark the ",(0,a.jsx)(n.code,{children:"section"})," param as optional. You can do it by adding the ",(0,a.jsx)(n.code,{children:"?"})," suffix after the param name:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Profile: {\n      path: 'user/:id/:section?',\n      parse: {\n        id: (id) => `user-${id}`,\n      },\n      stringify: {\n        id: (id) => id.replace(/^user-/, ''),\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With the URL ",(0,a.jsx)(n.code,{children:"/users/wojciech"}),", this will result in:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-wojciech' },\n    },\n  ],\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If the URL contains a ",(0,a.jsx)(n.code,{children:"section"})," param, e.g. ",(0,a.jsx)(n.code,{children:"/users/wojciech/settings"}),", this will result in the following with the same config:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-wojciech', section: 'settings' },\n    },\n  ],\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"handling-nested-navigators",children:"Handling nested navigators"}),"\n",(0,a.jsx)(n.p,{children:"Sometimes you'll have the target navigator nested in other navigators which aren't part of the deep link. For example, let's say your navigation structure looks like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'function Home() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Profile" component={Profile} />\n      <Tab.Screen name="Feed" component={Feed} />\n    </Tab.Navigator>\n  );\n}\n\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Home" component={Home} />\n      <Stack.Screen name="Settings" component={Settings} />\n    </Stack.Navigator>\n  );\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Here you have a stack navigator in the root, and inside the ",(0,a.jsx)(n.code,{children:"Home"})," screen of the root stack, you have a tab navigator with various screens. With this structure, let's say you want the path ",(0,a.jsx)(n.code,{children:"/users/:id"})," to go to the ",(0,a.jsx)(n.code,{children:"Profile"})," screen. You can express the nested config like so:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this config, you specify that the ",(0,a.jsx)(n.code,{children:"Profile"})," screen should be resolved for the ",(0,a.jsx)(n.code,{children:"users/:id"})," pattern and it's nested inside the ",(0,a.jsx)(n.code,{children:"Home"})," screen. Then parsing ",(0,a.jsx)(n.code,{children:"users/jane"})," will result in the following state object:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        routes: [\n          {\n            name: 'Profile',\n            params: { id: 'jane' },\n          },\n        ],\n      },\n    },\n  ],\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"It's important to note that the state object must match the hierarchy of nested navigators. Otherwise the state will be discarded."}),"\n",(0,a.jsx)(n.h2,{id:"handling-unmatched-routes-or-404",children:"Handling unmatched routes or 404"}),"\n",(0,a.jsx)(n.p,{children:"If your app is opened with an invalid URL, most of the times you'd want to show an error page with some information. On the web, this is commonly known as 404 - or page not found error."}),"\n",(0,a.jsxs)(n.p,{children:["To handle this, you'll need to define a catch-all route that will be rendered if no other routes match the path. You can do it by specifying ",(0,a.jsx)(n.code,{children:"*"})," for the path matching pattern."]}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: 'settings',\n      },\n    },\n    NotFound: '*',\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here, we have defined a route named ",(0,a.jsx)(n.code,{children:"NotFound"})," and set it to match ",(0,a.jsx)(n.code,{children:"*"})," aka everything. If the path didn't match ",(0,a.jsx)(n.code,{children:"user/:id"})," or ",(0,a.jsx)(n.code,{children:"settings"}),", it'll be matched by this route."]}),"\n",(0,a.jsxs)(n.p,{children:["So, a path like ",(0,a.jsx)(n.code,{children:"/library"})," or ",(0,a.jsx)(n.code,{children:"/settings/notification"})," will resolve to the following state object:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [{ name: 'NotFound' }],\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can even go more specific, for example, say if you want to show a different screen for invalid paths under ",(0,a.jsx)(n.code,{children:"/settings"}),", you can specify such a pattern under ",(0,a.jsx)(n.code,{children:"Settings"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: {\n          path: 'settings',\n          screens: {\n            InvalidSettings: '*',\n          },\n        },\n      },\n    },\n    NotFound: '*',\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With this configuration, the path ",(0,a.jsx)(n.code,{children:"/settings/notification"})," will resolve to the following state object:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        index: 1,\n        routes: [\n          { name: 'Feed' },\n          {\n            name: 'Settings',\n            state: {\n              routes: [{ name: 'InvalidSettings' }],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When doing server rendering, you'd also want to return correct status code for 404 errors. See ",(0,a.jsx)(n.a,{href:"/docs/5.x/server-rendering#handling-404-or-other-status-codes",children:"server rendering docs"})," for a guide on how to handle it."]}),"\n",(0,a.jsx)(n.h2,{id:"rendering-an-initial-route",children:"Rendering an initial route"}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes you want to ensure that a certain screen will always be present as the first screen in the navigator's state. You can use the ",(0,a.jsx)(n.code,{children:"initialRouteName"})," property to specify the screen to use for the initial screen."]}),"\n",(0,a.jsxs)(n.p,{children:["In the above example, if you want the ",(0,a.jsx)(n.code,{children:"Feed"})," screen to be the initial route in the navigator under ",(0,a.jsx)(n.code,{children:"Home"}),", your config will look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: 'settings',\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Then, the path ",(0,a.jsx)(n.code,{children:"/users/42"})," will resolve to the following state object:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        index: 1,\n        routes: [\n          { name: 'Feed' },\n          {\n            name: 'Profile',\n            params: { id: '42' },\n          },\n        ],\n      },\n    },\n  ],\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It's not possible to pass params to the initial screen through the URL. So make sure that your initial route doesn't need any params or specify ",(0,a.jsx)(n.code,{children:"initialParams"})," to pass required params."]}),"\n",(0,a.jsxs)(n.p,{children:["In this case, any params in the URL are only passed to the ",(0,a.jsx)(n.code,{children:"Profile"})," screen which matches the path pattern ",(0,a.jsx)(n.code,{children:"users/:id"}),", and the ",(0,a.jsx)(n.code,{children:"Feed"})," screen doesn't receive any params. If you want to have the same params in the ",(0,a.jsx)(n.code,{children:"Feed"})," screen, you can specify a ",(0,a.jsxs)(n.a,{href:"/docs/5.x/navigation-container#linkinggetstatefrompath",children:["custom ",(0,a.jsx)(n.code,{children:"getStateFromPath"})," function"]})," and copy those params."]}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, if you want to access params of a parent screen from a child screen, you can use ",(0,a.jsx)(n.a,{href:"https://reactjs.org/docs/context.html",children:"React Context"})," to expose them."]}),"\n",(0,a.jsx)(n.h2,{id:"matching-exact-paths",children:"Matching exact paths"}),"\n",(0,a.jsx)(n.p,{children:"By default, paths defined for each screen are matched against the URL relative to their parent screen's path. Consider the following config:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: 'feed',\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here, you have a ",(0,a.jsx)(n.code,{children:"path"})," property defined for the ",(0,a.jsx)(n.code,{children:"Home"})," screen, as well as the child ",(0,a.jsx)(n.code,{children:"Profile"})," screen. The profile screen specifies the path ",(0,a.jsx)(n.code,{children:"users/:id"}),", but since it's nested inside a screen with the path ",(0,a.jsx)(n.code,{children:"feed"}),", it'll try to match the pattern ",(0,a.jsx)(n.code,{children:"feed/users/:id"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["This will result in the URL ",(0,a.jsx)(n.code,{children:"/feed"})," navigating to ",(0,a.jsx)(n.code,{children:"Home"})," screen, and ",(0,a.jsx)(n.code,{children:"/feed/users/cal"})," navigating to the ",(0,a.jsx)(n.code,{children:"Profile"})," screen."]}),"\n",(0,a.jsxs)(n.p,{children:["In this case, it makes more sense to navigate to the ",(0,a.jsx)(n.code,{children:"Profile"})," screen using a URL like ",(0,a.jsx)(n.code,{children:"/users/cal"}),", rather than ",(0,a.jsx)(n.code,{children:"/feed/users/cal"}),". To achieve this, you can override the relative matching behavior to ",(0,a.jsx)(n.code,{children:"exact"})," matching:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: 'feed',\n      screens: {\n        Profile: {\n          path: 'users/:id',\n          exact: true,\n        },\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.code,{children:"exact"})," property set to ",(0,a.jsx)(n.code,{children:"true"}),", ",(0,a.jsx)(n.code,{children:"Profile"})," will ignore the parent screen's ",(0,a.jsx)(n.code,{children:"path"})," config and you'll be able to navigate to ",(0,a.jsx)(n.code,{children:"Profile"})," using a URL like ",(0,a.jsx)(n.code,{children:"users/cal"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"omitting-a-screen-from-path",children:"Omitting a screen from path"}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes, you may not want to have the route name of a screen in the path. For example, let's say you have a ",(0,a.jsx)(n.code,{children:"Home"})," screen and our ",(0,a.jsx)(n.a,{href:"/docs/5.x/navigation-state",children:"navigation state"})," looks like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [{ name: 'Home' }],\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When this state is serialized to a path with the following config, you'll get ",(0,a.jsx)(n.code,{children:"/home"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: 'home',\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["But it'll be nicer if the URL was just ",(0,a.jsx)(n.code,{children:"/"})," when visiting the home screen. You can specify an empty string as path or not specify a path at all, and React Navigation won't add the screen to the path (think of it like adding empty string to the path, which doesn't change anything):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: '',\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"serializing-and-parsing-params",children:"Serializing and parsing params"}),"\n",(0,a.jsx)(n.p,{children:"Since URLs are strings, any params you have for routes are also converted to strings when constructing the path."}),"\n",(0,a.jsx)(n.p,{children:"For example, say you have a state like following:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Chat',\n      params: { at: 1589842744264 },\n    },\n  ];\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It'll be converted to ",(0,a.jsx)(n.code,{children:"chat/1589842744264"})," with the following config:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Chat: 'chat/:date',\n  },\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"When parsing this path, you'll get the following state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Chat',\n      params: { date: '1589842744264' },\n    },\n  ];\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here, the ",(0,a.jsx)(n.code,{children:"date"})," param was parsed as a string because React Navigation doesn't know that it's supposed to be a timestamp, and hence number. You can customize it by providing a custom function to use for parsing:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Chat: {\n      path: 'chat/:date',\n      parse: {\n        date: Number,\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can also provide a custom function to serialize the params. For example, let's say that you want to use a DD-MM-YYYY format in the path instead of a timestamp:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Chat: {\n      path: 'chat/:date',\n      parse: {\n        date: (date) => new Date(date).getTime(),\n      },\n      stringify: {\n        date: (date) => {\n          const d = new Date(date);\n\n          return d.getFullYear() + '-' + d.getMonth() + '-' + d.getDate();\n        },\n      },\n    },\n  },\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"Depending on your requirements, you can use this functionality to parse and stringify more complex data."}),"\n",(0,a.jsx)(n.h2,{id:"advanced-cases",children:"Advanced cases"}),"\n",(0,a.jsxs)(n.p,{children:["For some advanced cases, specifying the mapping may not be sufficient. To handle such cases, you can specify a custom function to parse the URL into a state object (",(0,a.jsx)(n.a,{href:"/docs/5.x/navigation-container#linkinggetstatefrompath",children:(0,a.jsx)(n.code,{children:"getStateFromPath"})}),"), and a custom function to serialize the state object into an URL (",(0,a.jsx)(n.a,{href:"/docs/5.x/navigation-container#linkinggetpathfromstate",children:(0,a.jsx)(n.code,{children:"getPathFromState"})}),")."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const linking = {\n  prefixes: ['https://example.com', 'example://'],\n  config: {\n    screens: {\n      Chat: 'feed/:sort',\n    },\n  },\n  getStateFromPath(path, options) {\n    // Return a state object here\n    // You can also reuse the default logic by importing `getStateFromPath` from `@react-navigation/native`\n  },\n  getPathFromState(state, config) {\n    // Return a path string here\n    // You can also reuse the default logic by importing `getPathFromState` from `@react-navigation/native`\n  },\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"updating-config",children:"Updating config"}),"\n",(0,a.jsx)(n.p,{children:"Older versions of React Navigation had a slightly different configuration format for linking. The old config allowed a simple key value pair in the object regardless of nesting of navigators:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  Home: 'home',\n  Feed: 'feed',\n  Profile: 'profile',\n  Settings: 'settings',\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Let's say, your ",(0,a.jsx)(n.code,{children:"Feed"})," and ",(0,a.jsx)(n.code,{children:"Profile"})," screens are nested inside ",(0,a.jsx)(n.code,{children:"Home"}),". Even if you don't have such a nesting with the above configuration, as long as the URL was ",(0,a.jsx)(n.code,{children:"/home/profile"}),", it would work. Furthermore, it would also treat path segments and route names the same, which means that you could deep link to a screen that's not specified in the configuration. For example, if you have a ",(0,a.jsx)(n.code,{children:"Albums"})," screen inside ",(0,a.jsx)(n.code,{children:"Home"}),", the deep link ",(0,a.jsx)(n.code,{children:"/home/Albums"})," would navigate to that screen. While that may be desirable in some cases, there's no way to prevent access to specific screens. This approach also makes it impossible to have something like a 404 screen since any route name is a valid path."]}),"\n",(0,a.jsx)(n.p,{children:"Latest versions of React Navigation use a different config format which is stricter in this regard:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The shape of the config must match the shape of the nesting in the navigation structure"}),"\n",(0,a.jsx)(n.li,{children:"Only screens defined in the config will be eligible for deep linking"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"So, you'd refactor the above config to the following format:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: 'home',\n      screens: {\n        Feed: 'feed',\n        Profile: 'profile',\n      },\n    },\n    Settings: 'settings',\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here, there's a new ",(0,a.jsx)(n.code,{children:"screens"})," property to the configuration object, and the ",(0,a.jsx)(n.code,{children:"Feed"})," and ",(0,a.jsx)(n.code,{children:"Profile"})," configs are now nested under ",(0,a.jsx)(n.code,{children:"Home"})," to match the navigation structure."]}),"\n",(0,a.jsx)(n.p,{children:"If you have the old format, it will continue to work without any changes. However, you won't be able to specify a wildcard pattern to handle unmatched screens or prevent screens from being deep linked. The old format will be removed in the next major release. So we recommend to migrate to the new format when you can."}),"\n",(0,a.jsx)(n.h2,{id:"playground",children:"Playground"}),"\n",(0,a.jsx)(n.p,{children:"You can play around with customizing the config and path below, and see how the path is parsed."}),"\n","\n",(0,a.jsx)(o.A,{}),"\n",(0,a.jsx)(n.h2,{id:"example-app",children:"Example App"}),"\n",(0,a.jsxs)(n.p,{children:["In the example app, you will use the Expo managed workflow. The guide will focus on creating the deep linking configuration and not on creating the components themselves, but you can always check the full implementation in the ",(0,a.jsx)(n.a,{href:"https://github.com/react-navigation/deep-linking-example",children:"github repo"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["First, you need to decide the navigation structure of your app. To keep it simple, the main navigator will be bottom-tabs navigator with two screens. Its first screen will be a simple stack navigator, called ",(0,a.jsx)(n.code,{children:"HomeStack"}),", with two screens: ",(0,a.jsx)(n.code,{children:"Home"})," and ",(0,a.jsx)(n.code,{children:"Profile"}),", and the second tabs screen will be just a simple one without any nested navigators, called ",(0,a.jsx)(n.code,{children:"Settings"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"BottomTabs\n\u251c\u2500\u2500 Stack (HomeStack)\n\u2502\xa0\xa0 \u251c\u2500\u2500 Home\n\u2502\xa0\xa0 \u2514\u2500\u2500 Profile\n\u2514\u2500\u2500 Settings\n"})}),"\n",(0,a.jsx)(n.p,{children:"After creating the navigation structure, you can create a config for deep linking, which will contain mappings for each screen to a path segment. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    HomeStack: {\n      screens: {\n        Home: 'home',\n        Profile: 'user',\n      },\n    },\n    Settings: 'settings',\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As you can see, ",(0,a.jsx)(n.code,{children:"Home"})," and ",(0,a.jsx)(n.code,{children:"Profile"})," are nested in the ",(0,a.jsx)(n.code,{children:"screens"})," property of ",(0,a.jsx)(n.code,{children:"HomeStack"}),". This means that when you pass the ",(0,a.jsx)(n.code,{children:"/home"})," URL, it will be resolved to a ",(0,a.jsx)(n.code,{children:"HomeStack"}),"->",(0,a.jsx)(n.code,{children:"Home"})," state object (similarly for ",(0,a.jsx)(n.code,{children:"/user"})," it would be ",(0,a.jsx)(n.code,{children:"HomeStack"}),"->",(0,a.jsx)(n.code,{children:"Profile"}),"). The nesting in this object should match the nesting of our navigators."]}),"\n",(0,a.jsxs)(n.p,{children:["Here, the ",(0,a.jsx)(n.code,{children:"HomeStack"})," property contains a config object. The config can go as deep as you want, e.g. if ",(0,a.jsx)(n.code,{children:"Home"})," was a navigator, you could make it an object with ",(0,a.jsx)(n.code,{children:"screens"})," property, and put more screens or navigators inside it, making the URL string much more readable."]}),"\n",(0,a.jsxs)(n.p,{children:["What if you wanted a specific screen to used as the initial screen in the navigator? For example, if you had a URL that would open ",(0,a.jsx)(n.code,{children:"Home"})," screen, you would like to be able to navigate to ",(0,a.jsx)(n.code,{children:"Profile"})," from it by using navigation's ",(0,a.jsx)(n.code,{children:"navigation.goBack()"})," method. It is possible by defining ",(0,a.jsx)(n.code,{children:"initialRouteName"})," for a navigator. It would look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    HomeStack: {\n      initialRouteName: 'Profile',\n      screens: {\n        Home: 'home',\n        Profile: 'user',\n      },\n    },\n    Settings: 'settings',\n  },\n};\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},29571:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>LinkingTester});var _docusaurus_theme_common__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(95293),_react_navigation_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(48220),prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(71765),react__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(96540),react_simple_code_editor__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(26069),react_simple_code_editor__WEBPACK_IMPORTED_MODULE_3___default=__webpack_require__.n(react_simple_code_editor__WEBPACK_IMPORTED_MODULE_3__),_RouteMap__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(66715),react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(74848);const parse=value=>eval("(function() { return "+value+"; }())");function Code(e){let{code:n,theme:t,language:i}=e;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__.f4,{code:n,theme:t,language:i,children:e=>{let{className:n,style:t,tokens:i,getLineProps:a,getTokenProps:s}=e;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("pre",{className:n,style:Object.assign({},t,styles.json),children:i.map(((e,n)=>(0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)("div",Object.assign({},a({line:e,key:n}),{key:n}),e.map(((e,n)=>(0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)("span",Object.assign({},s({token:e,key:n}),{key:n})))))))})}})}function LinkingTester(){const{colorMode:e}=(0,_docusaurus_theme_common__WEBPACK_IMPORTED_MODULE_6__.G)(),n="dark"===e?prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__.Zj.dracula:prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__.Zj.github,[t,i]=react__WEBPACK_IMPORTED_MODULE_2__.useState("{\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: {\n          path: 'user/:id',\n          parse: {\n            id: id => id.replace(/^@/, ''),\n          },\n          screens: {\n            Settings: 'edit',\n          },\n        },\n      },\n    },\n    NoMatch: '*',\n  }\n}"),[a,s]=react__WEBPACK_IMPORTED_MODULE_2__.useState("/user/@vergil/edit"),[o,r]=react__WEBPACK_IMPORTED_MODULE_2__.useState((()=>parse(t))),[c,l]=react__WEBPACK_IMPORTED_MODULE_2__.useState("chart");let h,d;try{h=(0,_react_navigation_core__WEBPACK_IMPORTED_MODULE_0__.Bd)(a.replace(/(^\w+:|^)\/\//,""),o),h&&(d=(0,_react_navigation_core__WEBPACK_IMPORTED_MODULE_0__.U6)(h,o))}catch(p){}return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("input",{type:"text",value:a,placeholder:"Type a path, e.g. /user/@vergil/edit",onChange:e=>s(e.target.value),style:Object.assign({},styles.code,styles.input)}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_simple_code_editor__WEBPACK_IMPORTED_MODULE_3___default(),{value:t,placeholder:"Type linking config",onValueChange:e=>{i(e);try{const n=parse(e);r(n)}catch(p){}},highlight:e=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__.f4,{code:e,theme:n,language:"jsx",children:e=>{let{tokens:n,getLineProps:t,getTokenProps:i}=e;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment,{children:n.map(((e,n)=>(0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)("div",Object.assign({},t({line:e,key:n}),{key:n}),e.map(((e,n)=>(0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)("span",Object.assign({},i({token:e,key:n}),{key:n})))))))})}}),padding:16,style:Object.assign({},styles.code,styles.editor)}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div",{style:styles.preview,children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div",{style:styles.toggles,children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("button",{type:"button",style:styles.button,onClick:()=>l("chart"),children:"Chart"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("button",{type:"button",style:styles.button,onClick:()=>l("state"),children:"State"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("button",{type:"button",style:styles.button,onClick:()=>l("action"),children:"Action"})]}),"state"===c?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(Code,{theme:n,code:JSON.stringify(h,null,2)||"",language:"json"}):"action"===c?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(Code,{theme:n,code:JSON.stringify(d,null,2)||"",language:"json"}):"chart"===c?h?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_RouteMap__WEBPACK_IMPORTED_MODULE_4__.A,{routes:h.routes}):(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("p",{style:styles.error,children:"Failed to parse the path. Make sure that the path matches the patterns specified in the config."}):null]})]})}const styles={code:{display:"block",fontFamily:"var(--ifm-font-family-monospace)",fontSize:"var(--ifm-code-font-size)",borderRadius:"var(--ifm-pre-border-radius)",margin:"var(--ifm-spacing-vertical) 0"},input:{display:"block",width:"100%",padding:"var(--ifm-pre-padding)",backgroundColor:"transparent",color:"inherit",border:"1px solid var(--ifm-contents-border-color)"},editor:{border:"1px solid var(--ifm-contents-border-color)"},preview:{position:"relative",border:"1px solid var(--ifm-contents-border-color)",borderRadius:"var(--ifm-pre-border-radius)",minHeight:70},json:{margin:0,fontFamily:"var(--ifm-font-family-monospace)",fontSize:"var(--ifm-code-font-size)",borderRadius:"var(--ifm-pre-border-radius)",padding:"var(--ifm-pre-padding)",minHeight:70},toggles:{position:"absolute",flexDirection:"row",right:0,top:0,borderBottom:"1px solid var(--ifm-contents-border-color)"},button:{border:0,borderLeft:"1px solid var(--ifm-contents-border-color)",borderRadius:0,cursor:"pointer",display:"inline-flex",fontSize:12,margin:0,padding:"4px 8px",color:"inherit",background:"none",MozAppearance:"none",WebkitAppearance:"none"},error:{margin:24,color:"#A12027"}}},66715:(e,n,t)=>{t.d(n,{A:()=>s});t(96540);var i=t(74848);const a="#3F51B5";function s(e){let{routes:n,root:t=!0}=e;return(0,i.jsx)("div",{style:Object.assign({},o.container,t?{overflowX:"auto",padding:"calc(var(--ifm-pre-padding) / 2)"}:null),children:n.map(((e,n)=>(0,i.jsxs)("div",{style:o.item,children:[(0,i.jsxs)("div",{style:o.route,children:[(0,i.jsxs)("div",{style:o.name,children:[e.name,t?null:0===n?(0,i.jsx)("div",{style:o.connectLeft}):(0,i.jsx)("div",{style:o.connectUpLeft})]}),e.params?(0,i.jsxs)("div",{style:o.paramsContainer,children:[(0,i.jsx)("table",{style:o.params,children:(0,i.jsx)("tbody",{children:Object.entries(e.params).map((e=>{let[n,t]=e;return(0,i.jsxs)("tr",{style:o.row,children:[(0,i.jsx)("td",{style:o.key,children:n}),(0,i.jsx)("td",{style:o.colon,children:":"}),(0,i.jsx)("td",{style:o.value,children:JSON.stringify(t)})]},n)}))})}),(0,i.jsx)("div",{style:o.connectUp})]}):null]}),e.state?(0,i.jsx)(s,{routes:e.state.routes,root:!1}):null]},e.name)))})}const o={container:{display:"flex",flexDirection:"column"},item:{display:"flex",flexDirection:"row",alignItems:"flex-start"},route:{minWidth:160},name:{backgroundColor:a,color:"white",fontSize:"var(--ifm-code-font-size)",margin:"calc(var(--ifm-pre-padding) / 2)",padding:"calc(var(--ifm-pre-padding) / 2) var(--ifm-pre-padding)",borderRadius:4,position:"relative",textAlign:"center"},paramsContainer:{position:"relative"},params:{backgroundColor:"rgba(3, 169, 244, 0.08)",border:"1px solid "+a,fontFamily:"var(--ifm-font-family-monospace)",fontSize:"var(--ifm-code-font-size)",margin:"var(--ifm-pre-padding) calc(var(--ifm-pre-padding) / 2)",borderRadius:4,padding:3,width:"auto",overflow:"visible"},row:{border:0,background:"none"},key:{color:"#009688",border:0,padding:"4px 6px",textAlign:"right"},value:{color:"#E91E63",padding:"4px 6px",border:0},colon:{color:"inherit",opacity:.3,border:0,padding:0},connectLeft:{position:"absolute",width:16,height:1,backgroundColor:a,right:"100%",top:"50%"},connectUpLeft:{position:"absolute",width:9,height:52,border:"1px solid "+a,borderRadius:"0 0 0 3px",borderRight:0,borderTop:0,right:"100%",bottom:"50%"},connectUp:{position:"absolute",width:1,height:16,backgroundColor:a,right:"50%",bottom:"100%"}}}}]);