"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[77471],{60043:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"state-persistence","title":"State persistence","description":"You might want to save the user\'s location in the app, so that they are immediately returned to the same location after the app is restarted.","source":"@site/versioned_docs/version-6.x/state-persistence.md","sourceDirName":".","slug":"/state-persistence","permalink":"/docs/6.x/state-persistence","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-6.x/state-persistence.md","tags":[],"version":"6.x","frontMatter":{"id":"state-persistence","title":"State persistence","sidebar_label":"State persistence"},"sidebar":"docs","previous":{"title":"Themes","permalink":"/docs/6.x/themes"},"next":{"title":"Testing with Jest","permalink":"/docs/6.x/testing"}}');var i=n(74848),s=n(28453);const r={id:"state-persistence",title:"State persistence",sidebar_label:"State persistence",rawMarkdown:"---\nid: state-persistence\ntitle: State persistence\nsidebar_label: State persistence\n---\n\nYou might want to save the user's location in the app, so that they are immediately returned to the same location after the app is restarted.\n\nThis is especially valuable during development because it allows the developer to stay on the same screen when they refresh the app.\n\n## Usage\n\nTo be able to persist the [navigation state](navigation-state.md), we can use the `onStateChange` and `initialState` props of the container.\n\n- `onStateChange` - This prop notifies us of any state changes. We can persist the state in this callback.\n- `initialState` - This prop allows us to pass an initial state to use for [navigation state](navigation-state.md). We can pass the restored state in this prop.\n\n<samp id=\"state-persistence\" />\n\n```js\nimport * as React from 'react';\nimport { Linking, Platform } from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { NavigationContainer } from '@react-navigation/native';\n\nconst PERSISTENCE_KEY = 'NAVIGATION_STATE_V1';\n\nexport default function App() {\n  const [isReady, setIsReady] = React.useState(Platform.OS === 'web'); // Don't persist state on web since it's based on URL\n  const [initialState, setInitialState] = React.useState();\n\n  React.useEffect(() => {\n    const restoreState = async () => {\n      try {\n        const initialUrl = await Linking.getInitialURL();\n\n        if (initialUrl == null) {\n          // Only restore state if there's no deep link\n          const savedStateString = await AsyncStorage.getItem(PERSISTENCE_KEY);\n          const state = savedStateString\n            ? JSON.parse(savedStateString)\n            : undefined;\n\n          if (state !== undefined) {\n            setInitialState(state);\n          }\n        }\n      } finally {\n        setIsReady(true);\n      }\n    };\n\n    if (!isReady) {\n      restoreState();\n    }\n  }, [isReady]);\n\n  if (!isReady) {\n    return null;\n  }\n\n  return (\n    <NavigationContainer\n      initialState={initialState}\n      onStateChange={(state) =>\n        AsyncStorage.setItem(PERSISTENCE_KEY, JSON.stringify(state))\n      }\n    >\n      {/* ... */}\n    </NavigationContainer>\n  );\n}\n```\n\n:::warning\n\nIt is recommended to use an [error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) in your app and clear the persisted state if an error occurs. This will ensure that the app doesn't get stuck in an error state if a screen crashes.\n\n:::\n\n### Development Mode\n\nThis feature is particularly useful in development mode. You can enable it selectively using the following approach:\n\n```js\nconst [isReady, setIsReady] = React.useState(__DEV__ ? false : true);\n```\n\nWhile it can be used for production as well, use it with caution as it can make the app unusable if the app is crashing on a particular screen - as the user will still be on the same screen after restarting. So if you are using it in production, make sure to clear the persisted state if an error occurs.\n\n### Loading View\n\nBecause the state is restored asynchronously, the app must render an empty/loading view for a moment before we have the initial state. To handle this, we can return a loading view when `isReady` is `false`:\n\n```js\nif (!isReady) {\n  return <ActivityIndicator />;\n}\n```\n\n## Warning: Serializable State\n\nEach param, route, and navigation state must be fully serializable for this feature to work. Typically, you would serialize the state as a JSON string. This means that your routes and params must contain no functions, class instances, or recursive data structures. React Navigation already [warns you during development](troubleshooting.md#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state) if it encounters non-serializable data, so watch out for the warning if you plan to persist navigation state.\n\nYou can modify the initial state object before passing it to container, but note that if your `initialState` isn't a [valid navigation state](navigation-state.md#partial-state-objects), React Navigation may not be able to handle the situation gracefully.\n"},o=void 0,l={},c=[{value:"Usage",id:"usage",level:2},{value:"Development Mode",id:"development-mode",level:3},{value:"Loading View",id:"loading-view",level:3},{value:"Warning: Serializable State",id:"warning-serializable-state",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"You might want to save the user's location in the app, so that they are immediately returned to the same location after the app is restarted."}),"\n",(0,i.jsx)(t.p,{children:"This is especially valuable during development because it allows the developer to stay on the same screen when they refresh the app."}),"\n",(0,i.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(t.p,{children:["To be able to persist the ",(0,i.jsx)(t.a,{href:"/docs/6.x/navigation-state",children:"navigation state"}),", we can use the ",(0,i.jsx)(t.code,{children:"onStateChange"})," and ",(0,i.jsx)(t.code,{children:"initialState"})," props of the container."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"onStateChange"})," - This prop notifies us of any state changes. We can persist the state in this callback."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"initialState"})," - This prop allows us to pass an initial state to use for ",(0,i.jsx)(t.a,{href:"/docs/6.x/navigation-state",children:"navigation state"}),". We can pass the restored state in this prop."]}),"\n"]}),"\n",(0,i.jsx)("samp",{id:"state-persistence"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import * as React from 'react';\nimport { Linking, Platform } from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { NavigationContainer } from '@react-navigation/native';\n\nconst PERSISTENCE_KEY = 'NAVIGATION_STATE_V1';\n\nexport default function App() {\n  const [isReady, setIsReady] = React.useState(Platform.OS === 'web'); // Don't persist state on web since it's based on URL\n  const [initialState, setInitialState] = React.useState();\n\n  React.useEffect(() => {\n    const restoreState = async () => {\n      try {\n        const initialUrl = await Linking.getInitialURL();\n\n        if (initialUrl == null) {\n          // Only restore state if there's no deep link\n          const savedStateString = await AsyncStorage.getItem(PERSISTENCE_KEY);\n          const state = savedStateString\n            ? JSON.parse(savedStateString)\n            : undefined;\n\n          if (state !== undefined) {\n            setInitialState(state);\n          }\n        }\n      } finally {\n        setIsReady(true);\n      }\n    };\n\n    if (!isReady) {\n      restoreState();\n    }\n  }, [isReady]);\n\n  if (!isReady) {\n    return null;\n  }\n\n  return (\n    <NavigationContainer\n      initialState={initialState}\n      onStateChange={(state) =>\n        AsyncStorage.setItem(PERSISTENCE_KEY, JSON.stringify(state))\n      }\n    >\n      {/* ... */}\n    </NavigationContainer>\n  );\n}\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:["It is recommended to use an ",(0,i.jsx)(t.a,{href:"https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary",children:"error boundary"})," in your app and clear the persisted state if an error occurs. This will ensure that the app doesn't get stuck in an error state if a screen crashes."]})}),"\n",(0,i.jsx)(t.h3,{id:"development-mode",children:"Development Mode"}),"\n",(0,i.jsx)(t.p,{children:"This feature is particularly useful in development mode. You can enable it selectively using the following approach:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const [isReady, setIsReady] = React.useState(__DEV__ ? false : true);\n"})}),"\n",(0,i.jsx)(t.p,{children:"While it can be used for production as well, use it with caution as it can make the app unusable if the app is crashing on a particular screen - as the user will still be on the same screen after restarting. So if you are using it in production, make sure to clear the persisted state if an error occurs."}),"\n",(0,i.jsx)(t.h3,{id:"loading-view",children:"Loading View"}),"\n",(0,i.jsxs)(t.p,{children:["Because the state is restored asynchronously, the app must render an empty/loading view for a moment before we have the initial state. To handle this, we can return a loading view when ",(0,i.jsx)(t.code,{children:"isReady"})," is ",(0,i.jsx)(t.code,{children:"false"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"if (!isReady) {\n  return <ActivityIndicator />;\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"warning-serializable-state",children:"Warning: Serializable State"}),"\n",(0,i.jsxs)(t.p,{children:["Each param, route, and navigation state must be fully serializable for this feature to work. Typically, you would serialize the state as a JSON string. This means that your routes and params must contain no functions, class instances, or recursive data structures. React Navigation already ",(0,i.jsx)(t.a,{href:"/docs/6.x/troubleshooting#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state",children:"warns you during development"})," if it encounters non-serializable data, so watch out for the warning if you plan to persist navigation state."]}),"\n",(0,i.jsxs)(t.p,{children:["You can modify the initial state object before passing it to container, but note that if your ",(0,i.jsx)(t.code,{children:"initialState"})," isn't a ",(0,i.jsx)(t.a,{href:"/docs/6.x/navigation-state#partial-state-objects",children:"valid navigation state"}),", React Navigation may not be able to handle the situation gracefully."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(96540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);