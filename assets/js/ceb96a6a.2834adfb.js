"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[28004],{64004:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=t(85893),a=t(11151);t(74866),t(85162);const o={id:"preventing-going-back",title:"Preventing going back",sidebar_label:"Preventing going back"},s=void 0,i={id:"preventing-going-back",title:"Preventing going back",description:"Sometimes you may want to prevent the user from leaving a screen to avoid losing unsaved changes. There are a couple of things you may want to do in this case:",source:"@site/versioned_docs/version-7.x/preventing-going-back.md",sourceDirName:".",slug:"/preventing-going-back",permalink:"/docs/7.x/preventing-going-back",draft:!1,unlisted:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/preventing-going-back.md",tags:[],version:"7.x",frontMatter:{id:"preventing-going-back",title:"Preventing going back",sidebar_label:"Preventing going back"},sidebar:"docs",previous:{title:"Animating elements between screens",permalink:"/docs/7.x/shared-element-transitions"},next:{title:"Call a function when focused screen changes",permalink:"/docs/7.x/function-after-focusing-screen"}},l={},c=[{value:"Prevent the user from leaving the screen",id:"prevent-the-user-from-leaving-the-screen",level:2},{value:"Prevent the user from leaving the app",id:"prevent-the-user-from-leaving-the-app",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Sometimes you may want to prevent the user from leaving a screen to avoid losing unsaved changes. There are a couple of things you may want to do in this case:"}),"\n",(0,r.jsx)(n.h2,{id:"prevent-the-user-from-leaving-the-screen",children:"Prevent the user from leaving the screen"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"usePreventRemove"})," hook allows you to prevent the user from leaving a screen. See the ",(0,r.jsx)(n.a,{href:"/docs/7.x/use-prevent-remove",children:(0,r.jsx)(n.code,{children:"usePreventRemove"})})," docs for more details."]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Previous approach"}),(0,r.jsx)(n.p,{children:"Previously, the way to do this was to:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Override the back button in the header"}),"\n",(0,r.jsx)(n.li,{children:"Disable back swipe gesture"}),"\n",(0,r.jsx)(n.li,{children:"Override system back button/gesture on Android"}),"\n"]}),(0,r.jsx)(n.p,{children:"However, using the hook has many important differences in addition to being less code:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It's not coupled to any specific buttons, going back from custom buttons will trigger it as well"}),"\n",(0,r.jsx)(n.li,{children:"It's not coupled to any specific actions, any action that removes the route from the state will trigger it"}),"\n",(0,r.jsx)(n.li,{children:"It works across nested navigators, e.g. if the screen is being removed due to an action in the parent navigator"}),"\n",(0,r.jsx)(n.li,{children:"The user can still swipe back in the stack navigator, however, the swipe will be canceled if the event is prevented"}),"\n",(0,r.jsx)(n.li,{children:"It's possible to continue the same action that triggered the event"}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"prevent-the-user-from-leaving-the-app",children:"Prevent the user from leaving the app"}),"\n",(0,r.jsxs)(n.p,{children:["To be able to prompt the user before they leave the app on Android, you can use the ",(0,r.jsx)(n.code,{children:"BackHandler"})," API from React Native:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { Alert, BackHandler } from 'react-native';\n\n// ...\n\nReact.useEffect(() => {\n  const onBackPress = () => {\n    Alert.alert(\n      'Exit App',\n      'Do you want to exit?',\n      [\n        {\n          text: 'Cancel',\n          onPress: () => {\n            // Do nothing\n          },\n          style: 'cancel',\n        },\n        { text: 'YES', onPress: () => BackHandler.exitApp() },\n      ],\n      { cancelable: false }\n    );\n\n    return true;\n  };\n\n  const backHandler = BackHandler.addEventListener(\n    'hardwareBackPress',\n    onBackPress\n  );\n\n  return () => backHandler.remove();\n}, []);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["On the Web, you can use the ",(0,r.jsx)(n.code,{children:"beforeunload"})," event to prompt the user before they leave the browser tab:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"React.useEffect(() => {\n  const onBeforeUnload = (event) => {\n    // Prevent the user from leaving the page\n    event.preventDefault();\n    event.returnValue = true;\n  };\n\n  window.addEventListener('beforeunload', onBeforeUnload);\n\n  return () => {\n    window.removeEventListener('beforeunload', onBeforeUnload);\n  };\n}, []);\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"The user can still close the app by swiping it away from the app switcher or closing the browser tab. Or the app can be closed by the system due to low memory or other reasons. It's also not possible to prevent leaving the app on iOS. We recommend persisting the data and restoring it when the app is opened again instead of prompting the user before they leave the app."})})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},85162:(e,n,t)=>{t.d(n,{Z:()=>s});t(67294);var r=t(86010);const a={tabItem:"tabItem_Ymn6"};var o=t(85893);function s(e){let{children:n,hidden:t,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.Z)(a.tabItem,s),hidden:t,children:n})}},74866:(e,n,t)=>{t.d(n,{Z:()=>k});var r=t(67294),a=t(86010),o=t(12466),s=t(16550),i=t(20469),l=t(91980),c=t(67392),u=t(50012);function d(e){var n,t;return null!=(n=null==(t=r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=null!=n?n:function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:a}}=e;return{value:n,label:t,attributes:r,default:a}}))}(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function v(e){let{queryString:n=!1,groupId:t}=e;const a=(0,s.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l._X)(o),(0,r.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(a.location.search);n.set(o,e),a.replace({...a.location,search:n.toString()})}),[o,a])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,o=h(e),[s,l]=(0,r.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+r.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const a=null!=(n=r.find((e=>e.default)))?n:r[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[c,d]=v({queryString:t,groupId:a}),[g,m]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[a,o]=(0,u.Nk)(t);return[a,(0,r.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:a}),f=(()=>{const e=null!=c?c:g;return p({value:e,tabValues:o})?e:null})();(0,i.Z)((()=>{f&&l(f)}),[f]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error("Can't select invalid tab value="+e);l(e),d(e),m(e)}),[d,m,o]),tabValues:o}}var m=t(72389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(85893);function x(e){let{className:n,block:t,selectedValue:r,selectValue:s,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),u=e=>{const n=e.currentTarget,t=l.indexOf(n),a=i[t].value;a!==r&&(c(n),s(a))},d=e=>{var n;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var r;const n=l.indexOf(e.currentTarget)+1;t=null!=(r=l[n])?r:l[0];break}case"ArrowLeft":{var a;const n=l.indexOf(e.currentTarget)-1;t=null!=(a=l[n])?a:l[l.length-1];break}}null==(n=t)||n.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>l.push(e),onKeyDown:d,onClick:u,...o,className:(0,a.Z)("tabs__item",f.tabItem,null==o?void 0:o.className,{"tabs__item--active":r===n}),children:null!=t?t:n},n)}))})}function w(e){let{lazy:n,children:t,selectedValue:a}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function y(e){const n=g(e);return(0,b.jsxs)("div",{className:(0,a.Z)("tabs-container",f.tabList),children:[(0,b.jsx)(x,{...e,...n}),(0,b.jsx)(w,{...e,...n})]})}function k(e){const n=(0,m.Z)();return(0,b.jsx)(y,{...e,children:d(e.children)},String(n))}},11151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>s});var r=t(67294);const a={},o=r.createContext(a);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);