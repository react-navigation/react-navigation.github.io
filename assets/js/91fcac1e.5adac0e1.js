"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[51182],{45521:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>c,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"state-persistence","title":"State persistence","description":"You might want to save the user\'s location in the app, so that they are immediately returned to the same location after the app is restarted.","source":"@site/versioned_docs/version-8.x/state-persistence.md","sourceDirName":".","slug":"/state-persistence","permalink":"/docs/8.x/state-persistence","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-8.x/state-persistence.md","tags":[],"version":"8.x","frontMatter":{"id":"state-persistence","title":"State persistence","sidebar_label":"State persistence"},"sidebar":"docs","previous":{"title":"Configuring links","permalink":"/docs/8.x/configuring-links"},"next":{"title":"Web support","permalink":"/docs/8.x/web-support"}}');var r=t(74848),i=t(28453),o=t(11470),s=t(19365);const c={id:"state-persistence",title:"State persistence",sidebar_label:"State persistence",rawMarkdown:"---\nid: state-persistence\ntitle: State persistence\nsidebar_label: State persistence\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nYou might want to save the user's location in the app, so that they are immediately returned to the same location after the app is restarted.\n\nThis is especially valuable during development because it allows the developer to stay on the same screen when they refresh the app.\n\n## Usage\n\nTo be able to persist the [navigation state](navigation-state.md), we can use the `persistor` prop of the container. The `persistor` prop accepts an object with two functions:\n\n- `persist` - Function that receives the navigation state as an argument and should save it to storage.\n- `restore` - Function that returns the previously saved state from storage, or `undefined` if there's no saved state.\n\nThese function can be both synchronous or asynchronous. If a promise is returned from the `restore` function, make sure to provide a [`fallback`](navigation-container.md#fallback).\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js name=\"Persisting the navigation state\" snack dependencies=@react-native-async-storage/async-storage\nimport * as React from 'react';\n// codeblock-focus-start\nimport { View, Text } from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport {\n  useNavigation,\n  createStaticNavigation,\n} from '@react-navigation/native';\n// codeblock-focus-end\nimport { Button } from '@react-navigation/elements';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nfunction A() {\n  return <View />;\n}\n\nfunction B() {\n  const navigation = useNavigation('B');\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Button onPress={() => navigation.navigate('C')}>Go to C</Button>\n    </View>\n  );\n}\n\nfunction C() {\n  const navigation = useNavigation('C');\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Button onPress={() => navigation.navigate('D')}>Go to D</Button>\n    </View>\n  );\n}\n\nfunction D() {\n  return <View />;\n}\n\nconst HomeStackScreen = createNativeStackNavigator({\n  screens: {\n    A: A,\n  },\n});\n\nconst SettingsStackScreen = createNativeStackNavigator({\n  screens: {\n    B: B,\n    C: C,\n    D: D,\n  },\n});\n\nconst Tab = createBottomTabNavigator({\n  screens: {\n    Home: {\n      screen: HomeStackScreen,\n      options: {\n        headerShown: false,\n        tabBarLabel: 'Home!',\n      },\n    },\n    Settings: {\n      screen: SettingsStackScreen,\n      options: {\n        headerShown: false,\n        tabBarLabel: 'Settings!',\n      },\n    },\n  },\n});\n\nconst Navigation = createStaticNavigation(Tab);\n\n// codeblock-focus-start\n\nconst PERSISTENCE_KEY = 'NAVIGATION_STATE_V1';\n\nexport default function App() {\n  return (\n    <Navigation\n      fallback={<Text>Loading...</Text>}\n      persistor={{\n        async persist(state) {\n          await AsyncStorage.setItem(PERSISTENCE_KEY, JSON.stringify(state));\n        },\n        async restore() {\n          const state = await AsyncStorage.getItem(PERSISTENCE_KEY);\n\n          return state ? JSON.parse(state) : undefined;\n        },\n      }}\n    />\n  );\n}\n// codeblock-focus-end\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js name=\"Persisting the navigation state\" snack dependencies=@react-native-async-storage/async-storage\nimport * as React from 'react';\n// codeblock-focus-start\nimport { View, Text } from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { NavigationContainer, useNavigation } from '@react-navigation/native';\n// codeblock-focus-end\nimport { Button } from '@react-navigation/elements';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst Tab = createBottomTabNavigator();\nconst HomeStack = createNativeStackNavigator();\nconst SettingsStack = createNativeStackNavigator();\n\nfunction A() {\n  return <View />;\n}\n\nfunction B() {\n  const navigation = useNavigation('B');\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Button onPress={() => navigation.navigate('C')}>Go to C</Button>\n    </View>\n  );\n}\n\nfunction C() {\n  const navigation = useNavigation('C');\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Button onPress={() => navigation.navigate('D')}>Go to D</Button>\n    </View>\n  );\n}\n\nfunction D() {\n  return <View />;\n}\n\nfunction HomeStackScreen() {\n  return (\n    <HomeStack.Navigator>\n      <HomeStack.Screen name=\"A\" component={A} />\n    </HomeStack.Navigator>\n  );\n}\n\nfunction SettingsStackScreen() {\n  return (\n    <SettingsStack.Navigator>\n      <SettingsStack.Screen name=\"B\" component={B} />\n      <SettingsStack.Screen name=\"C\" component={C} />\n      <SettingsStack.Screen name=\"D\" component={D} />\n    </SettingsStack.Navigator>\n  );\n}\n\nfunction RootTabs() {\n  return (\n    <Tab.Navigator screenOptions={{ headerShown: false }}>\n      <Tab.Screen\n        name=\"Home\"\n        component={HomeStackScreen}\n        options={{ tabBarLabel: 'Home!' }}\n      />\n      <Tab.Screen\n        name=\"Settings\"\n        component={SettingsStackScreen}\n        options={{ tabBarLabel: 'Settings!' }}\n      />\n    </Tab.Navigator>\n  );\n}\n\n// codeblock-focus-start\n\nconst PERSISTENCE_KEY = 'NAVIGATION_STATE_V1';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      fallback={<Text>Loading...</Text>}\n      persistor={{\n        async persist(state) {\n          await AsyncStorage.setItem(PERSISTENCE_KEY, JSON.stringify(state));\n        },\n        async restore() {\n          const state = await AsyncStorage.getItem(PERSISTENCE_KEY);\n\n          return state ? JSON.parse(state) : undefined;\n        },\n      }}\n    >\n      <RootTabs />\n    </NavigationContainer>\n  );\n}\n// codeblock-focus-end\n```\n\n</TabItem>\n</Tabs>\n\nThis feature is particularly useful in development mode. You can enable it selectively by providing the `persistor` prop only if `__DEV__` is `true`.\n\nWhile it can be used for production as well, use it with caution as it can make the app unusable if the app is crashing on a particular screen - as the user will still be on the same screen after restarting. So if you are using it in production, make sure to clear the persisted state if an error occurs.\n\n:::warning\n\nIt is recommended to use an [error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) in your app and clear the persisted state if an error occurs. This will ensure that the app doesn't get stuck in an error state if a screen crashes.\n\n:::\n\nAlternatively, you can manually implement it using the `initialState` and `onStateChange` props. Make sure to not provide an `initialState` if there is a deep link to handle, otherwise the deep link will be ignored.\n\n## Warning: Serializable State\n\nEach param, route, and navigation state must be fully serializable for this feature to work. Typically, you would serialize the state as a JSON string. This means that your routes and params must contain no functions, class instances, or recursive data structures. React Navigation already [warns you during development](troubleshooting.md#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state) if it encounters non-serializable data, so watch out for the warning if you plan to persist navigation state.\n\nYou can modify the initial state object before passing it to container, but note that if your `initialState` isn't a [valid navigation state](navigation-state.md#stale-state-objects), React Navigation may not be able to handle the situation gracefully in some scenarios.\n"},l=void 0,u={},d=[{value:"Usage",id:"usage",level:2},{value:"Warning: Serializable State",id:"warning-serializable-state",level:2}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"You might want to save the user's location in the app, so that they are immediately returned to the same location after the app is restarted."}),"\n",(0,r.jsx)(n.p,{children:"This is especially valuable during development because it allows the developer to stay on the same screen when they refresh the app."}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:["To be able to persist the ",(0,r.jsx)(n.a,{href:"/docs/8.x/navigation-state",children:"navigation state"}),", we can use the ",(0,r.jsx)(n.code,{children:"persistor"})," prop of the container. The ",(0,r.jsx)(n.code,{children:"persistor"})," prop accepts an object with two functions:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"persist"})," - Function that receives the navigation state as an argument and should save it to storage."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"restore"})," - Function that returns the previously saved state from storage, or ",(0,r.jsx)(n.code,{children:"undefined"})," if there's no saved state."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["These function can be both synchronous or asynchronous. If a promise is returned from the ",(0,r.jsx)(n.code,{children:"restore"})," function, make sure to provide a ",(0,r.jsx)(n.a,{href:"/docs/8.x/navigation-container#fallback",children:(0,r.jsx)(n.code,{children:"fallback"})}),"."]}),"\n",(0,r.jsxs)(o.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{"data-name":"Persisting the navigation state","data-snack":"true","data-dependencies":"@react-native-async-storage/async-storage",children:(0,r.jsx)(n.code,{className:"language-js",metastring:'name="Persisting the navigation state" snack dependencies=@react-native-async-storage/async-storage',children:"import * as React from 'react';\n// codeblock-focus-start\nimport { View, Text } from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport {\n  useNavigation,\n  createStaticNavigation,\n} from '@react-navigation/native';\n// codeblock-focus-end\nimport { Button } from '@react-navigation/elements';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nfunction A() {\n  return <View />;\n}\n\nfunction B() {\n  const navigation = useNavigation('B');\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Button onPress={() => navigation.navigate('C')}>Go to C</Button>\n    </View>\n  );\n}\n\nfunction C() {\n  const navigation = useNavigation('C');\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Button onPress={() => navigation.navigate('D')}>Go to D</Button>\n    </View>\n  );\n}\n\nfunction D() {\n  return <View />;\n}\n\nconst HomeStackScreen = createNativeStackNavigator({\n  screens: {\n    A: A,\n  },\n});\n\nconst SettingsStackScreen = createNativeStackNavigator({\n  screens: {\n    B: B,\n    C: C,\n    D: D,\n  },\n});\n\nconst Tab = createBottomTabNavigator({\n  screens: {\n    Home: {\n      screen: HomeStackScreen,\n      options: {\n        headerShown: false,\n        tabBarLabel: 'Home!',\n      },\n    },\n    Settings: {\n      screen: SettingsStackScreen,\n      options: {\n        headerShown: false,\n        tabBarLabel: 'Settings!',\n      },\n    },\n  },\n});\n\nconst Navigation = createStaticNavigation(Tab);\n\n// codeblock-focus-start\n\nconst PERSISTENCE_KEY = 'NAVIGATION_STATE_V1';\n\nexport default function App() {\n  return (\n    <Navigation\n      fallback={<Text>Loading...</Text>}\n      persistor={{\n        async persist(state) {\n          await AsyncStorage.setItem(PERSISTENCE_KEY, JSON.stringify(state));\n        },\n        async restore() {\n          const state = await AsyncStorage.getItem(PERSISTENCE_KEY);\n\n          return state ? JSON.parse(state) : undefined;\n        },\n      }}\n    />\n  );\n}\n// codeblock-focus-end\n"})})}),(0,r.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{"data-name":"Persisting the navigation state","data-snack":"true","data-dependencies":"@react-native-async-storage/async-storage",children:(0,r.jsx)(n.code,{className:"language-js",metastring:'name="Persisting the navigation state" snack dependencies=@react-native-async-storage/async-storage',children:"import * as React from 'react';\n// codeblock-focus-start\nimport { View, Text } from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { NavigationContainer, useNavigation } from '@react-navigation/native';\n// codeblock-focus-end\nimport { Button } from '@react-navigation/elements';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst Tab = createBottomTabNavigator();\nconst HomeStack = createNativeStackNavigator();\nconst SettingsStack = createNativeStackNavigator();\n\nfunction A() {\n  return <View />;\n}\n\nfunction B() {\n  const navigation = useNavigation('B');\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Button onPress={() => navigation.navigate('C')}>Go to C</Button>\n    </View>\n  );\n}\n\nfunction C() {\n  const navigation = useNavigation('C');\n\n  return (\n    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>\n      <Button onPress={() => navigation.navigate('D')}>Go to D</Button>\n    </View>\n  );\n}\n\nfunction D() {\n  return <View />;\n}\n\nfunction HomeStackScreen() {\n  return (\n    <HomeStack.Navigator>\n      <HomeStack.Screen name=\"A\" component={A} />\n    </HomeStack.Navigator>\n  );\n}\n\nfunction SettingsStackScreen() {\n  return (\n    <SettingsStack.Navigator>\n      <SettingsStack.Screen name=\"B\" component={B} />\n      <SettingsStack.Screen name=\"C\" component={C} />\n      <SettingsStack.Screen name=\"D\" component={D} />\n    </SettingsStack.Navigator>\n  );\n}\n\nfunction RootTabs() {\n  return (\n    <Tab.Navigator screenOptions={{ headerShown: false }}>\n      <Tab.Screen\n        name=\"Home\"\n        component={HomeStackScreen}\n        options={{ tabBarLabel: 'Home!' }}\n      />\n      <Tab.Screen\n        name=\"Settings\"\n        component={SettingsStackScreen}\n        options={{ tabBarLabel: 'Settings!' }}\n      />\n    </Tab.Navigator>\n  );\n}\n\n// codeblock-focus-start\n\nconst PERSISTENCE_KEY = 'NAVIGATION_STATE_V1';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      fallback={<Text>Loading...</Text>}\n      persistor={{\n        async persist(state) {\n          await AsyncStorage.setItem(PERSISTENCE_KEY, JSON.stringify(state));\n        },\n        async restore() {\n          const state = await AsyncStorage.getItem(PERSISTENCE_KEY);\n\n          return state ? JSON.parse(state) : undefined;\n        },\n      }}\n    >\n      <RootTabs />\n    </NavigationContainer>\n  );\n}\n// codeblock-focus-end\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["This feature is particularly useful in development mode. You can enable it selectively by providing the ",(0,r.jsx)(n.code,{children:"persistor"})," prop only if ",(0,r.jsx)(n.code,{children:"__DEV__"})," is ",(0,r.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"While it can be used for production as well, use it with caution as it can make the app unusable if the app is crashing on a particular screen - as the user will still be on the same screen after restarting. So if you are using it in production, make sure to clear the persisted state if an error occurs."}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["It is recommended to use an ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary",children:"error boundary"})," in your app and clear the persisted state if an error occurs. This will ensure that the app doesn't get stuck in an error state if a screen crashes."]})}),"\n",(0,r.jsxs)(n.p,{children:["Alternatively, you can manually implement it using the ",(0,r.jsx)(n.code,{children:"initialState"})," and ",(0,r.jsx)(n.code,{children:"onStateChange"})," props. Make sure to not provide an ",(0,r.jsx)(n.code,{children:"initialState"})," if there is a deep link to handle, otherwise the deep link will be ignored."]}),"\n",(0,r.jsx)(n.h2,{id:"warning-serializable-state",children:"Warning: Serializable State"}),"\n",(0,r.jsxs)(n.p,{children:["Each param, route, and navigation state must be fully serializable for this feature to work. Typically, you would serialize the state as a JSON string. This means that your routes and params must contain no functions, class instances, or recursive data structures. React Navigation already ",(0,r.jsx)(n.a,{href:"/docs/8.x/troubleshooting#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state",children:"warns you during development"})," if it encounters non-serializable data, so watch out for the warning if you plan to persist navigation state."]}),"\n",(0,r.jsxs)(n.p,{children:["You can modify the initial state object before passing it to container, but note that if your ",(0,r.jsx)(n.code,{children:"initialState"})," isn't a ",(0,r.jsx)(n.a,{href:"/docs/8.x/navigation-state#stale-state-objects",children:"valid navigation state"}),", React Navigation may not be able to handle the situation gracefully in some scenarios."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>o});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var i=t(74848);function o(e){let{children:n,hidden:t,className:o}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,o),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>w});var a=t(96540),r=t(34164),i=t(17559),o=t(23104),s=t(56347),c=t(205),l=t(57485),u=t(31682),d=t(70679);function g(e){var n,t;return null!=(n=null==(t=a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:function(e){return g(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,u.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace(Object.assign({},r.location,{search:n.toString()}))}),[i,r])]}function v(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=p(e),[o,s]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(n=a.find((e=>e.default)))?n:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[l,u]=h({queryString:t,groupId:r}),[g,v]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[r,i]=(0,d.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),f=(()=>{const e=null!=l?l:g;return m({value:e,tabValues:i})?e:null})();(0,c.A)((()=>{f&&s(f)}),[f]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error("Can't select invalid tab value="+e);s(e),u(e),v(e)}),[u,v,i]),tabValues:i}}var f=t(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var S=t(74848);function y(e){let{className:n,block:t,selectedValue:a,selectValue:i,tabValues:s}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.a_)(),u=e=>{const n=e.currentTarget,t=c.indexOf(n),r=s[t].value;r!==a&&(l(n),i(r))},d=e=>{var n;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var a;const n=c.indexOf(e.currentTarget)+1;t=null!=(a=c[n])?a:c[0];break}case"ArrowLeft":{var r;const n=c.indexOf(e.currentTarget)-1;t=null!=(r=c[n])?r:c[c.length-1];break}}null==(n=t)||n.focus()};return(0,S.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:s.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,S.jsx)("li",Object.assign({role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{c.push(e)},onKeyDown:d,onClick:u},i,{className:(0,r.A)("tabs__item",b.tabItem,null==i?void 0:i.className,{"tabs__item--active":a===n}),children:null!=t?t:n}),n)}))})}function k(e){let{lazy:n,children:t,selectedValue:i}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,S.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function N(e){const n=v(e);return(0,S.jsxs)("div",{className:(0,r.A)(i.G.tabs.container,"tabs-container",b.tabList),children:[(0,S.jsx)(y,Object.assign({},n,e)),(0,S.jsx)(k,Object.assign({},n,e))]})}function w(e){const n=(0,f.A)();return(0,S.jsx)(N,Object.assign({},e,{children:g(e.children)}),String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);