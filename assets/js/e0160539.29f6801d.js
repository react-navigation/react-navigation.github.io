"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[48600],{82019:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"custom-routers","title":"Custom routers","description":"The router object provides various helper methods to deal with the state and actions, a reducer to update the state as well as some action creators.","source":"@site/versioned_docs/version-7.x/custom-routers.md","sourceDirName":".","slug":"/custom-routers","permalink":"/docs/custom-routers","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/custom-routers.md","tags":[],"version":"7.x","frontMatter":{"id":"custom-routers","title":"Custom routers","sidebar_label":"Custom routers"},"sidebar":"docs","previous":{"title":"TabActions","permalink":"/docs/tab-actions"},"next":{"title":"Custom navigators","permalink":"/docs/custom-navigators"}}');var a=n(74848),r=n(28453);const s={id:"custom-routers",title:"Custom routers",sidebar_label:"Custom routers",rawMarkdown:"---\nid: custom-routers\ntitle: Custom routers\nsidebar_label: Custom routers\n---\n\nThe router object provides various helper methods to deal with the state and actions, a reducer to update the state as well as some action creators.\n\nThe router is responsible for handling actions dispatched by calling methods on the navigation object. If the router cannot handle an action, it can return `null`, which would propagate the action to other routers until it's handled.\n\nYou can make your own router by building an object with the following functions:\n\n- `type` - String representing the type of the router, e.g. `'stack'`, `'tab'`, `'drawer'` etc.\n- `getInitialState` - Function that returns the initial state for the navigator. Receives an options object with `routeNames` and `routeParamList` properties.\n- `getRehydratedState` - Function that rehydrates the full [navigation state](navigation-state.md) from a given partial state. Receives a partial state object and an options object with `routeNames` and `routeParamList` properties.\n- `getStateForRouteNamesChange` - Function that takes the current state and updated list of route names, and returns a new state. Receives the state object and an options object with `routeNames` and `routeParamList` properties.\n- `getStateForAction` - Reducer function that takes the current state and action along with an options object with `routeNames` and `routeParamList` properties, and returns a new state. If the action cannot be handled, it should return `null`.\n- `getStateForRouteFocus` - Function that takes the current state and key of a route, and returns a new state with that route focused.\n- `shouldActionChangeFocus` - Function that determines whether the action should also change focus in parent navigator. Some actions such as `NAVIGATE` can change focus in the parent.\n- `actionCreators` - Optional object containing a list of action creators, such as `push`, `pop` etc. These will be used to add helper methods to the `navigation` object to dispatch those actions.\n\n:::info\n\nThe functions in the router object should be pure functions, i.e. they should not have any side-effects, mutate parameters or external variables, and should return the same output for the same input.\n\n:::\n\nExample:\n\n```js\nconst router = {\n  type: 'tab',\n\n  getInitialState({ routeNames, routeParamList }) {\n    const index =\n      options.initialRouteName === undefined\n        ? 0\n        : routeNames.indexOf(options.initialRouteName);\n\n    return {\n      stale: false,\n      type: 'tab',\n      key: shortid(),\n      index,\n      routeNames,\n      routes: routeNames.map(name => ({\n        name,\n        key: name,\n        params: routeParamList[name],\n      })),\n    };\n  },\n\n  getRehydratedState(partialState, { routeNames, routeParamList }) {\n    const state = partialState;\n\n    if (state.stale === false) {\n      return state as NavigationState;\n    }\n\n    const routes = state.routes\n      .filter(route => routeNames.includes(route.name))\n      .map(\n        route =>\n          ({\n            ...route,\n            key: route.key || `${route.name}-${shortid()}`,\n            params:\n              routeParamList[route.name] !== undefined\n                ? {\n                    ...routeParamList[route.name],\n                    ...route.params,\n                  }\n                : route.params,\n          } as Route<string>)\n      );\n\n    return {\n      stale: false,\n      type: 'tab',\n      key: shortid(),\n      index:\n        typeof state.index === 'number' && state.index < routes.length\n          ? state.index\n          : 0,\n      routeNames,\n      routes,\n    };\n  },\n\n  getStateForRouteNamesChange(state, { routeNames }) {\n    const routes = state.routes.filter(route =>\n      routeNames.includes(route.name)\n    );\n\n    return {\n      ...state,\n      routeNames,\n      routes,\n      index: Math.min(state.index, routes.length - 1),\n    };\n  },\n\n  getStateForRouteFocus(state, key) {\n    const index = state.routes.findIndex(r => r.key === key);\n\n    if (index === -1 || index === state.index) {\n      return state;\n    }\n\n    return { ...state, index };\n  },\n\n  getStateForAction(state, action) {\n    switch (action.type) {\n      case 'NAVIGATE': {\n        const index = state.routes.findIndex(\n          route => route.name === action.payload.name\n        );\n\n        if (index === -1) {\n          return null;\n        }\n\n        return { ...state, index };\n      }\n\n      default:\n        return BaseRouter.getStateForAction(state, action);\n    }\n  },\n\n  shouldActionChangeFocus() {\n    return false;\n  },\n};\n\nconst SimpleRouter = () => router;\n\nexport default SimpleRouter;\n```\n\n## Built-In Routers\n\nThe library ships with a few standard routers:\n\n- `StackRouter`\n- `TabRouter`\n- `DrawerRouter`\n\n## Customizing Routers\n\nThere are two main ways to customize routers:\n\n- Override an existing router with the [`UNSTABLE_router`](navigator.md#router) prop on navigators\n- Customized navigators with a custom router, see [extending navigators](custom-navigators.md#extending-navigators)\n\n### Custom Navigation Actions\n\nLet's say you want to add a custom action to clear the history:\n\n```js\nimport { TabRouter } from '@react-navigation/native';\n\nconst MyTabRouter = (options) => {\n  const router = TabRouter(options);\n\n  return {\n    ...router,\n    getStateForAction(state, action, options) {\n      switch (action.type) {\n        case 'CLEAR_HISTORY':\n          return {\n            ...state,\n            routeKeyHistory: [],\n          };\n        default:\n          return router.getStateForAction(state, action, options);\n      }\n    },\n\n    actionCreators: {\n      ...router.actionCreators,\n      clearHistory() {\n        return { type: 'CLEAR_HISTORY' };\n      },\n    },\n  };\n};\n```\n\nInstead of writing a custom router to handle custom actions, you can [pass a function to `dispatch`](navigation-object.md#dispatch) instead. It's cleaner and recommended instead of overriding routers.\n\n### Blocking Navigation Actions\n\nSometimes you may want to prevent some navigation activity, depending on your route. Let's say, you want to prevent pushing a new screen if `isEditing` is `true`:\n\n```js\nimport { StackRouter } from '@react-navigation/native';\n\nconst MyStackRouter = (options) => {\n  const router = StackRouter(options);\n\n  return {\n    ...router,\n    getStateForAction(state, action, options) {\n      const result = router.getStateForAction(state, action, options);\n\n      if (\n        result != null &&\n        result.index > state.index &&\n        state.routes[state.index].params?.isEditing\n      ) {\n        // Returning the current state means that the action has been handled, but we don't have a new state\n        return state;\n      }\n\n      return result;\n    },\n  };\n};\n```\n\nIf you want to prevent going back, the recommended approach is to use the [`usePreventRemove` hook](preventing-going-back.md).\n"},i=void 0,u={},c=[{value:"Built-In Routers",id:"built-in-routers",level:2},{value:"Customizing Routers",id:"customizing-routers",level:2},{value:"Custom Navigation Actions",id:"custom-navigation-actions",level:3},{value:"Blocking Navigation Actions",id:"blocking-navigation-actions",level:3}];function d(t){const e={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...t.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.p,{children:"The router object provides various helper methods to deal with the state and actions, a reducer to update the state as well as some action creators."}),"\n",(0,a.jsxs)(e.p,{children:["The router is responsible for handling actions dispatched by calling methods on the navigation object. If the router cannot handle an action, it can return ",(0,a.jsx)(e.code,{children:"null"}),", which would propagate the action to other routers until it's handled."]}),"\n",(0,a.jsx)(e.p,{children:"You can make your own router by building an object with the following functions:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"type"})," - String representing the type of the router, e.g. ",(0,a.jsx)(e.code,{children:"'stack'"}),", ",(0,a.jsx)(e.code,{children:"'tab'"}),", ",(0,a.jsx)(e.code,{children:"'drawer'"})," etc."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"getInitialState"})," - Function that returns the initial state for the navigator. Receives an options object with ",(0,a.jsx)(e.code,{children:"routeNames"})," and ",(0,a.jsx)(e.code,{children:"routeParamList"})," properties."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"getRehydratedState"})," - Function that rehydrates the full ",(0,a.jsx)(e.a,{href:"/docs/navigation-state",children:"navigation state"})," from a given partial state. Receives a partial state object and an options object with ",(0,a.jsx)(e.code,{children:"routeNames"})," and ",(0,a.jsx)(e.code,{children:"routeParamList"})," properties."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"getStateForRouteNamesChange"})," - Function that takes the current state and updated list of route names, and returns a new state. Receives the state object and an options object with ",(0,a.jsx)(e.code,{children:"routeNames"})," and ",(0,a.jsx)(e.code,{children:"routeParamList"})," properties."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"getStateForAction"})," - Reducer function that takes the current state and action along with an options object with ",(0,a.jsx)(e.code,{children:"routeNames"})," and ",(0,a.jsx)(e.code,{children:"routeParamList"})," properties, and returns a new state. If the action cannot be handled, it should return ",(0,a.jsx)(e.code,{children:"null"}),"."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"getStateForRouteFocus"})," - Function that takes the current state and key of a route, and returns a new state with that route focused."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"shouldActionChangeFocus"})," - Function that determines whether the action should also change focus in parent navigator. Some actions such as ",(0,a.jsx)(e.code,{children:"NAVIGATE"})," can change focus in the parent."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"actionCreators"})," - Optional object containing a list of action creators, such as ",(0,a.jsx)(e.code,{children:"push"}),", ",(0,a.jsx)(e.code,{children:"pop"})," etc. These will be used to add helper methods to the ",(0,a.jsx)(e.code,{children:"navigation"})," object to dispatch those actions."]}),"\n"]}),"\n",(0,a.jsx)(e.admonition,{type:"info",children:(0,a.jsx)(e.p,{children:"The functions in the router object should be pure functions, i.e. they should not have any side-effects, mutate parameters or external variables, and should return the same output for the same input."})}),"\n",(0,a.jsx)(e.p,{children:"Example:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"const router = {\n  type: 'tab',\n\n  getInitialState({ routeNames, routeParamList }) {\n    const index =\n      options.initialRouteName === undefined\n        ? 0\n        : routeNames.indexOf(options.initialRouteName);\n\n    return {\n      stale: false,\n      type: 'tab',\n      key: shortid(),\n      index,\n      routeNames,\n      routes: routeNames.map(name => ({\n        name,\n        key: name,\n        params: routeParamList[name],\n      })),\n    };\n  },\n\n  getRehydratedState(partialState, { routeNames, routeParamList }) {\n    const state = partialState;\n\n    if (state.stale === false) {\n      return state as NavigationState;\n    }\n\n    const routes = state.routes\n      .filter(route => routeNames.includes(route.name))\n      .map(\n        route =>\n          ({\n            ...route,\n            key: route.key || `${route.name}-${shortid()}`,\n            params:\n              routeParamList[route.name] !== undefined\n                ? {\n                    ...routeParamList[route.name],\n                    ...route.params,\n                  }\n                : route.params,\n          } as Route<string>)\n      );\n\n    return {\n      stale: false,\n      type: 'tab',\n      key: shortid(),\n      index:\n        typeof state.index === 'number' && state.index < routes.length\n          ? state.index\n          : 0,\n      routeNames,\n      routes,\n    };\n  },\n\n  getStateForRouteNamesChange(state, { routeNames }) {\n    const routes = state.routes.filter(route =>\n      routeNames.includes(route.name)\n    );\n\n    return {\n      ...state,\n      routeNames,\n      routes,\n      index: Math.min(state.index, routes.length - 1),\n    };\n  },\n\n  getStateForRouteFocus(state, key) {\n    const index = state.routes.findIndex(r => r.key === key);\n\n    if (index === -1 || index === state.index) {\n      return state;\n    }\n\n    return { ...state, index };\n  },\n\n  getStateForAction(state, action) {\n    switch (action.type) {\n      case 'NAVIGATE': {\n        const index = state.routes.findIndex(\n          route => route.name === action.payload.name\n        );\n\n        if (index === -1) {\n          return null;\n        }\n\n        return { ...state, index };\n      }\n\n      default:\n        return BaseRouter.getStateForAction(state, action);\n    }\n  },\n\n  shouldActionChangeFocus() {\n    return false;\n  },\n};\n\nconst SimpleRouter = () => router;\n\nexport default SimpleRouter;\n"})}),"\n",(0,a.jsx)(e.h2,{id:"built-in-routers",children:"Built-In Routers"}),"\n",(0,a.jsx)(e.p,{children:"The library ships with a few standard routers:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.code,{children:"StackRouter"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.code,{children:"TabRouter"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.code,{children:"DrawerRouter"})}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"customizing-routers",children:"Customizing Routers"}),"\n",(0,a.jsx)(e.p,{children:"There are two main ways to customize routers:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Override an existing router with the ",(0,a.jsx)(e.a,{href:"/docs/navigator#router",children:(0,a.jsx)(e.code,{children:"UNSTABLE_router"})})," prop on navigators"]}),"\n",(0,a.jsxs)(e.li,{children:["Customized navigators with a custom router, see ",(0,a.jsx)(e.a,{href:"/docs/custom-navigators#extending-navigators",children:"extending navigators"})]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"custom-navigation-actions",children:"Custom Navigation Actions"}),"\n",(0,a.jsx)(e.p,{children:"Let's say you want to add a custom action to clear the history:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import { TabRouter } from '@react-navigation/native';\n\nconst MyTabRouter = (options) => {\n  const router = TabRouter(options);\n\n  return {\n    ...router,\n    getStateForAction(state, action, options) {\n      switch (action.type) {\n        case 'CLEAR_HISTORY':\n          return {\n            ...state,\n            routeKeyHistory: [],\n          };\n        default:\n          return router.getStateForAction(state, action, options);\n      }\n    },\n\n    actionCreators: {\n      ...router.actionCreators,\n      clearHistory() {\n        return { type: 'CLEAR_HISTORY' };\n      },\n    },\n  };\n};\n"})}),"\n",(0,a.jsxs)(e.p,{children:["Instead of writing a custom router to handle custom actions, you can ",(0,a.jsxs)(e.a,{href:"/docs/navigation-object#dispatch",children:["pass a function to ",(0,a.jsx)(e.code,{children:"dispatch"})]})," instead. It's cleaner and recommended instead of overriding routers."]}),"\n",(0,a.jsx)(e.h3,{id:"blocking-navigation-actions",children:"Blocking Navigation Actions"}),"\n",(0,a.jsxs)(e.p,{children:["Sometimes you may want to prevent some navigation activity, depending on your route. Let's say, you want to prevent pushing a new screen if ",(0,a.jsx)(e.code,{children:"isEditing"})," is ",(0,a.jsx)(e.code,{children:"true"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import { StackRouter } from '@react-navigation/native';\n\nconst MyStackRouter = (options) => {\n  const router = StackRouter(options);\n\n  return {\n    ...router,\n    getStateForAction(state, action, options) {\n      const result = router.getStateForAction(state, action, options);\n\n      if (\n        result != null &&\n        result.index > state.index &&\n        state.routes[state.index].params?.isEditing\n      ) {\n        // Returning the current state means that the action has been handled, but we don't have a new state\n        return state;\n      }\n\n      return result;\n    },\n  };\n};\n"})}),"\n",(0,a.jsxs)(e.p,{children:["If you want to prevent going back, the recommended approach is to use the ",(0,a.jsxs)(e.a,{href:"/docs/preventing-going-back",children:[(0,a.jsx)(e.code,{children:"usePreventRemove"})," hook"]}),"."]})]})}function h(t={}){const{wrapper:e}={...(0,r.R)(),...t.components};return e?(0,a.jsx)(e,{...t,children:(0,a.jsx)(d,{...t})}):d(t)}},28453:(t,e,n)=>{n.d(e,{R:()=>s,x:()=>i});var o=n(96540);const a={},r=o.createContext(a);function s(t){const e=o.useContext(r);return o.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function i(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(a):t.components||a:s(t.components),o.createElement(r.Provider,{value:e},t.children)}}}]);