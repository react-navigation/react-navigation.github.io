"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[82616],{93571:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>g,frontMatter:()=>c,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"auth-flow","title":"Authentication flows","description":"Most apps require that a user authenticates in some way to have access to data associated with a user or other private content. Typically the flow will look like this:","source":"@site/versioned_docs/version-7.x/auth-flow.md","sourceDirName":".","slug":"/auth-flow","permalink":"/docs/auth-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/auth-flow.md","tags":[],"version":"7.x","frontMatter":{"id":"auth-flow","title":"Authentication flows","sidebar_label":"Authentication flows"},"sidebar":"docs","previous":{"title":"Next steps","permalink":"/docs/next-steps"},"next":{"title":"Supporting safe areas","permalink":"/docs/handling-safe-area"}}');var a=t(74848),o=t(28453),s=t(11470),r=t(19365);const c={id:"auth-flow",title:"Authentication flows",sidebar_label:"Authentication flows",rawMarkdown:'---\nid: auth-flow\ntitle: Authentication flows\nsidebar_label: Authentication flows\n---\n\nimport Tabs from \'@theme/Tabs\';\nimport TabItem from \'@theme/TabItem\';\n\nMost apps require that a user authenticates in some way to have access to data associated with a user or other private content. Typically the flow will look like this:\n\n- The user opens the app.\n- The app loads some authentication state from encrypted persistent storage (for example, [`SecureStore`](https://docs.expo.io/versions/latest/sdk/securestore/)).\n- When the state has loaded, the user is presented with either authentication screens or the main app, depending on whether valid authentication state was loaded.\n- When the user signs out, we clear the authentication state and send them back to authentication screens.\n\n:::note\n\nWe say "authentication screens" because usually there is more than one. You may have a main screen with a username and password field, another for "forgot password", and another set for sign up.\n\n:::\n\n## What we need\n\nWe want the following behavior from our authentication flow:\n\n- When the user is signed in, we want to show the main app screens and not the authentication-related screens.\n- When the user is signed out, we want to show the authentication screens and not the main app screens.\n- After the user goes through the authentication flow and signs in, we want to unmount all of the screens related to authentication, and when we press the hardware back button, we expect to not be able to go back to the authentication flow.\n\n## How it will work\n\nWe can configure different screens to be available based on some condition. For example, if the user is signed in, we want `Home` to be available. If the user is not signed in, we want `SignIn` to be available.\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js name="Authentication flow" snack\nimport * as React from \'react\';\nimport { View } from \'react-native\';\nimport { createStaticNavigation } from \'@react-navigation/native\';\nimport { createNativeStackNavigator } from \'@react-navigation/native-stack\';\n\nconst useIsSignedIn = () => {\n  return true;\n};\n\nconst useIsSignedOut = () => {\n  return !useIsSignedIn();\n};\n\n// codeblock-focus-start\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n    },\n  },\n});\n// codeblock-focus-end\n\nconst Navigation = createStaticNavigation(RootStack);\n\nexport default function App() {\n  return <Navigation />;\n}\n\nfunction HomeScreen() {\n  return <View />;\n}\n\nfunction SignInScreen() {\n  return <View />;\n}\n```\n\nHere, for each screen, we have defined a condition using the `if` property which takes a hook. The hook returns a boolean value indicating whether the user is signed in or not. If the hook returns `true`, the screen will be available, otherwise it won\'t.\n\nThis means:\n\n- When `useIsSignedIn` returns `true`, React Navigation will only use the `Home` screen, since it\'s the only screen matching the condition.\n- Similarly, when `useIsSignedOut` returns `true`, React Navigation will use the `SignIn` screen.\n\nThis makes it impossible to navigate to the `Home` when the user is not signed in, and to `SignIn` when the user is signed in.\n\nWhen the values returned by `useIsSignedin` and `useIsSignedOut` change, the screens matching the condition will change:\n\n- Let\'s say, initially `useIsSignedOut` returns `true`. This means that `SignIn` screens is shown.\n- After the user signs in, the return value of `useIsSignedIn` will change to `true` and `useIsSignedOut` will change to `false`, which means:\n  - React Navigation will see that the `SignIn` screen is no longer matches the condition, so it will remove the screen.\n  - Then it\'ll show the `Home` screen automatically because that\'s the first screen available when `useIsSignedIn` returns `true`.\n\nThe order of the screens matters when there are multiple screens matching the condition. For example, if there are two screens matching `useIsSignedIn`, the first screen will be shown when the condition is `true`.\n\n## Define the hooks\n\nTo implement the `useIsSignedIn` and `useIsSignedOut` hooks, we can start by creating a context to store the authentication state. Let\'s call it `SignInContext`:\n\n```js\nimport * as React from \'react\';\n\nconst SignInContext = React.createContext();\n```\n\nThen we can implement the `useIsSignedIn` and `useIsSignedOut` hooks as follows:\n\n```js\nfunction useIsSignedIn() {\n  const isSignedIn = React.useContext(SignInContext);\n  return isSignedIn;\n}\n\nfunction useIsSignedOut() {\n  return !useIsSignedIn();\n}\n```\n\nWe\'ll discuss how to provide the context value later.\n\n</TabItem>\n\n<TabItem value="dynamic" label="Dynamic">\n\n```js name="Authentication flow" snack\nimport * as React from \'react\';\nimport { View } from \'react-native\';\nimport { NavigationContainer } from \'@react-navigation/native\';\nimport { createNativeStackNavigator } from \'@react-navigation/native-stack\';\n\nconst Stack = createNativeStackNavigator();\n\nexport default function App() {\n  const isSignedIn = true;\n\n  return (\n    <NavigationContainer>\n      <Stack.Navigator>\n        // codeblock-focus-start\n        {isSignedIn ? (\n          <Stack.Screen name="Home" component={HomeScreen} />\n        ) : (\n          <Stack.Screen name="SignIn" component={SignInScreen} />\n        )}\n        // codeblock-focus-end\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}\n\nfunction HomeScreen() {\n  return <View />;\n}\n\nfunction SignInScreen() {\n  return <View />;\n}\n```\n\nHere, we have conditionally defined the screens based on the value of `isSignedIn`.\n\nThis means:\n\n- When `isSignedIn` is `true`, React Navigation will only see the `Home` screen, since it\'s the only screen defined based on the condition.\n- Similarly, when `isSignedIn` is `false`, React Navigation will only see the `SignIn` screen.\n\nThis makes it impossible to navigate to the `Home` when the user is not signed in, and to `SignIn` when the user is signed in.\n\nWhen the value of `isSignedin` changes, the screens defined based on the condition will change:\n\n- Let\'s say, initially `isSignedin` is `false`. This means that `SignIn` screens is shown.\n- After the user signs in, the value of `isSignedin` will change to `true`, which means:\n  - React Navigation will see that the `SignIn` screen is no longer defined, so it will remove the screen.\n  - Then it\'ll show the `Home` screen automatically because that\'s the first screen defined when `isSignedin` returns `true`.\n\nThe order of the screens matters when there are multiple screens matching the condition. For example, if there are two screens defined based on `isSignedin`, the first screen will be shown when the condition is `true`.\n\n</TabItem>\n</Tabs>\n\n## Add more screens\n\nFor our case, let\'s say we have 3 screens:\n\n- `SplashScreen` - This will show a splash or loading screen when we\'re restoring the token.\n- `SignIn` - This is the screen we show if the user isn\'t signed in already (we couldn\'t find a token).\n- `Home` - This is the screen we show if the user is already signed in.\n\nSo our navigator will look like:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: \'Sign in\',\n      },\n    },\n  },\n});\n\nconst Navigation = createStaticNavigation(RootStack);\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nconst Stack = createNativeStackNavigator();\n\nexport default function App() {\n  const isSignedIn = true;\n\n  return (\n    <NavigationContainer>\n      <Stack.Navigator>\n        {isSignedIn ? (\n          <Stack.Screen\n            name="SignIn"\n            component={SimpleSignInScreen}\n            options={{\n              title: \'Sign in\',\n            }}\n            initialParams={{ setUserToken }}\n          />\n        ) : (\n          <Stack.Screen name="Home" component={HomeScreen} />\n        )}\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\nNotice how we have only defined the `Home` and `SignIn` screens here, and not the `SplashScreen`. The `SplashScreen` should be rendered before we render any navigators so that we don\'t render incorrect screens before we know whether the user is signed in or not.\n\nWhen we use this in our component, it\'d look something like this:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nif (isLoading) {\n  // We haven\'t finished checking for the token yet\n  return <SplashScreen />;\n}\n\nconst isSignedIn = userToken != null;\n\nreturn (\n  <SignInContext.Provider value={isSignedIn}>\n    <Navigation />\n  </SignInContext.Provider>\n);\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nif (isLoading) {\n  // We haven\'t finished checking for the token yet\n  return <SplashScreen />;\n}\n\nconst isSignedIn = userToken != null;\n\nreturn (\n  <NavigationContainer>\n    <Stack.Navigator>\n      {isSignedIn ? (\n        <Stack.Screen\n          name="SignIn"\n          component={SimpleSignInScreen}\n          options={{\n            title: \'Sign in\',\n          }}\n          initialParams={{ setUserToken }}\n        />\n      ) : (\n        <Stack.Screen name="Home" component={HomeScreen} />\n      )}\n    </Stack.Navigator>\n  </NavigationContainer>\n);\n```\n\n</TabItem>\n</Tabs>\n\nIn the above snippet, `isLoading` means that we\'re still checking if we have a token. This can usually be done by checking if we have a token in `SecureStore` and validating the token.\n\nNext, we\'re exposing the sign in status via the `SignInContext` so that it\'s available to the `useIsSignedIn` and `useIsSignedOut` hooks.\n\nIn the above example, we have one screen for each case. But you could also define multiple screens. For example, you probably want to define password reset, signup, etc screens as well when the user isn\'t signed in. Similarly for the screens accessible after sign in, you probably have more than one screen.\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\nWe can use [`groups`](static-configuration.md#groups) to define multiple screens:\n\n```js\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    // Common screens\n  },\n  groups: {\n    SignedIn: {\n      if: useIsSignedIn,\n      screens: {\n        Home: HomeScreen,\n        Profile: ProfileScreen,\n      },\n    },\n    SignedOut: {\n      if: useIsSignedOut,\n      screens: {\n        SignIn: SignInScreen,\n        SignUp: SignUpScreen,\n        ResetPassword: ResetPasswordScreen,\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\nWe can use [`React.Fragment`](https://react.dev/reference/react/Fragment) or [`Group`](group.md) to define multiple screens:\n\n```js\nisSignedIn ? (\n  <>\n    <Stack.Screen name="SignIn" component={SignInScreen} />\n    <Stack.Screen name="SignUp" component={SignUpScreen} />\n    <Stack.Screen name="ResetPassword" component={ResetPassword} />\n  </>\n) : (\n  <>\n    <Stack.Screen name="Home" component={HomeScreen} />\n    <Stack.Screen name="Profile" component={ProfileScreen} />\n  </>\n);\n```\n\n:::tip\n\nInstead of having your login-related screens and rest of the screens in two different Stack navigators and render them conditionally, we recommend to use a single Stack navigator and place the conditional inside. This makes it possible to have a proper transition animation during login/logout.\n\n:::\n\n</TabItem>\n</Tabs>\n\n## Implement the logic for restoring the token\n\n:::note\n\nThe following is just an example of how you might implement the logic for authentication in your app. You don\'t need to follow it as is.\n\n:::\n\nFrom the previous snippet, we can see that we need 3 state variables:\n\n- `isLoading` - We set this to `true` when we\'re trying to check if we already have a token saved in `SecureStore`.\n- `isSignout` - We set this to `true` when user is signing out, otherwise set it to `false`. This can be used to customize the animation when signing out.\n- `userToken` - The token for the user. If it\'s non-null, we assume the user is logged in, otherwise not.\n\nSo we need to:\n\n- Add some logic for restoring token, signing in and signing out\n- Expose methods for signing in and signing out to other components\n\nWe\'ll use `React.useReducer` and `React.useContext` in this guide. But if you\'re using a state management library such as Redux or Mobx, you can use them for this functionality instead. In fact, in bigger apps, a global state management library is more suitable for storing authentication tokens. You can adapt the same approach to your state management library.\n\nFirst we\'ll need to create a context for auth where we can expose the necessary methods:\n\n```js\nimport * as React from \'react\';\n\nconst AuthContext = React.createContext();\n```\n\nIn our component, we will:\n\n- Store the token and loading state in `useReducer`\n- Persist it to `SecureStore` and read it from there on app launch\n- Expose the methods for sign in and sign out to child components using `AuthContext`\n\nSo our component will look like this:\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js name="Signing in and signing out with AuthContext" snack dependencies=expo-secure-store\n// codeblock-focus-start\nimport * as React from \'react\';\nimport * as SecureStore from \'expo-secure-store\';\n\n// codeblock-focus-end\nimport { Text, TextInput, View } from \'react-native\';\nimport { createStaticNavigation } from \'@react-navigation/native\';\nimport { createNativeStackNavigator } from \'@react-navigation/native-stack\';\nimport { Button } from \'@react-navigation/elements\';\n\nconst AuthContext = React.createContext();\n\nconst SignInContext = React.createContext();\n\nfunction useIsSignedIn() {\n  const isSignedIn = React.useContext(SignInContext);\n  return isSignedIn;\n}\n\nfunction useIsSignedOut() {\n  return !useIsSignedIn();\n}\n\nfunction SplashScreen() {\n  return (\n    <View>\n      <Text>Loading...</Text>\n    </View>\n  );\n}\n\nfunction HomeScreen() {\n  const { signOut } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <Text>Signed in!</Text>\n      <Button onPress={signOut}>Sign out</Button>\n    </View>\n  );\n}\n\nfunction SignInScreen() {\n  const [username, setUsername] = React.useState(\'\');\n  const [password, setPassword] = React.useState(\'\');\n\n  const { signIn } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <TextInput\n        placeholder="Username"\n        value={username}\n        onChangeText={setUsername}\n      />\n      <TextInput\n        placeholder="Password"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button onPress={() => signIn({ username, password })}>Sign in</Button>\n    </View>\n  );\n}\n\n// codeblock-focus-start\nexport default function App() {\n  const [state, dispatch] = React.useReducer(\n    (prevState, action) => {\n      switch (action.type) {\n        case \'RESTORE_TOKEN\':\n          return {\n            ...prevState,\n            userToken: action.token,\n            isLoading: false,\n          };\n        case \'SIGN_IN\':\n          return {\n            ...prevState,\n            isSignout: false,\n            userToken: action.token,\n          };\n        case \'SIGN_OUT\':\n          return {\n            ...prevState,\n            isSignout: true,\n            userToken: null,\n          };\n      }\n    },\n    {\n      isLoading: true,\n      isSignout: false,\n      userToken: null,\n    }\n  );\n\n  React.useEffect(() => {\n    // Fetch the token from storage then navigate to our appropriate place\n    const bootstrapAsync = async () => {\n      let userToken;\n\n      try {\n        // Restore token stored in `SecureStore` or any other encrypted storage\n        userToken = await SecureStore.getItemAsync(\'userToken\');\n      } catch (e) {\n        // Restoring token failed\n      }\n\n      // After restoring token, we may need to validate it in production apps\n\n      // This will switch to the App screen or Auth screen and this loading\n      // screen will be unmounted and thrown away.\n      dispatch({ type: \'RESTORE_TOKEN\', token: userToken });\n    };\n\n    bootstrapAsync();\n  }, []);\n\n  const authContext = React.useMemo(\n    () => ({\n      signIn: async (data) => {\n        // In a production app, we need to send some data (usually username, password) to server and get a token\n        // We will also need to handle errors if sign in failed\n        // After getting token, we need to persist the token using `SecureStore` or any other encrypted storage\n        // In the example, we\'ll use a dummy token\n\n        dispatch({ type: \'SIGN_IN\', token: \'dummy-auth-token\' });\n      },\n      signOut: () => dispatch({ type: \'SIGN_OUT\' }),\n      signUp: async (data) => {\n        // In a production app, we need to send user data to server and get a token\n        // We will also need to handle errors if sign up failed\n        // After getting token, we need to persist the token using `SecureStore` or any other encrypted storage\n        // In the example, we\'ll use a dummy token\n\n        dispatch({ type: \'SIGN_IN\', token: \'dummy-auth-token\' });\n      },\n    }),\n    []\n  );\n\n  if (state.isLoading) {\n    // We haven\'t finished checking for the token yet\n    return <SplashScreen />;\n  }\n\n  const isSignedIn = state.userToken != null;\n\n  return (\n    <AuthContext.Provider value={authContext}>\n      <SignInContext.Provider value={isSignedIn}>\n        <Navigation />\n      </SignInContext.Provider>\n    </AuthContext.Provider>\n  );\n}\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: \'Sign in\',\n      },\n    },\n  },\n});\n\nconst Navigation = createStaticNavigation(RootStack);\n// codeblock-focus-end\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js name="Signing in and signing out with AuthContext" snack dependencies=expo-secure-store\n// codeblock-focus-start\nimport * as React from \'react\';\nimport * as SecureStore from \'expo-secure-store\';\n\n// codeblock-focus-end\nimport { Text, TextInput, View } from \'react-native\';\nimport { NavigationContainer } from \'@react-navigation/native\';\nimport { createNativeStackNavigator } from \'@react-navigation/native-stack\';\nimport { Button } from \'@react-navigation/elements\';\n\nconst AuthContext = React.createContext();\n\nfunction SplashScreen() {\n  return (\n    <View>\n      <Text>Loading...</Text>\n    </View>\n  );\n}\n\nfunction HomeScreen() {\n  const { signOut } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <Text>Signed in!</Text>\n      <Button onPress={signOut}>Sign out</Button>\n    </View>\n  );\n}\n\nfunction SignInScreen() {\n  const [username, setUsername] = React.useState(\'\');\n  const [password, setPassword] = React.useState(\'\');\n\n  const { signIn } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <TextInput\n        placeholder="Username"\n        value={username}\n        onChangeText={setUsername}\n      />\n      <TextInput\n        placeholder="Password"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button onPress={() => signIn({ username, password })}>Sign in</Button>\n    </View>\n  );\n}\n\nconst Stack = createNativeStackNavigator();\n\n// codeblock-focus-start\nexport default function App() {\n  const [state, dispatch] = React.useReducer(\n    (prevState, action) => {\n      switch (action.type) {\n        case \'RESTORE_TOKEN\':\n          return {\n            ...prevState,\n            userToken: action.token,\n            isLoading: false,\n          };\n        case \'SIGN_IN\':\n          return {\n            ...prevState,\n            isSignout: false,\n            userToken: action.token,\n          };\n        case \'SIGN_OUT\':\n          return {\n            ...prevState,\n            isSignout: true,\n            userToken: null,\n          };\n      }\n    },\n    {\n      isLoading: true,\n      isSignout: false,\n      userToken: null,\n    }\n  );\n\n  React.useEffect(() => {\n    // Fetch the token from storage then navigate to our appropriate place\n    const bootstrapAsync = async () => {\n      let userToken;\n\n      try {\n        // Restore token stored in `SecureStore` or any other encrypted storage\n        userToken = await SecureStore.getItemAsync(\'userToken\');\n      } catch (e) {\n        // Restoring token failed\n      }\n\n      // After restoring token, we may need to validate it in production apps\n\n      // This will switch to the App screen or Auth screen and this loading\n      // screen will be unmounted and thrown away.\n      dispatch({ type: \'RESTORE_TOKEN\', token: userToken });\n    };\n\n    bootstrapAsync();\n  }, []);\n\n  const authContext = React.useMemo(\n    () => ({\n      signIn: async (data) => {\n        // In a production app, we need to send some data (usually username, password) to server and get a token\n        // We will also need to handle errors if sign in failed\n        // After getting token, we need to persist the token using `SecureStore` or any other encrypted storage\n        // In the example, we\'ll use a dummy token\n\n        dispatch({ type: \'SIGN_IN\', token: \'dummy-auth-token\' });\n      },\n      signOut: () => dispatch({ type: \'SIGN_OUT\' }),\n      signUp: async (data) => {\n        // In a production app, we need to send user data to server and get a token\n        // We will also need to handle errors if sign up failed\n        // After getting token, we need to persist the token using `SecureStore` or any other encrypted storage\n        // In the example, we\'ll use a dummy token\n\n        dispatch({ type: \'SIGN_IN\', token: \'dummy-auth-token\' });\n      },\n    }),\n    []\n  );\n\n  return (\n    <AuthContext.Provider value={authContext}>\n      <NavigationContainer>\n        <Stack.Navigator>\n          {state.isLoading ? (\n            // We haven\'t finished checking for the token yet\n            <Stack.Screen name="Splash" component={SplashScreen} />\n          ) : state.userToken == null ? (\n            // No token found, user isn\'t signed in\n            <Stack.Screen\n              name="SignIn"\n              component={SignInScreen}\n              options={{\n                title: \'Sign in\',\n                // When logging out, a pop animation feels intuitive\n                animationTypeForReplace: state.isSignout ? \'pop\' : \'push\',\n              }}\n            />\n          ) : (\n            // User is signed in\n            <Stack.Screen name="Home" component={HomeScreen} />\n          )}\n        </Stack.Navigator>\n      </NavigationContainer>\n    </AuthContext.Provider>\n  );\n}\n// codeblock-focus-end\n```\n\n</TabItem>\n</Tabs>\n\n## Fill in other components\n\nWe won\'t talk about how to implement the text inputs and buttons for the authentication screen, that is outside of the scope of navigation. We\'ll just fill in some placeholder content.\n\n```js\nfunction SignInScreen() {\n  const [username, setUsername] = React.useState(\'\');\n  const [password, setPassword] = React.useState(\'\');\n\n  const { signIn } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <TextInput\n        placeholder="Username"\n        value={username}\n        onChangeText={setUsername}\n      />\n      <TextInput\n        placeholder="Password"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button onPress={() => signIn({ username, password })}>Sign in</Button>\n    </View>\n  );\n}\n```\n\nYou can similarly fill in the other screens according to your requirements.\n\n## Removing shared screens when auth state changes\n\nConsider the following example:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst RootStack = createNativeStackNavigator({\n  groups: {\n    LoggedIn: {\n      if: useIsSignedIn,\n      screens: {\n        Home: HomeScreen,\n        Profile: ProfileScreen,\n      },\n    },\n    LoggedOut: {\n      if: useIsSignedOut,\n      screens: {\n        SignIn: SignInScreen,\n        SignUp: SignUpScreen,\n      },\n    },\n  },\n  screens: {\n    Help: HelpScreen,\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nisSignedIn ? (\n  <>\n    <Stack.Screen name="Home" component={HomeScreen} />\n    <Stack.Screen name="Profile" component={ProfileScreen} />\n    <Stack.Screen name="Help" component={HelpScreen} />\n  </>\n) : (\n  <>\n    <Stack.Screen name="SignIn" component={SignInScreen} />\n    <Stack.Screen name="SignUp" component={SignUpScreen} />\n    <Stack.Screen name="Help" component={HelpScreen} />\n  </>\n);\n```\n\n</TabItem>\n</Tabs>\n\nHere we have specific screens such as `SignIn`, `Home` etc. which are only shown depending on the sign in state. But we also have the `Help` screen which can be shown regardless of the login status. This also means that if the sign in state changes when the user is in the `Help` screen, they\'ll stay on the `Help` screen.\n\nThis can be a problem, we probably want the user to be taken to the `SignIn` screen or `Home` screen instead of keeping them on the `Help` screen.\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\nTo make this work, we can move the `Help` screen to both of the groups instead of keeping it outside. This will ensure that the [`navigationKey`](screen.md#navigation-key) (the name of the group) for the screen changes when the sign in state changes.\n\nSo our updated code will look like the following:\n\n```js\nconst RootStack = createNativeStackNavigator({\n  groups: {\n    LoggedIn: {\n      if: useIsSignedIn,\n      screens: {\n        Home: HomeScreen,\n        Profile: ProfileScreen,\n        Help: HelpScreen,\n      },\n    },\n    LoggedOut: {\n      if: useIsSignedOut,\n      screens: {\n        SignIn: SignInScreen,\n        SignUp: SignUpScreen,\n        Help: HelpScreen,\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\nTo make this work, we can use [`navigationKey`](screen.md#navigation-key). When the `navigationKey` changes, React Navigation will remove all the screen.\n\nSo our updated code will look like the following:\n\n```js\n<>\n  {isSignedIn ? (\n    <>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </>\n  ) : (\n    <>\n      <Stack.Screen name="SignIn" component={SignInScreen} />\n      <Stack.Screen name="SignUp" component={SignUpScreen} />\n    </>\n  )}\n  <Stack.Screen\n    navigationKey={isSignedIn ? \'user\' : \'guest\'}\n    name="Help"\n    component={HelpScreen}\n  />\n</>\n```\n\nIf you have a bunch of shared screens, you can also use [`navigationKey` with a `Group`](group.md#navigation-key) to remove all of the screens in the group. For example:\n\n```js\n<>\n  {isSignedIn ? (\n    <>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </>\n  ) : (\n    <>\n      <Stack.Screen name="SignIn" component={SignInScreen} />\n      <Stack.Screen name="SignUp" component={SignUpScreen} />\n    </>\n  )}\n  <Stack.Group navigationKey={isSignedIn ? \'user\' : \'guest\'}>\n    <Stack.Screen name="Help" component={HelpScreen} />\n    <Stack.Screen name="About" component={AboutScreen} />\n  </Stack.Group>\n</>\n```\n\n</TabItem>\n</Tabs>\n\nThe examples above show stack navigator, but you can use the same approach with any navigator.\n\nBy specifying a condition for our screens, we can implement auth flow in a simple way that doesn\'t require additional logic to make sure that the correct screen is shown.\n\n## Don\'t manually navigate when conditionally rendering screens\n\nIt\'s important to note that when using such a setup, you **don\'t manually navigate** to the `Home` screen by calling `navigation.navigate(\'Home\')` or any other method. **React Navigation will automatically navigate to the correct screen** when `isSignedIn` changes - `Home` screen when `isSignedIn` becomes `true`, and to `SignIn` screen when `isSignedIn` becomes `false`. You\'ll get an error if you attempt to navigate manually.\n\n## Handling deep links after auth\n\nWhen using deep links, you may want to handle the case where the user opens a deep link that requires authentication.\n\nExample scenario:\n\n- User opens a deep link to `myapp://profile` but is not signed in.\n- The app shows the `SignIn` screen.\n- After the user signs in, you want to navigate them to the `Profile` screen.\n\nTo achieve this, you can set [`UNSTABLE_routeNamesChangeBehavior`](navigator.md#route-names-change-behavior) to `"lastUnhandled"`:\n\n:::warning\n\nThis API is experimental and may change in a minor release.\n\n:::\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst RootStack = createNativeStackNavigator({\n  // highlight-next-line\n  UNSTABLE_routeNamesChangeBehavior: \'lastUnhandled\',\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: \'Sign in\',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\n<Stack.Navigator\n  // highlight-next-line\n  UNSTABLE_routeNamesChangeBehavior="lastUnhandled"\n>\n  {isSignedIn ? (\n    <Stack.Screen name="Home" component={HomeScreen} />\n  ) : (\n    <Stack.Screen name="SignIn" component={SignInScreen} />\n  )}\n</Stack.Navigator>\n```\n\n</TabItem>\n</Tabs>\n\nThe `UNSTABLE_routeNamesChangeBehavior` option allows you to control how React Navigation handles navigation when the available screens change because of conditions such as authentication state. When `lastUnhandled` is specified, React Navigation will remember the last screen that couldn\'t be handled, and after the condition changes, it\'ll automatically navigate to that screen if it\'s now available.\n'},l=void 0,d={},h=[{value:"What we need",id:"what-we-need",level:2},{value:"How it will work",id:"how-it-will-work",level:2},{value:"Define the hooks",id:"define-the-hooks",level:2},{value:"Add more screens",id:"add-more-screens",level:2},{value:"Implement the logic for restoring the token",id:"implement-the-logic-for-restoring-the-token",level:2},{value:"Fill in other components",id:"fill-in-other-components",level:2},{value:"Removing shared screens when auth state changes",id:"removing-shared-screens-when-auth-state-changes",level:2},{value:"Don&#39;t manually navigate when conditionally rendering screens",id:"dont-manually-navigate-when-conditionally-rendering-screens",level:2},{value:"Handling deep links after auth",id:"handling-deep-links-after-auth",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Most apps require that a user authenticates in some way to have access to data associated with a user or other private content. Typically the flow will look like this:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The user opens the app."}),"\n",(0,a.jsxs)(n.li,{children:["The app loads some authentication state from encrypted persistent storage (for example, ",(0,a.jsx)(n.a,{href:"https://docs.expo.io/versions/latest/sdk/securestore/",children:(0,a.jsx)(n.code,{children:"SecureStore"})}),")."]}),"\n",(0,a.jsx)(n.li,{children:"When the state has loaded, the user is presented with either authentication screens or the main app, depending on whether valid authentication state was loaded."}),"\n",(0,a.jsx)(n.li,{children:"When the user signs out, we clear the authentication state and send them back to authentication screens."}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:'We say "authentication screens" because usually there is more than one. You may have a main screen with a username and password field, another for "forgot password", and another set for sign up.'})}),"\n",(0,a.jsx)(n.h2,{id:"what-we-need",children:"What we need"}),"\n",(0,a.jsx)(n.p,{children:"We want the following behavior from our authentication flow:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"When the user is signed in, we want to show the main app screens and not the authentication-related screens."}),"\n",(0,a.jsx)(n.li,{children:"When the user is signed out, we want to show the authentication screens and not the main app screens."}),"\n",(0,a.jsx)(n.li,{children:"After the user goes through the authentication flow and signs in, we want to unmount all of the screens related to authentication, and when we press the hardware back button, we expect to not be able to go back to the authentication flow."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"how-it-will-work",children:"How it will work"}),"\n",(0,a.jsxs)(n.p,{children:["We can configure different screens to be available based on some condition. For example, if the user is signed in, we want ",(0,a.jsx)(n.code,{children:"Home"})," to be available. If the user is not signed in, we want ",(0,a.jsx)(n.code,{children:"SignIn"})," to be available."]}),"\n",(0,a.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,a.jsxs)(r.A,{value:"static",label:"Static",default:!0,children:[(0,a.jsx)(n.pre,{"data-name":"Authentication flow","data-snack":"true",children:(0,a.jsx)(n.code,{className:"language-js",metastring:'name="Authentication flow" snack',children:"import * as React from 'react';\nimport { View } from 'react-native';\nimport { createStaticNavigation } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst useIsSignedIn = () => {\n  return true;\n};\n\nconst useIsSignedOut = () => {\n  return !useIsSignedIn();\n};\n\n// codeblock-focus-start\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n    },\n  },\n});\n// codeblock-focus-end\n\nconst Navigation = createStaticNavigation(RootStack);\n\nexport default function App() {\n  return <Navigation />;\n}\n\nfunction HomeScreen() {\n  return <View />;\n}\n\nfunction SignInScreen() {\n  return <View />;\n}\n"})}),(0,a.jsxs)(n.p,{children:["Here, for each screen, we have defined a condition using the ",(0,a.jsx)(n.code,{children:"if"})," property which takes a hook. The hook returns a boolean value indicating whether the user is signed in or not. If the hook returns ",(0,a.jsx)(n.code,{children:"true"}),", the screen will be available, otherwise it won't."]}),(0,a.jsx)(n.p,{children:"This means:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["When ",(0,a.jsx)(n.code,{children:"useIsSignedIn"})," returns ",(0,a.jsx)(n.code,{children:"true"}),", React Navigation will only use the ",(0,a.jsx)(n.code,{children:"Home"})," screen, since it's the only screen matching the condition."]}),"\n",(0,a.jsxs)(n.li,{children:["Similarly, when ",(0,a.jsx)(n.code,{children:"useIsSignedOut"})," returns ",(0,a.jsx)(n.code,{children:"true"}),", React Navigation will use the ",(0,a.jsx)(n.code,{children:"SignIn"})," screen."]}),"\n"]}),(0,a.jsxs)(n.p,{children:["This makes it impossible to navigate to the ",(0,a.jsx)(n.code,{children:"Home"})," when the user is not signed in, and to ",(0,a.jsx)(n.code,{children:"SignIn"})," when the user is signed in."]}),(0,a.jsxs)(n.p,{children:["When the values returned by ",(0,a.jsx)(n.code,{children:"useIsSignedin"})," and ",(0,a.jsx)(n.code,{children:"useIsSignedOut"})," change, the screens matching the condition will change:"]}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Let's say, initially ",(0,a.jsx)(n.code,{children:"useIsSignedOut"})," returns ",(0,a.jsx)(n.code,{children:"true"}),". This means that ",(0,a.jsx)(n.code,{children:"SignIn"})," screens is shown."]}),"\n",(0,a.jsxs)(n.li,{children:["After the user signs in, the return value of ",(0,a.jsx)(n.code,{children:"useIsSignedIn"})," will change to ",(0,a.jsx)(n.code,{children:"true"})," and ",(0,a.jsx)(n.code,{children:"useIsSignedOut"})," will change to ",(0,a.jsx)(n.code,{children:"false"}),", which means:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["React Navigation will see that the ",(0,a.jsx)(n.code,{children:"SignIn"})," screen is no longer matches the condition, so it will remove the screen."]}),"\n",(0,a.jsxs)(n.li,{children:["Then it'll show the ",(0,a.jsx)(n.code,{children:"Home"})," screen automatically because that's the first screen available when ",(0,a.jsx)(n.code,{children:"useIsSignedIn"})," returns ",(0,a.jsx)(n.code,{children:"true"}),"."]}),"\n"]}),"\n"]}),"\n"]}),(0,a.jsxs)(n.p,{children:["The order of the screens matters when there are multiple screens matching the condition. For example, if there are two screens matching ",(0,a.jsx)(n.code,{children:"useIsSignedIn"}),", the first screen will be shown when the condition is ",(0,a.jsx)(n.code,{children:"true"}),"."]}),(0,a.jsx)(n.h2,{id:"define-the-hooks",children:"Define the hooks"}),(0,a.jsxs)(n.p,{children:["To implement the ",(0,a.jsx)(n.code,{children:"useIsSignedIn"})," and ",(0,a.jsx)(n.code,{children:"useIsSignedOut"})," hooks, we can start by creating a context to store the authentication state. Let's call it ",(0,a.jsx)(n.code,{children:"SignInContext"}),":"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import * as React from 'react';\n\nconst SignInContext = React.createContext();\n"})}),(0,a.jsxs)(n.p,{children:["Then we can implement the ",(0,a.jsx)(n.code,{children:"useIsSignedIn"})," and ",(0,a.jsx)(n.code,{children:"useIsSignedOut"})," hooks as follows:"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function useIsSignedIn() {\n  const isSignedIn = React.useContext(SignInContext);\n  return isSignedIn;\n}\n\nfunction useIsSignedOut() {\n  return !useIsSignedIn();\n}\n"})}),(0,a.jsx)(n.p,{children:"We'll discuss how to provide the context value later."})]}),(0,a.jsxs)(r.A,{value:"dynamic",label:"Dynamic",children:[(0,a.jsx)(n.pre,{"data-name":"Authentication flow","data-snack":"true",children:(0,a.jsx)(n.code,{className:"language-js",metastring:'name="Authentication flow" snack',children:"import * as React from 'react';\nimport { View } from 'react-native';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst Stack = createNativeStackNavigator();\n\nexport default function App() {\n  const isSignedIn = true;\n\n  return (\n    <NavigationContainer>\n      <Stack.Navigator>\n        // codeblock-focus-start\n        {isSignedIn ? (\n          <Stack.Screen name=\"Home\" component={HomeScreen} />\n        ) : (\n          <Stack.Screen name=\"SignIn\" component={SignInScreen} />\n        )}\n        // codeblock-focus-end\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}\n\nfunction HomeScreen() {\n  return <View />;\n}\n\nfunction SignInScreen() {\n  return <View />;\n}\n"})}),(0,a.jsxs)(n.p,{children:["Here, we have conditionally defined the screens based on the value of ",(0,a.jsx)(n.code,{children:"isSignedIn"}),"."]}),(0,a.jsx)(n.p,{children:"This means:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["When ",(0,a.jsx)(n.code,{children:"isSignedIn"})," is ",(0,a.jsx)(n.code,{children:"true"}),", React Navigation will only see the ",(0,a.jsx)(n.code,{children:"Home"})," screen, since it's the only screen defined based on the condition."]}),"\n",(0,a.jsxs)(n.li,{children:["Similarly, when ",(0,a.jsx)(n.code,{children:"isSignedIn"})," is ",(0,a.jsx)(n.code,{children:"false"}),", React Navigation will only see the ",(0,a.jsx)(n.code,{children:"SignIn"})," screen."]}),"\n"]}),(0,a.jsxs)(n.p,{children:["This makes it impossible to navigate to the ",(0,a.jsx)(n.code,{children:"Home"})," when the user is not signed in, and to ",(0,a.jsx)(n.code,{children:"SignIn"})," when the user is signed in."]}),(0,a.jsxs)(n.p,{children:["When the value of ",(0,a.jsx)(n.code,{children:"isSignedin"})," changes, the screens defined based on the condition will change:"]}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Let's say, initially ",(0,a.jsx)(n.code,{children:"isSignedin"})," is ",(0,a.jsx)(n.code,{children:"false"}),". This means that ",(0,a.jsx)(n.code,{children:"SignIn"})," screens is shown."]}),"\n",(0,a.jsxs)(n.li,{children:["After the user signs in, the value of ",(0,a.jsx)(n.code,{children:"isSignedin"})," will change to ",(0,a.jsx)(n.code,{children:"true"}),", which means:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["React Navigation will see that the ",(0,a.jsx)(n.code,{children:"SignIn"})," screen is no longer defined, so it will remove the screen."]}),"\n",(0,a.jsxs)(n.li,{children:["Then it'll show the ",(0,a.jsx)(n.code,{children:"Home"})," screen automatically because that's the first screen defined when ",(0,a.jsx)(n.code,{children:"isSignedin"})," returns ",(0,a.jsx)(n.code,{children:"true"}),"."]}),"\n"]}),"\n"]}),"\n"]}),(0,a.jsxs)(n.p,{children:["The order of the screens matters when there are multiple screens matching the condition. For example, if there are two screens defined based on ",(0,a.jsx)(n.code,{children:"isSignedin"}),", the first screen will be shown when the condition is ",(0,a.jsx)(n.code,{children:"true"}),"."]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"add-more-screens",children:"Add more screens"}),"\n",(0,a.jsx)(n.p,{children:"For our case, let's say we have 3 screens:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"SplashScreen"})," - This will show a splash or loading screen when we're restoring the token."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"SignIn"})," - This is the screen we show if the user isn't signed in already (we couldn't find a token)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Home"})," - This is the screen we show if the user is already signed in."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"So our navigator will look like:"}),"\n",(0,a.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,a.jsx)(r.A,{value:"static",label:"Static",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: 'Sign in',\n      },\n    },\n  },\n});\n\nconst Navigation = createStaticNavigation(RootStack);\n"})})}),(0,a.jsx)(r.A,{value:"dynamic",label:"Dynamic",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const Stack = createNativeStackNavigator();\n\nexport default function App() {\n  const isSignedIn = true;\n\n  return (\n    <NavigationContainer>\n      <Stack.Navigator>\n        {isSignedIn ? (\n          <Stack.Screen\n            name="SignIn"\n            component={SimpleSignInScreen}\n            options={{\n              title: \'Sign in\',\n            }}\n            initialParams={{ setUserToken }}\n          />\n        ) : (\n          <Stack.Screen name="Home" component={HomeScreen} />\n        )}\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["Notice how we have only defined the ",(0,a.jsx)(n.code,{children:"Home"})," and ",(0,a.jsx)(n.code,{children:"SignIn"})," screens here, and not the ",(0,a.jsx)(n.code,{children:"SplashScreen"}),". The ",(0,a.jsx)(n.code,{children:"SplashScreen"})," should be rendered before we render any navigators so that we don't render incorrect screens before we know whether the user is signed in or not."]}),"\n",(0,a.jsx)(n.p,{children:"When we use this in our component, it'd look something like this:"}),"\n",(0,a.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,a.jsx)(r.A,{value:"static",label:"Static",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"if (isLoading) {\n  // We haven't finished checking for the token yet\n  return <SplashScreen />;\n}\n\nconst isSignedIn = userToken != null;\n\nreturn (\n  <SignInContext.Provider value={isSignedIn}>\n    <Navigation />\n  </SignInContext.Provider>\n);\n"})})}),(0,a.jsx)(r.A,{value:"dynamic",label:"Dynamic",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'if (isLoading) {\n  // We haven\'t finished checking for the token yet\n  return <SplashScreen />;\n}\n\nconst isSignedIn = userToken != null;\n\nreturn (\n  <NavigationContainer>\n    <Stack.Navigator>\n      {isSignedIn ? (\n        <Stack.Screen\n          name="SignIn"\n          component={SimpleSignInScreen}\n          options={{\n            title: \'Sign in\',\n          }}\n          initialParams={{ setUserToken }}\n        />\n      ) : (\n        <Stack.Screen name="Home" component={HomeScreen} />\n      )}\n    </Stack.Navigator>\n  </NavigationContainer>\n);\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["In the above snippet, ",(0,a.jsx)(n.code,{children:"isLoading"})," means that we're still checking if we have a token. This can usually be done by checking if we have a token in ",(0,a.jsx)(n.code,{children:"SecureStore"})," and validating the token."]}),"\n",(0,a.jsxs)(n.p,{children:["Next, we're exposing the sign in status via the ",(0,a.jsx)(n.code,{children:"SignInContext"})," so that it's available to the ",(0,a.jsx)(n.code,{children:"useIsSignedIn"})," and ",(0,a.jsx)(n.code,{children:"useIsSignedOut"})," hooks."]}),"\n",(0,a.jsx)(n.p,{children:"In the above example, we have one screen for each case. But you could also define multiple screens. For example, you probably want to define password reset, signup, etc screens as well when the user isn't signed in. Similarly for the screens accessible after sign in, you probably have more than one screen."}),"\n",(0,a.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,a.jsxs)(r.A,{value:"static",label:"Static",default:!0,children:[(0,a.jsxs)(n.p,{children:["We can use ",(0,a.jsx)(n.a,{href:"/docs/static-configuration#groups",children:(0,a.jsx)(n.code,{children:"groups"})})," to define multiple screens:"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  screens: {\n    // Common screens\n  },\n  groups: {\n    SignedIn: {\n      if: useIsSignedIn,\n      screens: {\n        Home: HomeScreen,\n        Profile: ProfileScreen,\n      },\n    },\n    SignedOut: {\n      if: useIsSignedOut,\n      screens: {\n        SignIn: SignInScreen,\n        SignUp: SignUpScreen,\n        ResetPassword: ResetPasswordScreen,\n      },\n    },\n  },\n});\n"})})]}),(0,a.jsxs)(r.A,{value:"dynamic",label:"Dynamic",children:[(0,a.jsxs)(n.p,{children:["We can use ",(0,a.jsx)(n.a,{href:"https://react.dev/reference/react/Fragment",children:(0,a.jsx)(n.code,{children:"React.Fragment"})})," or ",(0,a.jsx)(n.a,{href:"/docs/group",children:(0,a.jsx)(n.code,{children:"Group"})})," to define multiple screens:"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'isSignedIn ? (\n  <>\n    <Stack.Screen name="SignIn" component={SignInScreen} />\n    <Stack.Screen name="SignUp" component={SignUpScreen} />\n    <Stack.Screen name="ResetPassword" component={ResetPassword} />\n  </>\n) : (\n  <>\n    <Stack.Screen name="Home" component={HomeScreen} />\n    <Stack.Screen name="Profile" component={ProfileScreen} />\n  </>\n);\n'})}),(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"Instead of having your login-related screens and rest of the screens in two different Stack navigators and render them conditionally, we recommend to use a single Stack navigator and place the conditional inside. This makes it possible to have a proper transition animation during login/logout."})})]})]}),"\n",(0,a.jsx)(n.h2,{id:"implement-the-logic-for-restoring-the-token",children:"Implement the logic for restoring the token"}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"The following is just an example of how you might implement the logic for authentication in your app. You don't need to follow it as is."})}),"\n",(0,a.jsx)(n.p,{children:"From the previous snippet, we can see that we need 3 state variables:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isLoading"})," - We set this to ",(0,a.jsx)(n.code,{children:"true"})," when we're trying to check if we already have a token saved in ",(0,a.jsx)(n.code,{children:"SecureStore"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"isSignout"})," - We set this to ",(0,a.jsx)(n.code,{children:"true"})," when user is signing out, otherwise set it to ",(0,a.jsx)(n.code,{children:"false"}),". This can be used to customize the animation when signing out."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"userToken"})," - The token for the user. If it's non-null, we assume the user is logged in, otherwise not."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"So we need to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Add some logic for restoring token, signing in and signing out"}),"\n",(0,a.jsx)(n.li,{children:"Expose methods for signing in and signing out to other components"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["We'll use ",(0,a.jsx)(n.code,{children:"React.useReducer"})," and ",(0,a.jsx)(n.code,{children:"React.useContext"})," in this guide. But if you're using a state management library such as Redux or Mobx, you can use them for this functionality instead. In fact, in bigger apps, a global state management library is more suitable for storing authentication tokens. You can adapt the same approach to your state management library."]}),"\n",(0,a.jsx)(n.p,{children:"First we'll need to create a context for auth where we can expose the necessary methods:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import * as React from 'react';\n\nconst AuthContext = React.createContext();\n"})}),"\n",(0,a.jsx)(n.p,{children:"In our component, we will:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Store the token and loading state in ",(0,a.jsx)(n.code,{children:"useReducer"})]}),"\n",(0,a.jsxs)(n.li,{children:["Persist it to ",(0,a.jsx)(n.code,{children:"SecureStore"})," and read it from there on app launch"]}),"\n",(0,a.jsxs)(n.li,{children:["Expose the methods for sign in and sign out to child components using ",(0,a.jsx)(n.code,{children:"AuthContext"})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"So our component will look like this:"}),"\n",(0,a.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,a.jsx)(r.A,{value:"static",label:"Static",default:!0,children:(0,a.jsx)(n.pre,{"data-name":"Signing in and signing out with AuthContext","data-snack":"true","data-dependencies":"expo-secure-store",children:(0,a.jsx)(n.code,{className:"language-js",metastring:'name="Signing in and signing out with AuthContext" snack dependencies=expo-secure-store',children:"// codeblock-focus-start\nimport * as React from 'react';\nimport * as SecureStore from 'expo-secure-store';\n\n// codeblock-focus-end\nimport { Text, TextInput, View } from 'react-native';\nimport { createStaticNavigation } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport { Button } from '@react-navigation/elements';\n\nconst AuthContext = React.createContext();\n\nconst SignInContext = React.createContext();\n\nfunction useIsSignedIn() {\n  const isSignedIn = React.useContext(SignInContext);\n  return isSignedIn;\n}\n\nfunction useIsSignedOut() {\n  return !useIsSignedIn();\n}\n\nfunction SplashScreen() {\n  return (\n    <View>\n      <Text>Loading...</Text>\n    </View>\n  );\n}\n\nfunction HomeScreen() {\n  const { signOut } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <Text>Signed in!</Text>\n      <Button onPress={signOut}>Sign out</Button>\n    </View>\n  );\n}\n\nfunction SignInScreen() {\n  const [username, setUsername] = React.useState('');\n  const [password, setPassword] = React.useState('');\n\n  const { signIn } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <TextInput\n        placeholder=\"Username\"\n        value={username}\n        onChangeText={setUsername}\n      />\n      <TextInput\n        placeholder=\"Password\"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button onPress={() => signIn({ username, password })}>Sign in</Button>\n    </View>\n  );\n}\n\n// codeblock-focus-start\nexport default function App() {\n  const [state, dispatch] = React.useReducer(\n    (prevState, action) => {\n      switch (action.type) {\n        case 'RESTORE_TOKEN':\n          return {\n            ...prevState,\n            userToken: action.token,\n            isLoading: false,\n          };\n        case 'SIGN_IN':\n          return {\n            ...prevState,\n            isSignout: false,\n            userToken: action.token,\n          };\n        case 'SIGN_OUT':\n          return {\n            ...prevState,\n            isSignout: true,\n            userToken: null,\n          };\n      }\n    },\n    {\n      isLoading: true,\n      isSignout: false,\n      userToken: null,\n    }\n  );\n\n  React.useEffect(() => {\n    // Fetch the token from storage then navigate to our appropriate place\n    const bootstrapAsync = async () => {\n      let userToken;\n\n      try {\n        // Restore token stored in `SecureStore` or any other encrypted storage\n        userToken = await SecureStore.getItemAsync('userToken');\n      } catch (e) {\n        // Restoring token failed\n      }\n\n      // After restoring token, we may need to validate it in production apps\n\n      // This will switch to the App screen or Auth screen and this loading\n      // screen will be unmounted and thrown away.\n      dispatch({ type: 'RESTORE_TOKEN', token: userToken });\n    };\n\n    bootstrapAsync();\n  }, []);\n\n  const authContext = React.useMemo(\n    () => ({\n      signIn: async (data) => {\n        // In a production app, we need to send some data (usually username, password) to server and get a token\n        // We will also need to handle errors if sign in failed\n        // After getting token, we need to persist the token using `SecureStore` or any other encrypted storage\n        // In the example, we'll use a dummy token\n\n        dispatch({ type: 'SIGN_IN', token: 'dummy-auth-token' });\n      },\n      signOut: () => dispatch({ type: 'SIGN_OUT' }),\n      signUp: async (data) => {\n        // In a production app, we need to send user data to server and get a token\n        // We will also need to handle errors if sign up failed\n        // After getting token, we need to persist the token using `SecureStore` or any other encrypted storage\n        // In the example, we'll use a dummy token\n\n        dispatch({ type: 'SIGN_IN', token: 'dummy-auth-token' });\n      },\n    }),\n    []\n  );\n\n  if (state.isLoading) {\n    // We haven't finished checking for the token yet\n    return <SplashScreen />;\n  }\n\n  const isSignedIn = state.userToken != null;\n\n  return (\n    <AuthContext.Provider value={authContext}>\n      <SignInContext.Provider value={isSignedIn}>\n        <Navigation />\n      </SignInContext.Provider>\n    </AuthContext.Provider>\n  );\n}\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: 'Sign in',\n      },\n    },\n  },\n});\n\nconst Navigation = createStaticNavigation(RootStack);\n// codeblock-focus-end\n"})})}),(0,a.jsx)(r.A,{value:"dynamic",label:"Dynamic",children:(0,a.jsx)(n.pre,{"data-name":"Signing in and signing out with AuthContext","data-snack":"true","data-dependencies":"expo-secure-store",children:(0,a.jsx)(n.code,{className:"language-js",metastring:'name="Signing in and signing out with AuthContext" snack dependencies=expo-secure-store',children:"// codeblock-focus-start\nimport * as React from 'react';\nimport * as SecureStore from 'expo-secure-store';\n\n// codeblock-focus-end\nimport { Text, TextInput, View } from 'react-native';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport { Button } from '@react-navigation/elements';\n\nconst AuthContext = React.createContext();\n\nfunction SplashScreen() {\n  return (\n    <View>\n      <Text>Loading...</Text>\n    </View>\n  );\n}\n\nfunction HomeScreen() {\n  const { signOut } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <Text>Signed in!</Text>\n      <Button onPress={signOut}>Sign out</Button>\n    </View>\n  );\n}\n\nfunction SignInScreen() {\n  const [username, setUsername] = React.useState('');\n  const [password, setPassword] = React.useState('');\n\n  const { signIn } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <TextInput\n        placeholder=\"Username\"\n        value={username}\n        onChangeText={setUsername}\n      />\n      <TextInput\n        placeholder=\"Password\"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button onPress={() => signIn({ username, password })}>Sign in</Button>\n    </View>\n  );\n}\n\nconst Stack = createNativeStackNavigator();\n\n// codeblock-focus-start\nexport default function App() {\n  const [state, dispatch] = React.useReducer(\n    (prevState, action) => {\n      switch (action.type) {\n        case 'RESTORE_TOKEN':\n          return {\n            ...prevState,\n            userToken: action.token,\n            isLoading: false,\n          };\n        case 'SIGN_IN':\n          return {\n            ...prevState,\n            isSignout: false,\n            userToken: action.token,\n          };\n        case 'SIGN_OUT':\n          return {\n            ...prevState,\n            isSignout: true,\n            userToken: null,\n          };\n      }\n    },\n    {\n      isLoading: true,\n      isSignout: false,\n      userToken: null,\n    }\n  );\n\n  React.useEffect(() => {\n    // Fetch the token from storage then navigate to our appropriate place\n    const bootstrapAsync = async () => {\n      let userToken;\n\n      try {\n        // Restore token stored in `SecureStore` or any other encrypted storage\n        userToken = await SecureStore.getItemAsync('userToken');\n      } catch (e) {\n        // Restoring token failed\n      }\n\n      // After restoring token, we may need to validate it in production apps\n\n      // This will switch to the App screen or Auth screen and this loading\n      // screen will be unmounted and thrown away.\n      dispatch({ type: 'RESTORE_TOKEN', token: userToken });\n    };\n\n    bootstrapAsync();\n  }, []);\n\n  const authContext = React.useMemo(\n    () => ({\n      signIn: async (data) => {\n        // In a production app, we need to send some data (usually username, password) to server and get a token\n        // We will also need to handle errors if sign in failed\n        // After getting token, we need to persist the token using `SecureStore` or any other encrypted storage\n        // In the example, we'll use a dummy token\n\n        dispatch({ type: 'SIGN_IN', token: 'dummy-auth-token' });\n      },\n      signOut: () => dispatch({ type: 'SIGN_OUT' }),\n      signUp: async (data) => {\n        // In a production app, we need to send user data to server and get a token\n        // We will also need to handle errors if sign up failed\n        // After getting token, we need to persist the token using `SecureStore` or any other encrypted storage\n        // In the example, we'll use a dummy token\n\n        dispatch({ type: 'SIGN_IN', token: 'dummy-auth-token' });\n      },\n    }),\n    []\n  );\n\n  return (\n    <AuthContext.Provider value={authContext}>\n      <NavigationContainer>\n        <Stack.Navigator>\n          {state.isLoading ? (\n            // We haven't finished checking for the token yet\n            <Stack.Screen name=\"Splash\" component={SplashScreen} />\n          ) : state.userToken == null ? (\n            // No token found, user isn't signed in\n            <Stack.Screen\n              name=\"SignIn\"\n              component={SignInScreen}\n              options={{\n                title: 'Sign in',\n                // When logging out, a pop animation feels intuitive\n                animationTypeForReplace: state.isSignout ? 'pop' : 'push',\n              }}\n            />\n          ) : (\n            // User is signed in\n            <Stack.Screen name=\"Home\" component={HomeScreen} />\n          )}\n        </Stack.Navigator>\n      </NavigationContainer>\n    </AuthContext.Provider>\n  );\n}\n// codeblock-focus-end\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"fill-in-other-components",children:"Fill in other components"}),"\n",(0,a.jsx)(n.p,{children:"We won't talk about how to implement the text inputs and buttons for the authentication screen, that is outside of the scope of navigation. We'll just fill in some placeholder content."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function SignInScreen() {\n  const [username, setUsername] = React.useState('');\n  const [password, setPassword] = React.useState('');\n\n  const { signIn } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <TextInput\n        placeholder=\"Username\"\n        value={username}\n        onChangeText={setUsername}\n      />\n      <TextInput\n        placeholder=\"Password\"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button onPress={() => signIn({ username, password })}>Sign in</Button>\n    </View>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can similarly fill in the other screens according to your requirements."}),"\n",(0,a.jsx)(n.h2,{id:"removing-shared-screens-when-auth-state-changes",children:"Removing shared screens when auth state changes"}),"\n",(0,a.jsx)(n.p,{children:"Consider the following example:"}),"\n",(0,a.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,a.jsx)(r.A,{value:"static",label:"Static",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  groups: {\n    LoggedIn: {\n      if: useIsSignedIn,\n      screens: {\n        Home: HomeScreen,\n        Profile: ProfileScreen,\n      },\n    },\n    LoggedOut: {\n      if: useIsSignedOut,\n      screens: {\n        SignIn: SignInScreen,\n        SignUp: SignUpScreen,\n      },\n    },\n  },\n  screens: {\n    Help: HelpScreen,\n  },\n});\n"})})}),(0,a.jsx)(r.A,{value:"dynamic",label:"Dynamic",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'isSignedIn ? (\n  <>\n    <Stack.Screen name="Home" component={HomeScreen} />\n    <Stack.Screen name="Profile" component={ProfileScreen} />\n    <Stack.Screen name="Help" component={HelpScreen} />\n  </>\n) : (\n  <>\n    <Stack.Screen name="SignIn" component={SignInScreen} />\n    <Stack.Screen name="SignUp" component={SignUpScreen} />\n    <Stack.Screen name="Help" component={HelpScreen} />\n  </>\n);\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["Here we have specific screens such as ",(0,a.jsx)(n.code,{children:"SignIn"}),", ",(0,a.jsx)(n.code,{children:"Home"})," etc. which are only shown depending on the sign in state. But we also have the ",(0,a.jsx)(n.code,{children:"Help"})," screen which can be shown regardless of the login status. This also means that if the sign in state changes when the user is in the ",(0,a.jsx)(n.code,{children:"Help"})," screen, they'll stay on the ",(0,a.jsx)(n.code,{children:"Help"})," screen."]}),"\n",(0,a.jsxs)(n.p,{children:["This can be a problem, we probably want the user to be taken to the ",(0,a.jsx)(n.code,{children:"SignIn"})," screen or ",(0,a.jsx)(n.code,{children:"Home"})," screen instead of keeping them on the ",(0,a.jsx)(n.code,{children:"Help"})," screen."]}),"\n",(0,a.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,a.jsxs)(r.A,{value:"static",label:"Static",default:!0,children:[(0,a.jsxs)(n.p,{children:["To make this work, we can move the ",(0,a.jsx)(n.code,{children:"Help"})," screen to both of the groups instead of keeping it outside. This will ensure that the ",(0,a.jsx)(n.a,{href:"/docs/screen#navigation-key",children:(0,a.jsx)(n.code,{children:"navigationKey"})})," (the name of the group) for the screen changes when the sign in state changes."]}),(0,a.jsx)(n.p,{children:"So our updated code will look like the following:"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  groups: {\n    LoggedIn: {\n      if: useIsSignedIn,\n      screens: {\n        Home: HomeScreen,\n        Profile: ProfileScreen,\n        Help: HelpScreen,\n      },\n    },\n    LoggedOut: {\n      if: useIsSignedOut,\n      screens: {\n        SignIn: SignInScreen,\n        SignUp: SignUpScreen,\n        Help: HelpScreen,\n      },\n    },\n  },\n});\n"})})]}),(0,a.jsxs)(r.A,{value:"dynamic",label:"Dynamic",children:[(0,a.jsxs)(n.p,{children:["To make this work, we can use ",(0,a.jsx)(n.a,{href:"/docs/screen#navigation-key",children:(0,a.jsx)(n.code,{children:"navigationKey"})}),". When the ",(0,a.jsx)(n.code,{children:"navigationKey"})," changes, React Navigation will remove all the screen."]}),(0,a.jsx)(n.p,{children:"So our updated code will look like the following:"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'<>\n  {isSignedIn ? (\n    <>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </>\n  ) : (\n    <>\n      <Stack.Screen name="SignIn" component={SignInScreen} />\n      <Stack.Screen name="SignUp" component={SignUpScreen} />\n    </>\n  )}\n  <Stack.Screen\n    navigationKey={isSignedIn ? \'user\' : \'guest\'}\n    name="Help"\n    component={HelpScreen}\n  />\n</>\n'})}),(0,a.jsxs)(n.p,{children:["If you have a bunch of shared screens, you can also use ",(0,a.jsxs)(n.a,{href:"/docs/group#navigation-key",children:[(0,a.jsx)(n.code,{children:"navigationKey"})," with a ",(0,a.jsx)(n.code,{children:"Group"})]})," to remove all of the screens in the group. For example:"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'<>\n  {isSignedIn ? (\n    <>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </>\n  ) : (\n    <>\n      <Stack.Screen name="SignIn" component={SignInScreen} />\n      <Stack.Screen name="SignUp" component={SignUpScreen} />\n    </>\n  )}\n  <Stack.Group navigationKey={isSignedIn ? \'user\' : \'guest\'}>\n    <Stack.Screen name="Help" component={HelpScreen} />\n    <Stack.Screen name="About" component={AboutScreen} />\n  </Stack.Group>\n</>\n'})})]})]}),"\n",(0,a.jsx)(n.p,{children:"The examples above show stack navigator, but you can use the same approach with any navigator."}),"\n",(0,a.jsx)(n.p,{children:"By specifying a condition for our screens, we can implement auth flow in a simple way that doesn't require additional logic to make sure that the correct screen is shown."}),"\n",(0,a.jsx)(n.h2,{id:"dont-manually-navigate-when-conditionally-rendering-screens",children:"Don't manually navigate when conditionally rendering screens"}),"\n",(0,a.jsxs)(n.p,{children:["It's important to note that when using such a setup, you ",(0,a.jsx)(n.strong,{children:"don't manually navigate"})," to the ",(0,a.jsx)(n.code,{children:"Home"})," screen by calling ",(0,a.jsx)(n.code,{children:"navigation.navigate('Home')"})," or any other method. ",(0,a.jsx)(n.strong,{children:"React Navigation will automatically navigate to the correct screen"})," when ",(0,a.jsx)(n.code,{children:"isSignedIn"})," changes - ",(0,a.jsx)(n.code,{children:"Home"})," screen when ",(0,a.jsx)(n.code,{children:"isSignedIn"})," becomes ",(0,a.jsx)(n.code,{children:"true"}),", and to ",(0,a.jsx)(n.code,{children:"SignIn"})," screen when ",(0,a.jsx)(n.code,{children:"isSignedIn"})," becomes ",(0,a.jsx)(n.code,{children:"false"}),". You'll get an error if you attempt to navigate manually."]}),"\n",(0,a.jsx)(n.h2,{id:"handling-deep-links-after-auth",children:"Handling deep links after auth"}),"\n",(0,a.jsx)(n.p,{children:"When using deep links, you may want to handle the case where the user opens a deep link that requires authentication."}),"\n",(0,a.jsx)(n.p,{children:"Example scenario:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["User opens a deep link to ",(0,a.jsx)(n.code,{children:"myapp://profile"})," but is not signed in."]}),"\n",(0,a.jsxs)(n.li,{children:["The app shows the ",(0,a.jsx)(n.code,{children:"SignIn"})," screen."]}),"\n",(0,a.jsxs)(n.li,{children:["After the user signs in, you want to navigate them to the ",(0,a.jsx)(n.code,{children:"Profile"})," screen."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["To achieve this, you can set ",(0,a.jsx)(n.a,{href:"/docs/navigator#route-names-change-behavior",children:(0,a.jsx)(n.code,{children:"UNSTABLE_routeNamesChangeBehavior"})})," to ",(0,a.jsx)(n.code,{children:'"lastUnhandled"'}),":"]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"This API is experimental and may change in a minor release."})}),"\n",(0,a.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,a.jsx)(r.A,{value:"static",label:"Static",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  // highlight-next-line\n  UNSTABLE_routeNamesChangeBehavior: 'lastUnhandled',\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: 'Sign in',\n      },\n    },\n  },\n});\n"})})}),(0,a.jsx)(r.A,{value:"dynamic",label:"Dynamic",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'<Stack.Navigator\n  // highlight-next-line\n  UNSTABLE_routeNamesChangeBehavior="lastUnhandled"\n>\n  {isSignedIn ? (\n    <Stack.Screen name="Home" component={HomeScreen} />\n  ) : (\n    <Stack.Screen name="SignIn" component={SignInScreen} />\n  )}\n</Stack.Navigator>\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"UNSTABLE_routeNamesChangeBehavior"})," option allows you to control how React Navigation handles navigation when the available screens change because of conditions such as authentication state. When ",(0,a.jsx)(n.code,{children:"lastUnhandled"})," is specified, React Navigation will remember the last screen that couldn't be handled, and after the condition changes, it'll automatically navigate to that screen if it's now available."]})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>s});t(96540);var i=t(34164);const a={tabItem:"tabItem_Ymn6"};var o=t(74848);function s(e){let{children:n,hidden:t,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,i.A)(a.tabItem,s),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>y});var i=t(96540),a=t(34164),o=t(17559),s=t(23104),r=t(56347),c=t(205),l=t(57485),d=t(31682),h=t(70679);function u(e){var n,t;return null!=(n=null==(t=i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function g(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=null!=n?n:function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:i,default:a}}=e;return{value:n,label:t,attributes:i,default:a}}))}(t);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const a=(0,r.W6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(o),(0,i.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(a.location.search);n.set(o,e),a.replace(Object.assign({},a.location,{search:n.toString()}))}),[o,a])]}function S(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,o=g(e),[s,r]=(0,i.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:i}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+i.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const a=null!=(n=i.find((e=>e.default)))?n:i[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[l,d]=m({queryString:t,groupId:a}),[u,S]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[a,o]=(0,h.Dv)(t);return[a,(0,i.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:a}),f=(()=>{const e=null!=l?l:u;return p({value:e,tabValues:o})?e:null})();(0,c.A)((()=>{f&&r(f)}),[f]);return{selectedValue:s,selectValue:(0,i.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error("Can't select invalid tab value="+e);r(e),d(e),S(e)}),[d,S,o]),tabValues:o}}var f=t(92303);const w={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=t(74848);function x(e){let{className:n,block:t,selectedValue:i,selectValue:o,tabValues:r}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),a=r[t].value;a!==i&&(l(n),o(a))},h=e=>{var n;let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var i;const n=c.indexOf(e.currentTarget)+1;t=null!=(i=c[n])?i:c[0];break}case"ArrowLeft":{var a;const n=c.indexOf(e.currentTarget)-1;t=null!=(a=c[n])?a:c[c.length-1];break}}null==(n=t)||n.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":t},n),children:r.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,v.jsx)("li",Object.assign({role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,ref:e=>{c.push(e)},onKeyDown:h,onClick:d},o,{className:(0,a.A)("tabs__item",w.tabItem,null==o?void 0:o.className,{"tabs__item--active":i===n}),children:null!=t?t:n}),n)}))})}function k(e){let{lazy:n,children:t,selectedValue:o}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===o));return e?(0,i.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==o})))})}function I(e){const n=S(e);return(0,v.jsxs)("div",{className:(0,a.A)(o.G.tabs.container,"tabs-container",w.tabList),children:[(0,v.jsx)(x,Object.assign({},n,e)),(0,v.jsx)(k,Object.assign({},n,e))]})}function y(e){const n=(0,f.A)();return(0,v.jsx)(I,Object.assign({},e,{children:u(e.children)}),String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(96540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);