"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[141],{8511:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"screen","title":"Screen","description":"Screen components are used to configure various aspects of screens inside a navigator.","source":"@site/versioned_docs/version-6.x/screen.md","sourceDirName":".","slug":"/screen","permalink":"/docs/6.x/screen","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-6.x/screen.md","tags":[],"version":"6.x","frontMatter":{"id":"screen","title":"Screen","sidebar_label":"Screen"},"sidebar":"docs","previous":{"title":"Group","permalink":"/docs/6.x/group"},"next":{"title":"Options for screens","permalink":"/docs/6.x/screen-options"}}');var r=t(74848),i=t(28453);const o={id:"screen",title:"Screen",sidebar_label:"Screen",rawMarkdown:"---\nid: screen\ntitle: Screen\nsidebar_label: Screen\n---\n\n`Screen` components are used to configure various aspects of screens inside a navigator.\n\nA `Screen` is returned from a `createXNavigator` function:\n\n```js\nconst Stack = createNativeStackNavigator(); // Stack contains Screen & Navigator properties\n```\n\nAfter creating the navigator, it can be used as children of the `Navigator` component:\n\n```js\n<Stack.Navigator>\n  <Stack.Screen name=\"Home\" component={HomeScreen} />\n  <Stack.Screen name=\"Profile\" component={ProfileScreen} />\n</Stack.Navigator>\n```\n\nYou need to provide at least a name and a component to render for each screen.\n\n## Props\n\n### `name`\n\nThe name to use for the screen. It accepts a string:\n\n```js\n<Stack.Screen name=\"Profile\" component={ProfileScreen} />\n```\n\nThis name is used to navigate to the screen:\n\n```js\nnavigation.navigate('Profile');\n```\n\nIt is also used for the `name` property in the [`route`](route-prop.md).\n\nWhile it is supported, we recommend to avoid spaces or special characters in screen names and keep them simple.\n\n### `options`\n\nOptions to configure how the screen gets presented in the navigator. It accepts either an object or a function returning an object:\n\n```js\n<Stack.Screen\n  name=\"Profile\"\n  component={ProfileScreen}\n  options={{\n    title: 'Awesome app',\n  }}\n/>\n```\n\nWhen you pass a function, it'll receive the [`route`](route-prop.md) and [`navigation`](navigation-prop.md):\n\n```js\n<Stack.Screen\n  name=\"Profile\"\n  component={ProfileScreen}\n  options={({ route, navigation }) => ({\n    title: route.params.userId,\n  })}\n/>\n```\n\nSee [Options for screens](screen-options.md) for more details and examples.\n\n### `initialParams`\n\nInitial params to use for the screen. If a screen is used as `initialRouteName`, it'll contain the params from `initialParams`. If you navigate to a new screen, the params passed are shallow merged with the initial params.\n\n```js\n<Stack.Screen\n  name=\"Details\"\n  component={DetailsScreen}\n  initialParams={{ itemId: 42 }}\n/>\n```\n\n### `getId`\n\nCallback to return an unique ID to use for the screen. It receives an object with the route params:\n\n```js\n<Stack.Screen\n  name=\"Profile\"\n  component={ProfileScreen}\n  getId={({ params }) => params.userId}\n/>\n```\n\nBy default, `navigate('ScreenName', params)` identifies the screen by its name. So if you're on `ScreenName` and navigate to `ScreenName` again, it won't add a new screen even if the params are different - it'll update the current screen with the new params instead:\n\n```js\n// Let's say you're on `Home` screen\n// Then you navigate to `Profile` screen with `userId: 1`\nnavigation.navigate('Profile', { userId: 1 });\n\n// Now the stack will have: `Home` -> `Profile` with `userId: 1`\n\n// Then you navigate to `Profile` screen again with `userId: 2`\nnavigation.navigate('Profile', { userId: 2 });\n\n// The stack will now have: `Home` -> `Profile` with `userId: 2`\n```\n\nIf you specify `getId` and it doesn't return `undefined`, the screen is identified by both the screen name and the returned ID. Which means that if you're on `ScreenName` and navigate to `ScreenName` again with different params - and return a different ID from the `getId` callback, it'll add a new screen to the stack:\n\n```js\n// Let's say you're on `Home` screen\n// Then you navigate to `Profile` screen with `userId: 1`\nnavigation.navigate('Profile', { userId: 1 });\n\n// Now the stack will have: `Home` -> `Profile` with `userId: 1`\n\n// Then you navigate to `Profile` screen again with `userId: 2`\nnavigation.navigate('Profile', { userId: 2 });\n\n// The stack will now have: `Home` -> `Profile` with `userId: 1` -> `Profile` with `userId: 2`\n```\n\nThe `getId` callback can also be used to ensure that the screen with the same ID doesn't appear multiple times in the stack:\n\n```js\n// Let's say you have a stack with the screens: `Home` -> `Profile` with `userId: 1` -> `Settings`\n// Then you navigate to `Profile` screen with `userId: 1` again\nnavigation.navigate('Profile', { userId: 1 });\n\n// Now the stack will have: `Home` -> `Profile` with `userId: 1`\n```\n\nIn the above examples, `params.userId` is used as an ID, subsequent navigation to the screen with the same `userId` will navigate to the existing screen instead of adding a new one to the stack. If the navigation was with a different `userId`, then it'll add a new screen.\n\nIf `getId` is specified in a tab or drawer navigator, the screen will remount if the ID changes.\n\n### `component`\n\nThe React Component to render for the screen:\n\n```js\n<Stack.Screen name=\"Profile\" component={ProfileScreen} />\n```\n\n### `getComponent`\n\nCallback to return the React Component to render for the screen:\n\n```js\n<Stack.Screen\n  name=\"Profile\"\n  getComponent={() => require('./ProfileScreen').default}\n/>\n```\n\nYou can use this approach instead of the `component` prop if you want the `ProfileScreen` module to be lazily evaluated when needed. This is especially useful when using [ram bundles](https://reactnative.dev/docs/ram-bundles-inline-requires) to improve initial load.\n\n### `children`\n\nRender callback to return React Element to use for the screen:\n\n```js\n<Stack.Screen name=\"Profile\">\n  {(props) => <ProfileScreen {...props} />}\n</Stack.Screen>\n```\n\nYou can use this approach instead of the `component` prop if you need to pass additional props. Though we recommend using [React context](https://react.dev/reference/react/useContext) for passing data instead.\n\n:::warning\n\nBy default, React Navigation applies optimizations to screen components to prevent unnecessary renders. Using a render callback removes those optimizations. So if you use a render callback, you'll need to ensure that you use [`React.memo`](https://react.dev/reference/react/memo) or [`React.PureComponent`](https://react.dev/reference/react/PureComponent) for your screen components to avoid performance issues.\n\n:::\n\n### `navigationKey`\n\nOptional key for this screen. This doesn't need to be unique. If the key changes, existing screens with this name will be removed (if used in a stack navigator) or reset (if used in a tab or drawer navigator).\n\nThis can be useful when we have some screens which we want to be removed or reset when the condition changes:\n\n```js\n<Stack.Screen\n  navigationKey={isSignedIn ? 'user' : 'guest'}\n  name=\"Profile\"\n  component={ProfileScreen}\n/>\n```\n\n### `listeners`\n\nEvent listeners to subscribe to. See [`listeners` prop on `Screen`](navigation-events.md#listeners-prop-on-screen) for more details.\n"},s=void 0,c={},d=[{value:"Props",id:"props",level:2},{value:"<code>name</code>",id:"name",level:3},{value:"<code>options</code>",id:"options",level:3},{value:"<code>initialParams</code>",id:"initialparams",level:3},{value:"<code>getId</code>",id:"getid",level:3},{value:"<code>component</code>",id:"component",level:3},{value:"<code>getComponent</code>",id:"getcomponent",level:3},{value:"<code>children</code>",id:"children",level:3},{value:"<code>navigationKey</code>",id:"navigationkey",level:3},{value:"<code>listeners</code>",id:"listeners",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Screen"})," components are used to configure various aspects of screens inside a navigator."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"Screen"})," is returned from a ",(0,r.jsx)(n.code,{children:"createXNavigator"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createNativeStackNavigator(); // Stack contains Screen & Navigator properties\n"})}),"\n",(0,r.jsxs)(n.p,{children:["After creating the navigator, it can be used as children of the ",(0,r.jsx)(n.code,{children:"Navigator"})," component:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Stack.Navigator>\n  <Stack.Screen name="Home" component={HomeScreen} />\n  <Stack.Screen name="Profile" component={ProfileScreen} />\n</Stack.Navigator>\n'})}),"\n",(0,r.jsx)(n.p,{children:"You need to provide at least a name and a component to render for each screen."}),"\n",(0,r.jsx)(n.h2,{id:"props",children:"Props"}),"\n",(0,r.jsx)(n.h3,{id:"name",children:(0,r.jsx)(n.code,{children:"name"})}),"\n",(0,r.jsx)(n.p,{children:"The name to use for the screen. It accepts a string:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Stack.Screen name="Profile" component={ProfileScreen} />\n'})}),"\n",(0,r.jsx)(n.p,{children:"This name is used to navigate to the screen:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"navigation.navigate('Profile');\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It is also used for the ",(0,r.jsx)(n.code,{children:"name"})," property in the ",(0,r.jsx)(n.a,{href:"/docs/6.x/route-prop",children:(0,r.jsx)(n.code,{children:"route"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:"While it is supported, we recommend to avoid spaces or special characters in screen names and keep them simple."}),"\n",(0,r.jsx)(n.h3,{id:"options",children:(0,r.jsx)(n.code,{children:"options"})}),"\n",(0,r.jsx)(n.p,{children:"Options to configure how the screen gets presented in the navigator. It accepts either an object or a function returning an object:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"<Stack.Screen\n  name=\"Profile\"\n  component={ProfileScreen}\n  options={{\n    title: 'Awesome app',\n  }}\n/>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When you pass a function, it'll receive the ",(0,r.jsx)(n.a,{href:"/docs/6.x/route-prop",children:(0,r.jsx)(n.code,{children:"route"})})," and ",(0,r.jsx)(n.a,{href:"/docs/6.x/navigation-prop",children:(0,r.jsx)(n.code,{children:"navigation"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Stack.Screen\n  name="Profile"\n  component={ProfileScreen}\n  options={({ route, navigation }) => ({\n    title: route.params.userId,\n  })}\n/>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"/docs/6.x/screen-options",children:"Options for screens"})," for more details and examples."]}),"\n",(0,r.jsx)(n.h3,{id:"initialparams",children:(0,r.jsx)(n.code,{children:"initialParams"})}),"\n",(0,r.jsxs)(n.p,{children:["Initial params to use for the screen. If a screen is used as ",(0,r.jsx)(n.code,{children:"initialRouteName"}),", it'll contain the params from ",(0,r.jsx)(n.code,{children:"initialParams"}),". If you navigate to a new screen, the params passed are shallow merged with the initial params."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Stack.Screen\n  name="Details"\n  component={DetailsScreen}\n  initialParams={{ itemId: 42 }}\n/>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"getid",children:(0,r.jsx)(n.code,{children:"getId"})}),"\n",(0,r.jsx)(n.p,{children:"Callback to return an unique ID to use for the screen. It receives an object with the route params:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Stack.Screen\n  name="Profile"\n  component={ProfileScreen}\n  getId={({ params }) => params.userId}\n/>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["By default, ",(0,r.jsx)(n.code,{children:"navigate('ScreenName', params)"})," identifies the screen by its name. So if you're on ",(0,r.jsx)(n.code,{children:"ScreenName"})," and navigate to ",(0,r.jsx)(n.code,{children:"ScreenName"})," again, it won't add a new screen even if the params are different - it'll update the current screen with the new params instead:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Let's say you're on `Home` screen\n// Then you navigate to `Profile` screen with `userId: 1`\nnavigation.navigate('Profile', { userId: 1 });\n\n// Now the stack will have: `Home` -> `Profile` with `userId: 1`\n\n// Then you navigate to `Profile` screen again with `userId: 2`\nnavigation.navigate('Profile', { userId: 2 });\n\n// The stack will now have: `Home` -> `Profile` with `userId: 2`\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you specify ",(0,r.jsx)(n.code,{children:"getId"})," and it doesn't return ",(0,r.jsx)(n.code,{children:"undefined"}),", the screen is identified by both the screen name and the returned ID. Which means that if you're on ",(0,r.jsx)(n.code,{children:"ScreenName"})," and navigate to ",(0,r.jsx)(n.code,{children:"ScreenName"})," again with different params - and return a different ID from the ",(0,r.jsx)(n.code,{children:"getId"})," callback, it'll add a new screen to the stack:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Let's say you're on `Home` screen\n// Then you navigate to `Profile` screen with `userId: 1`\nnavigation.navigate('Profile', { userId: 1 });\n\n// Now the stack will have: `Home` -> `Profile` with `userId: 1`\n\n// Then you navigate to `Profile` screen again with `userId: 2`\nnavigation.navigate('Profile', { userId: 2 });\n\n// The stack will now have: `Home` -> `Profile` with `userId: 1` -> `Profile` with `userId: 2`\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"getId"})," callback can also be used to ensure that the screen with the same ID doesn't appear multiple times in the stack:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Let's say you have a stack with the screens: `Home` -> `Profile` with `userId: 1` -> `Settings`\n// Then you navigate to `Profile` screen with `userId: 1` again\nnavigation.navigate('Profile', { userId: 1 });\n\n// Now the stack will have: `Home` -> `Profile` with `userId: 1`\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the above examples, ",(0,r.jsx)(n.code,{children:"params.userId"})," is used as an ID, subsequent navigation to the screen with the same ",(0,r.jsx)(n.code,{children:"userId"})," will navigate to the existing screen instead of adding a new one to the stack. If the navigation was with a different ",(0,r.jsx)(n.code,{children:"userId"}),", then it'll add a new screen."]}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"getId"})," is specified in a tab or drawer navigator, the screen will remount if the ID changes."]}),"\n",(0,r.jsx)(n.h3,{id:"component",children:(0,r.jsx)(n.code,{children:"component"})}),"\n",(0,r.jsx)(n.p,{children:"The React Component to render for the screen:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Stack.Screen name="Profile" component={ProfileScreen} />\n'})}),"\n",(0,r.jsx)(n.h3,{id:"getcomponent",children:(0,r.jsx)(n.code,{children:"getComponent"})}),"\n",(0,r.jsx)(n.p,{children:"Callback to return the React Component to render for the screen:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"<Stack.Screen\n  name=\"Profile\"\n  getComponent={() => require('./ProfileScreen').default}\n/>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can use this approach instead of the ",(0,r.jsx)(n.code,{children:"component"})," prop if you want the ",(0,r.jsx)(n.code,{children:"ProfileScreen"})," module to be lazily evaluated when needed. This is especially useful when using ",(0,r.jsx)(n.a,{href:"https://reactnative.dev/docs/ram-bundles-inline-requires",children:"ram bundles"})," to improve initial load."]}),"\n",(0,r.jsx)(n.h3,{id:"children",children:(0,r.jsx)(n.code,{children:"children"})}),"\n",(0,r.jsx)(n.p,{children:"Render callback to return React Element to use for the screen:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Stack.Screen name="Profile">\n  {(props) => <ProfileScreen {...props} />}\n</Stack.Screen>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can use this approach instead of the ",(0,r.jsx)(n.code,{children:"component"})," prop if you need to pass additional props. Though we recommend using ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/useContext",children:"React context"})," for passing data instead."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["By default, React Navigation applies optimizations to screen components to prevent unnecessary renders. Using a render callback removes those optimizations. So if you use a render callback, you'll need to ensure that you use ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/memo",children:(0,r.jsx)(n.code,{children:"React.memo"})})," or ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/PureComponent",children:(0,r.jsx)(n.code,{children:"React.PureComponent"})})," for your screen components to avoid performance issues."]})}),"\n",(0,r.jsx)(n.h3,{id:"navigationkey",children:(0,r.jsx)(n.code,{children:"navigationKey"})}),"\n",(0,r.jsx)(n.p,{children:"Optional key for this screen. This doesn't need to be unique. If the key changes, existing screens with this name will be removed (if used in a stack navigator) or reset (if used in a tab or drawer navigator)."}),"\n",(0,r.jsx)(n.p,{children:"This can be useful when we have some screens which we want to be removed or reset when the condition changes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"<Stack.Screen\n  navigationKey={isSignedIn ? 'user' : 'guest'}\n  name=\"Profile\"\n  component={ProfileScreen}\n/>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"listeners",children:(0,r.jsx)(n.code,{children:"listeners"})}),"\n",(0,r.jsxs)(n.p,{children:["Event listeners to subscribe to. See ",(0,r.jsxs)(n.a,{href:"/docs/6.x/navigation-events#listeners-prop-on-screen",children:[(0,r.jsx)(n.code,{children:"listeners"})," prop on ",(0,r.jsx)(n.code,{children:"Screen"})]})," for more details."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);