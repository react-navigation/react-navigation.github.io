"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[87225],{61654:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"navigation-lifecycle","title":"Navigation lifecycle","description":"In the previous section, we worked with a stack navigator that has two screens (Home and Details) and learned how to use this.props.navigation.navigate(\'RouteName\') to navigate between the routes.","source":"@site/versioned_docs/version-3.x/navigation-lifecycle.md","sourceDirName":".","slug":"/navigation-lifecycle","permalink":"/docs/3.x/navigation-lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-3.x/navigation-lifecycle.md","tags":[],"version":"3.x","frontMatter":{"id":"navigation-lifecycle","title":"Navigation lifecycle","sidebar_label":"Navigation lifecycle"},"sidebar":"version-3.x-docs","previous":{"title":"Moving between screens","permalink":"/docs/3.x/navigating"},"next":{"title":"Passing parameters to routes","permalink":"/docs/3.x/params"}}');var a=n(74848),o=n(28453);const s={id:"navigation-lifecycle",title:"Navigation lifecycle",sidebar_label:"Navigation lifecycle",rawMarkdown:"---\nid: navigation-lifecycle\ntitle: Navigation lifecycle\nsidebar_label: Navigation lifecycle\n---\n\nIn the previous section, we worked with a stack navigator that has two screens (`Home` and `Details`) and learned how to use `this.props.navigation.navigate('RouteName')` to navigate between the routes.\n\nAn important question in this context is: what happens with `Home` when we navigate away from it, or when we come back to it? How does a route find out that a user is leaving it or coming back to it?\n\nComing to react-navigation from the web, you may assume that when user navigates from route A to route B, A will unmount (its `componentWillUnmount` is called) and A will mount again when user comes back to it. While these React lifecycle methods are still valid and are used in react-navigation, their usage differs from the web. This is driven by more complex needs of mobile navigation.\n\n## Example scenario\n\nConsider a stack navigator with screens A and B. After navigating to A, its `componentDidMount` is called. When pushing B, its `componentDidMount` is also called, but A remains mounted on the stack and its `componentWillUnmount` is therefore not called.\n\nWhen going back from B to A, `componentWillUnmount` of B is called, but `componentDidMount` of A is not because A remained mounted the whole time.\n\nSimilar results can be observed (in combination) with other navigators as well. Consider a tab navigator with two tabs, where each tab is a stack navigator:\n\n```jsx\nconst HomeStack = createStackNavigator({\n  Home: HomeScreen,\n  Details: DetailsScreen,\n});\n\nconst SettingsStack = createStackNavigator({\n  Settings: SettingsScreen,\n  Profile: ProfileScreen,\n});\n\nconst TabNavigator = createBottomTabNavigator({\n  Home: HomeStack,\n  Settings: SettingsStack,\n});\n```\n\nWe start on the `HomeScreen` and navigate to `DetailsScreen`. Then we use the tab bar to switch to the `SettingsScreen` and navigate to `ProfileScreen`. After this sequence of operations is done, all 4 of the screens are mounted! If you use the tab bar to switch back to the `HomeStack`, you'll notice you'll be presented with the `DetailsScreen` - the navigation state of the `HomeStack` has been preserved!\n\n## React Navigation lifecycle events\n\nNow that we understand how React lifecycle methods work in React Navigation, let's answer the question we asked at the beginning: \"How do we find out that a user is leaving it or coming back to it?\"\n\nReact Navigation emits events to screen components that subscribe to them. There are four different events that you can subscribe to: `willFocus`, `willBlur`, `didFocus` and `didBlur`. Read more about them in the [API reference](navigation-prop.md#addlistener---subscribe-to-updates-to-navigation-lifecycle).\n\nMany of your use cases may be covered with the [`withNavigationFocus` HOC](with-navigation-focus.md) or the [`<NavigationEvents />` component](navigation-events.md) which are a little more straightforward to use.\n\n## Summary\n\n- while React's lifecycle methods are still valid, React Navigation adds more lifecycle events that you can subscribe to through the `navigation` prop.\n- you may also use the `withNavigationFocus` HOC or `<NavigationEvents />` component to react to lifecycle changes\n"},c=void 0,r={},l=[{value:"Example scenario",id:"example-scenario",level:2},{value:"React Navigation lifecycle events",id:"react-navigation-lifecycle-events",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["In the previous section, we worked with a stack navigator that has two screens (",(0,a.jsx)(t.code,{children:"Home"})," and ",(0,a.jsx)(t.code,{children:"Details"}),") and learned how to use ",(0,a.jsx)(t.code,{children:"this.props.navigation.navigate('RouteName')"})," to navigate between the routes."]}),"\n",(0,a.jsxs)(t.p,{children:["An important question in this context is: what happens with ",(0,a.jsx)(t.code,{children:"Home"})," when we navigate away from it, or when we come back to it? How does a route find out that a user is leaving it or coming back to it?"]}),"\n",(0,a.jsxs)(t.p,{children:["Coming to react-navigation from the web, you may assume that when user navigates from route A to route B, A will unmount (its ",(0,a.jsx)(t.code,{children:"componentWillUnmount"})," is called) and A will mount again when user comes back to it. While these React lifecycle methods are still valid and are used in react-navigation, their usage differs from the web. This is driven by more complex needs of mobile navigation."]}),"\n",(0,a.jsx)(t.h2,{id:"example-scenario",children:"Example scenario"}),"\n",(0,a.jsxs)(t.p,{children:["Consider a stack navigator with screens A and B. After navigating to A, its ",(0,a.jsx)(t.code,{children:"componentDidMount"})," is called. When pushing B, its ",(0,a.jsx)(t.code,{children:"componentDidMount"})," is also called, but A remains mounted on the stack and its ",(0,a.jsx)(t.code,{children:"componentWillUnmount"})," is therefore not called."]}),"\n",(0,a.jsxs)(t.p,{children:["When going back from B to A, ",(0,a.jsx)(t.code,{children:"componentWillUnmount"})," of B is called, but ",(0,a.jsx)(t.code,{children:"componentDidMount"})," of A is not because A remained mounted the whole time."]}),"\n",(0,a.jsx)(t.p,{children:"Similar results can be observed (in combination) with other navigators as well. Consider a tab navigator with two tabs, where each tab is a stack navigator:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"const HomeStack = createStackNavigator({\n  Home: HomeScreen,\n  Details: DetailsScreen,\n});\n\nconst SettingsStack = createStackNavigator({\n  Settings: SettingsScreen,\n  Profile: ProfileScreen,\n});\n\nconst TabNavigator = createBottomTabNavigator({\n  Home: HomeStack,\n  Settings: SettingsStack,\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We start on the ",(0,a.jsx)(t.code,{children:"HomeScreen"})," and navigate to ",(0,a.jsx)(t.code,{children:"DetailsScreen"}),". Then we use the tab bar to switch to the ",(0,a.jsx)(t.code,{children:"SettingsScreen"})," and navigate to ",(0,a.jsx)(t.code,{children:"ProfileScreen"}),". After this sequence of operations is done, all 4 of the screens are mounted! If you use the tab bar to switch back to the ",(0,a.jsx)(t.code,{children:"HomeStack"}),", you'll notice you'll be presented with the ",(0,a.jsx)(t.code,{children:"DetailsScreen"})," - the navigation state of the ",(0,a.jsx)(t.code,{children:"HomeStack"})," has been preserved!"]}),"\n",(0,a.jsx)(t.h2,{id:"react-navigation-lifecycle-events",children:"React Navigation lifecycle events"}),"\n",(0,a.jsx)(t.p,{children:'Now that we understand how React lifecycle methods work in React Navigation, let\'s answer the question we asked at the beginning: "How do we find out that a user is leaving it or coming back to it?"'}),"\n",(0,a.jsxs)(t.p,{children:["React Navigation emits events to screen components that subscribe to them. There are four different events that you can subscribe to: ",(0,a.jsx)(t.code,{children:"willFocus"}),", ",(0,a.jsx)(t.code,{children:"willBlur"}),", ",(0,a.jsx)(t.code,{children:"didFocus"})," and ",(0,a.jsx)(t.code,{children:"didBlur"}),". Read more about them in the ",(0,a.jsx)(t.a,{href:"/docs/3.x/navigation-prop#addlistener---subscribe-to-updates-to-navigation-lifecycle",children:"API reference"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Many of your use cases may be covered with the ",(0,a.jsxs)(t.a,{href:"/docs/3.x/with-navigation-focus",children:[(0,a.jsx)(t.code,{children:"withNavigationFocus"})," HOC"]})," or the ",(0,a.jsxs)(t.a,{href:"/docs/3.x/navigation-events",children:[(0,a.jsx)(t.code,{children:"<NavigationEvents />"})," component"]})," which are a little more straightforward to use."]}),"\n",(0,a.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["while React's lifecycle methods are still valid, React Navigation adds more lifecycle events that you can subscribe to through the ",(0,a.jsx)(t.code,{children:"navigation"})," prop."]}),"\n",(0,a.jsxs)(t.li,{children:["you may also use the ",(0,a.jsx)(t.code,{children:"withNavigationFocus"})," HOC or ",(0,a.jsx)(t.code,{children:"<NavigationEvents />"})," component to react to lifecycle changes"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var i=n(96540);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);