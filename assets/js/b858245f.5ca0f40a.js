"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([["11262"],{92859(e,t,s){s.r(t),s.d(t,{metadata:()=>n,default:()=>l,frontMatter:()=>o,contentTitle:()=>r,toc:()=>d,assets:()=>c});var n=JSON.parse('{"id":"navigation-state","title":"Navigation state reference","description":"The navigation state is the state where React Navigation stores the navigation structure and history of the app. It\'s useful to know about the structure of the navigation state if you need to do advanced operations such as resetting the state, providing a custom initial state etc.","source":"@site/versioned_docs/version-8.x/navigation-state.md","sourceDirName":".","slug":"/navigation-state","permalink":"/docs/8.x/navigation-state","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-8.x/navigation-state.md","tags":[],"version":"8.x","frontMatter":{"id":"navigation-state","title":"Navigation state reference","sidebar_label":"Navigation state"},"sidebar":"docs","previous":{"title":"Navigation events","permalink":"/docs/8.x/navigation-events"},"next":{"title":"Link","permalink":"/docs/8.x/link"}}'),i=s(74848),a=s(28453);let o={id:"navigation-state",title:"Navigation state reference",sidebar_label:"Navigation state"},r,c={},d=[{value:"History stack",id:"history-stack",level:2},{value:"Stale state objects",id:"stale-state-objects",level:2}];function h(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["The navigation state is the state where React Navigation stores the navigation structure and history of the app. It's useful to know about the structure of the navigation state if you need to do advanced operations such as ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-actions#reset",children:"resetting the state"}),", ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-container#initialstate",children:"providing a custom initial state"})," etc."]}),"\n",(0,i.jsx)(t.p,{children:"It's a JavaScript object which looks like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    { key: 'home-1', name: 'Home', params: { sortBy: 'latest' } },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n  stale: false,\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"There are few properties present in every navigation state object:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"type"})," - Type of the navigator that the state belongs to, e.g. ",(0,i.jsx)(t.code,{children:"stack"}),", ",(0,i.jsx)(t.code,{children:"tab"}),", ",(0,i.jsx)(t.code,{children:"drawer"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"key"})," - Unique key to identify the navigator."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"routeNames"})," - Name of the screens defined in the navigator. This is an unique array containing strings for each screen."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"routes"})," - List of route objects (screens) which are rendered in the navigator. It also represents the history in a stack navigator. There should be at least one item present in this array."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"index"})," - Index of the focused route object in the ",(0,i.jsx)(t.code,{children:"routes"})," array."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"history"})," - An optional list of visited items. See ",(0,i.jsx)(t.a,{href:"#history-stack",children:"History stack"})," for more details."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"stale"})," - A navigation state is assumed to be stale unless the ",(0,i.jsx)(t.code,{children:"stale"})," property is explicitly set to ",(0,i.jsx)(t.code,{children:"false"}),". This means that the state object needs to be ",(0,i.jsx)(t.a,{href:"#stale-state-objects",children:'"rehydrated"'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Each route object in a ",(0,i.jsx)(t.code,{children:"routes"})," array may contain the following properties:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"key"})," - Unique key of the screen. Created automatically or added while navigating to this screen."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"name"})," - Name of the screen. Defined in navigator component hierarchy."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"params"})," - An optional object containing params which is defined while navigating e.g. ",(0,i.jsx)(t.code,{children:"navigate('Home', { sortBy: 'latest' })"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"history"})," - An optional list of history items for the route. See ",(0,i.jsx)(t.a,{href:"#history-stack",children:"History stack"})," for more details."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"state"})," - An optional object containing the ",(0,i.jsx)(t.a,{href:"#stale-state-objects",children:"stale navigation state"})," of a child navigator nested inside this screen."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"For example, a stack navigator containing a tab navigator nested inside it's home screen may have a navigation state object like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    {\n      key: 'home-1',\n      name: 'Home',\n      state: {\n        key: 'tab-1',\n        routeNames: ['Feed', 'Library', 'Favorites'],\n        routes: [\n          { key: 'feed-1', name: 'Feed', params: { sortBy: 'latest' } },\n          { key: 'library-1', name: 'Library' },\n          { key: 'favorites-1', name: 'Favorites' },\n        ],\n        index: 0,\n      },\n    },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It's important to note that even if there's a nested navigator, the ",(0,i.jsx)(t.code,{children:"state"})," property on the ",(0,i.jsx)(t.code,{children:"route"})," object is not added until a navigation happens, hence it's not guaranteed to exist, or maybe ",(0,i.jsx)(t.a,{href:"#stale-state-objects",children:"stale"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"history-stack",children:"History stack"}),"\n",(0,i.jsx)(t.p,{children:"In React Navigation, each navigator may maintain a history stack to keep track of visited entries. This is used when navigating back, syncing with browser history on the Web, etc."}),"\n",(0,i.jsx)(t.p,{children:"Unlike Web, which has a linear history stack, React Navigation uses a nested history stack mirroring mobile navigation patterns. A parent navigator maintains its own history stack, while each child navigator also maintains its own history stack. When navigating back, it goes back in the history stack of the navigator where the \"go back\" action was triggered - and if that stack is empty, it bubbles up to the parent navigator's history stack. Any sibling navigators' history stacks are not affected."}),"\n",(0,i.jsx)(t.p,{children:"The history stack for a navigator is determined from the following sources:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"state.history"})," if present, otherwise ",(0,i.jsx)(t.code,{children:"state.routes"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"route.history"})," for each route in ",(0,i.jsx)(t.code,{children:"state.routes"})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"When determining total length of history stack (e.g. to sync with browser history on the Web), these 2 sources are combined."}),"\n",(0,i.jsxs)(t.p,{children:["The content and shape of items in the ",(0,i.jsx)(t.code,{children:"state.history"})," array can vary depending on the navigator. There should be at least one item present in this array. Among built-in navigators, this property is present only in tab and drawer navigators. For example, the ",(0,i.jsx)(t.code,{children:"history"})," array in a drawer navigator looks like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  history: [\n    { type: 'route', key: 'home-1' },\n    { type: 'route', key: 'settings-1' },\n    { type: 'drawer', status: 'open' },\n  ],\n\n  // ...\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This array is populated based on the ",(0,i.jsx)(t.code,{children:"backBehavior"})," prop of the tab or drawer navigators:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"firstRoute"})," - the first route defined in the navigator and the focused route"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"initialRoute"})," - the initial route defined in the navigator and the focused route"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"order"})," - the focused route and any routes defined before it in the navigator, in the order they are defined"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"history"})," - deduplicated list of previously visited routes in the navigator and the focused route"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"fullHistory"})," - full list of previously visited routes in the navigator and the focused route"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"none"})," - only the focused route"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Similarly, each ",(0,i.jsx)(t.code,{children:"route"})," object in the ",(0,i.jsx)(t.code,{children:"routes"})," array may also have a ",(0,i.jsx)(t.code,{children:"history"})," property which maintains a history stack for that specific route. It contains previous params in built-in navigators:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const route = {\n  history: [\n    { type: 'params', params: { sortBy: 'latest' } },\n    { type: 'params', params: { sortBy: 'popular' } },\n  ],\n  params: { sortBy: 'trending' },\n\n  // ...\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["By default, this property is populated when using the ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-actions#pushparams",children:(0,i.jsx)(t.code,{children:"pushParams"})})," action. The ",(0,i.jsx)(t.code,{children:"params"})," property on the route object always contains the latest params, while the ",(0,i.jsx)(t.code,{children:"history"})," array contains previous params in the order they were updated."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/docs/8.x/custom-routers",children:"Custom routers"})," may also add different types of items to the ",(0,i.jsx)(t.code,{children:"history"})," array to represent different kinds of history entries."]}),"\n",(0,i.jsx)(t.h2,{id:"stale-state-objects",children:"Stale state objects"}),"\n",(0,i.jsxs)(t.p,{children:["Earlier there was a mention of ",(0,i.jsx)(t.code,{children:"stale"})," property in the navigation state. If the ",(0,i.jsx)(t.code,{children:"stale"})," property is set to ",(0,i.jsx)(t.code,{children:"true"})," or is missing, the state is assumed to be stale. Typically this is not something to worry about unless you're using the navigation state object directly for advanced use-cases."]}),"\n",(0,i.jsxs)(t.p,{children:["A stale navigation state means that the state object may be partial, such as missing keys or routes, contain invalid routes, or may not be up-to-date. A stale state can be a result of ",(0,i.jsx)(t.a,{href:"/docs/8.x/deep-linking",children:"deep linking"}),", ",(0,i.jsx)(t.a,{href:"/docs/8.x/state-persistence",children:"restoring from a persisted state"})," etc."]}),"\n",(0,i.jsx)(t.p,{children:"The state object is guaranteed to not be stale when accessing it with built-in APIs such as:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Navigator's state with ",(0,i.jsx)(t.a,{href:"/docs/8.x/use-navigation-state",children:(0,i.jsx)(t.code,{children:"useNavigationState()"})})," or ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-object#getstate",children:(0,i.jsx)(t.code,{children:"navigation.getState()"})})," - not including child navigators."]}),"\n",(0,i.jsxs)(t.li,{children:["Complete state of the navigation tree with ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-container#getrootstate",children:(0,i.jsx)(t.code,{children:"ref.getRootState()"})})," including root navigator and all child navigators."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["However, if you try to access a child navigator's state with the ",(0,i.jsx)(t.code,{children:"state"})," property on the ",(0,i.jsx)(t.a,{href:"/docs/8.x/route-object",children:(0,i.jsx)(t.code,{children:"route"})})," object, it maybe a stale or partial state object. So it's not recommended to use this property directly."]}),"\n",(0,i.jsxs)(t.p,{children:["When React Navigation encounters stale or partial state, it will automatically fix it up before using it. This includes adding missing keys, removing any invalid routes, ensuring the ",(0,i.jsx)(t.code,{children:"index"})," is correct etc. This process of fixing stale state is called ",(0,i.jsx)(t.strong,{children:"rehydration"}),". If you're writing a ",(0,i.jsx)(t.a,{href:"/docs/8.x/custom-routers",children:"custom router"}),", the ",(0,i.jsx)(t.code,{children:"getRehydratedState"})," method lets you write custom rehydration logic to fix up state objects."]}),"\n",(0,i.jsxs)(t.p,{children:["This feature comes handy when doing operations such as ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-actions#reset",children:"reset"}),", ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-container#initialstate",children:"providing a initial state"})," etc., as you can safely omit many properties from the navigation state object and relying on React Navigation to add those properties for you, making your code simpler."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, you can only provide a state without ",(0,i.jsx)(t.code,{children:"index"}),", ",(0,i.jsx)(t.code,{children:"keys"})," etc. only with a ",(0,i.jsx)(t.code,{children:"routes"})," array without any keys and React Navigation will automatically add everything that's needed to make it work:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  routes: [{ name: 'Home' }, { name: 'Profile' }],\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"After rehydration, it'll look something like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    { key: 'home-1', name: 'Home' },\n    { key: 'profile-1', name: 'Profile' },\n  ],\n  index: 1,\n  stale: false,\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here, React Navigation filled in the missing bits such as keys, route names, index etc."}),"\n",(0,i.jsxs)(t.p,{children:["It's also possible to provide invalid data such as non-existent screens and it'll be fixed automatically. While it's not recommended to write code with invalid state objects, it can be super useful if you do things like ",(0,i.jsx)(t.a,{href:"/docs/8.x/state-persistence",children:"state persistence"}),", where the configured screens might have changed after an update, which could cause problems if React Navigation didn't fix the state object automatically."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["If you want React Navigation to fix invalid state, make sure that you don't have ",(0,i.jsx)(t.code,{children:"stale: false"})," in the state object. State objects with ",(0,i.jsx)(t.code,{children:"stale: false"})," are assumed to be valid state objects and React Navigation won't attempt to fix them. If ",(0,i.jsx)(t.code,{children:"stale"})," is missing or set to ",(0,i.jsx)(t.code,{children:"true"}),", React Navigation will always try to rehydrate the state object."]})}),"\n",(0,i.jsxs)(t.p,{children:["When you're providing a state object in ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-container#initialstate",children:(0,i.jsx)(t.code,{children:"initialState"})}),", React Navigation will always assume that it's a stale state object, since navigation configuration may have changed since the last time. This makes sure that things like ",(0,i.jsx)(t.a,{href:"/docs/8.x/state-persistence",children:"state persistence"})," work smoothly without extra manipulation of the state object."]})]})}function l(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453(e,t,s){s.d(t,{R:()=>o,x:()=>r});var n=s(96540);let i={},a=n.createContext(i);function o(e){let t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);