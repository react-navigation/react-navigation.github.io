"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[17182],{58219:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>c,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"screen","title":"Screen","description":"A screen represents routes in a navigator. A screen\'s configuration contains the component for the route, options, event listeners, etc.","source":"@site/versioned_docs/version-8.x/screen.md","sourceDirName":".","slug":"/screen","permalink":"/docs/8.x/screen","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-8.x/screen.md","tags":[],"version":"8.x","frontMatter":{"id":"screen","title":"Screen","sidebar_label":"Screen"},"sidebar":"docs","previous":{"title":"Group","permalink":"/docs/8.x/group"},"next":{"title":"Options for screens","permalink":"/docs/8.x/screen-options"}}');var r=t(74848),i=t(28453),s=t(11470),o=t(19365);const c={id:"screen",title:"Screen",sidebar_label:"Screen",rawMarkdown:'---\nid: screen\ntitle: Screen\nsidebar_label: Screen\n---\n\nimport Tabs from \'@theme/Tabs\';\nimport TabItem from \'@theme/TabItem\';\n\nA screen represents routes in a navigator. A screen\'s configuration contains the component for the route, options, event listeners, etc.\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\nScreens can be defined under the `screens` key in the navigator configuration:\n\n```js\nconst MyStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\nA `Screen` component is returned from a `createXNavigator` function. After creating the navigator, it can be used as children of the `Navigator` component:\n\n```js\nconst Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\nYou need to provide at least a name and a component to render for each screen.\n\n</TabItem>\n</Tabs>\n\n## Configuration\n\n### Name\n\nThe name to use for the screen.\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\nThe key in the `screens` object is used as the name:\n\n```js\nconst Stack = createNativeStackNavigator({\n  screens: {\n    // highlight-next-line\n    Profile: {\n      screen: ProfileScreen,\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\nIt can be passed in the `name` prop to the `Screen` component:\n\n```jsx\n<Stack.Screen\n  // highlight-next-line\n  name="Profile"\n  component={ProfileScreen}\n/>\n```\n\n</TabItem>\n</Tabs>\n\nThis name is used to navigate to the screen:\n\n```js\nnavigation.navigate(\'Profile\');\n```\n\nIt is also used for the `name` property in the [`route`](route-object.md).\n\nWhile it is supported, we recommend avoiding spaces or special characters in screen names and keeping them simple.\n\n### Options\n\nOptions are used to configure how the screen gets presented in the navigator. It accepts either an object or a function returning an object:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      options: {\n        title: \'Awesome app\',\n      },\n      // highlight-end\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```jsx\n<Stack.Screen\n  name="Profile"\n  component={ProfileScreen}\n  // highlight-start\n  options={{\n    title: \'Awesome app\',\n  }}\n  // highlight-end\n/>\n```\n\n</TabItem>\n</Tabs>\n\nWhen you pass a function, it\'ll receive the [`route`](route-object.md), [`navigation`](navigation-object.md) and [`theme`](themes.md) as arguments:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      options: ({ route, navigation, theme }) => ({\n        title: route.params.userId,\n      }),\n      // highlight-end\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```jsx\n<Stack.Screen\n  name="Profile"\n  component={ProfileScreen}\n  // highlight-start\n  options={({ route, navigation }) => ({\n    title: route.params.userId,\n  })}\n  // highlight-end\n/>\n```\n\n</TabItem>\n</Tabs>\n\nSee [Options for screens](screen-options.md) for more details and examples.\n\n### Initial params\n\nInitial params are used as the default params for the screen. If a screen is used as `initialRouteName`, it\'ll contain the params from `initialParams`. If you navigate to a new screen, the params passed are shallow merged with the initial params.\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst Stack = createNativeStackNavigator({\n  screens: {\n    Details: {\n      screen: DetailsScreen,\n      // highlight-next-line\n      initialParams: { itemId: 42 },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```jsx\n<Stack.Screen\n  name="Details"\n  component={DetailsScreen}\n  // highlight-next-line\n  initialParams={{ itemId: 42 }}\n/>\n```\n\n</TabItem>\n</Tabs>\n\n### ID\n\nA screen can have an ID to identify it. The ID is used differently based on the navigator type.\n\n- In a stack navigator, the ID is treated similarly to the name.\n- In a tab or drawer navigator, the screen will remount if the ID changes.\n\nThis can be done by specifying the `getId` callback. It receives an object with the route params:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst Stack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-next-line\n      getId: ({ params }) => params.userId,\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```jsx\n<Stack.Screen\n  name="Profile"\n  component={ProfileScreen}\n  // highlight-next-line\n  getId={({ params }) => params.userId}\n/>\n```\n\n</TabItem>\n</Tabs>\n\nIn the above example, `params.userId` is used as an ID for the `Profile` screen with `getId`. So if you navigate to `Profile` with the same `userId`, it\'ll update the params of the existing screen instead of pushing a new one. If you navigate to `Profile` with a different `userId`, it\'ll push a new screen onto the stack.\n\n### Component\n\nEach screen must specify a component to render for that route.\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\nIt can be passed under the `screen` property in the screen configuration:\n\n```js\nconst Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      // highlight-next-line\n      screen: ProfileScreen,\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n#### `component`\n\nIt can be passed in the `component` prop to the `Screen` component:\n\n```jsx\n<Stack.Screen\n  name="Profile"\n  // highlight-next-line\n  component={ProfileScreen}\n/>\n```\n\n#### `getComponent`\n\nIt\'s also possible to pass a function in the `getComponent` prop to lazily evaluate the component:\n\n```jsx\n<Stack.Screen\n  name="Profile"\n  // highlight-next-line\n  getComponent={() => require(\'./ProfileScreen\').default}\n/>\n```\n\nYou can use this approach instead of the `component` prop if you want the `ProfileScreen` module to be lazily evaluated when needed. This is especially useful when using [ram bundles](https://reactnative.dev/docs/ram-bundles-inline-requires) to improve initial load.\n\n#### `children`\n\nAnother way is to pass a render callback to return React Element to use for the screen:\n\n```jsx\n<Stack.Screen name="Profile">\n  // highlight-next-line\n  {(props) => <ProfileScreen {...props} />}\n</Stack.Screen>\n```\n\nYou can use this approach instead of the `component` prop if you need to pass additional props. Though we recommend using [React context](https://react.dev/reference/react/useContext) for passing data instead.\n\n:::warning\n\nBy default, React Navigation applies optimizations to screen components to prevent unnecessary renders. Using a render callback removes those optimizations. So if you use a render callback, you\'ll need to ensure that you use [`React.memo`](https://react.dev/reference/react/memo) or [`React.PureComponent`](https://react.dev/reference/react/PureComponent) for your screen components to avoid performance issues.\n\n:::\n\n</TabItem>\n</Tabs>\n\n### Layout\n\nA layout is a wrapper around the screen. It makes it easier to provide things such as an error boundary and suspense fallback for a screen, or wrap the screen with additional UI.\n\nIt takes a function that returns a React element:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      layout: ({ children }) => (\n        <ErrorBoundary>\n          <React.Suspense\n            fallback={\n              <View style={styles.fallback}>\n                <Text style={styles.text}>Loading\u2026</Text>\n              </View>\n            }\n          >\n            {children}\n          </React.Suspense>\n        </ErrorBoundary>\n      ),\n      // highlight-end\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```jsx\n<Stack.Screen\n  name="MyScreen"\n  component={MyScreenComponent}\n  // highlight-start\n  layout={({ children }) => (\n    <ErrorBoundary>\n      <React.Suspense\n        fallback={\n          <View style={styles.fallback}>\n            <Text style={styles.text}>Loading\u2026</Text>\n          </View>\n        }\n      >\n        {children}\n      </React.Suspense>\n    </ErrorBoundary>\n  )}\n  // highlight-end\n/>\n```\n\nTo specify a layout for all multiple screens, you can use `screenLayout` in a [group](group.md#screen-layout) or [navigator](navigator.md#screen-layout).\n\n</TabItem>\n</Tabs>\n\n### Navigation key\n\nA navigation key is an optional key for this screen. This doesn\'t need to be unique. If the key changes, existing screens with this name will be removed (if used in a stack navigator) or reset (if used in a tab or drawer navigator).\n\nThis can be useful when we have some screens that we want to be removed or reset when the condition changes:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-next-line\n      navigationKey: \'user\',\n    },\n  },\n});\n```\n\nFor the static API, we recommend using the [`groups`](group.md#navigation-key) instead of the `navigationKey` for each screen as you can dynamically add or remove groups with the [`if`](static-configuration.md#if) property.\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```jsx\n<Stack.Screen\n  // highlight-next-line\n  navigationKey={isSignedIn ? \'user\' : \'guest\'}\n  name="Profile"\n  component={ProfileScreen}\n/>\n```\n\n</TabItem>\n</Tabs>\n\n### Event listeners\n\nEvent listeners can be used to subscribe to various events emitted for the screen. See [`listeners` prop on `Screen`](navigation-events.md#listeners-prop-on-screen) for more details.\n'},l=void 0,d={},h=[{value:"Configuration",id:"configuration",level:2},{value:"Name",id:"name",level:3},{value:"Options",id:"options",level:3},{value:"Initial params",id:"initial-params",level:3},{value:"ID",id:"id",level:3},{value:"Component",id:"component",level:3},{value:"<code>component</code>",id:"component-1",level:4},{value:"<code>getComponent</code>",id:"getcomponent",level:4},{value:"<code>children</code>",id:"children",level:4},{value:"Layout",id:"layout",level:3},{value:"Navigation key",id:"navigation-key",level:3},{value:"Event listeners",id:"event-listeners",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"A screen represents routes in a navigator. A screen's configuration contains the component for the route, options, event listeners, etc."}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsxs)(o.A,{value:"static",label:"Static",default:!0,children:[(0,r.jsxs)(n.p,{children:["Screens can be defined under the ",(0,r.jsx)(n.code,{children:"screens"})," key in the navigator configuration:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MyStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})})]}),(0,r.jsxs)(o.A,{value:"dynamic",label:"Dynamic",children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"Screen"})," component is returned from a ",(0,r.jsx)(n.code,{children:"createXNavigator"})," function. After creating the navigator, it can be used as children of the ",(0,r.jsx)(n.code,{children:"Navigator"})," component:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})}),(0,r.jsx)(n.p,{children:"You need to provide at least a name and a component to render for each screen."})]})]}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"name",children:"Name"}),"\n",(0,r.jsx)(n.p,{children:"The name to use for the screen."}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsxs)(o.A,{value:"static",label:"Static",default:!0,children:[(0,r.jsxs)(n.p,{children:["The key in the ",(0,r.jsx)(n.code,{children:"screens"})," object is used as the name:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createNativeStackNavigator({\n  screens: {\n    // highlight-next-line\n    Profile: {\n      screen: ProfileScreen,\n    },\n  },\n});\n"})})]}),(0,r.jsxs)(o.A,{value:"dynamic",label:"Dynamic",children:[(0,r.jsxs)(n.p,{children:["It can be passed in the ",(0,r.jsx)(n.code,{children:"name"})," prop to the ",(0,r.jsx)(n.code,{children:"Screen"})," component:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Stack.Screen\n  // highlight-next-line\n  name="Profile"\n  component={ProfileScreen}\n/>\n'})})]})]}),"\n",(0,r.jsx)(n.p,{children:"This name is used to navigate to the screen:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"navigation.navigate('Profile');\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It is also used for the ",(0,r.jsx)(n.code,{children:"name"})," property in the ",(0,r.jsx)(n.a,{href:"/docs/8.x/route-object",children:(0,r.jsx)(n.code,{children:"route"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:"While it is supported, we recommend avoiding spaces or special characters in screen names and keeping them simple."}),"\n",(0,r.jsx)(n.h3,{id:"options",children:"Options"}),"\n",(0,r.jsx)(n.p,{children:"Options are used to configure how the screen gets presented in the navigator. It accepts either an object or a function returning an object:"}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      options: {\n        title: 'Awesome app',\n      },\n      // highlight-end\n    },\n  },\n});\n"})})}),(0,r.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"<Stack.Screen\n  name=\"Profile\"\n  component={ProfileScreen}\n  // highlight-start\n  options={{\n    title: 'Awesome app',\n  }}\n  // highlight-end\n/>\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["When you pass a function, it'll receive the ",(0,r.jsx)(n.a,{href:"/docs/8.x/route-object",children:(0,r.jsx)(n.code,{children:"route"})}),", ",(0,r.jsx)(n.a,{href:"/docs/8.x/navigation-object",children:(0,r.jsx)(n.code,{children:"navigation"})})," and ",(0,r.jsx)(n.a,{href:"/docs/8.x/themes",children:(0,r.jsx)(n.code,{children:"theme"})})," as arguments:"]}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      options: ({ route, navigation, theme }) => ({\n        title: route.params.userId,\n      }),\n      // highlight-end\n    },\n  },\n});\n"})})}),(0,r.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Stack.Screen\n  name="Profile"\n  component={ProfileScreen}\n  // highlight-start\n  options={({ route, navigation }) => ({\n    title: route.params.userId,\n  })}\n  // highlight-end\n/>\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"/docs/8.x/screen-options",children:"Options for screens"})," for more details and examples."]}),"\n",(0,r.jsx)(n.h3,{id:"initial-params",children:"Initial params"}),"\n",(0,r.jsxs)(n.p,{children:["Initial params are used as the default params for the screen. If a screen is used as ",(0,r.jsx)(n.code,{children:"initialRouteName"}),", it'll contain the params from ",(0,r.jsx)(n.code,{children:"initialParams"}),". If you navigate to a new screen, the params passed are shallow merged with the initial params."]}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createNativeStackNavigator({\n  screens: {\n    Details: {\n      screen: DetailsScreen,\n      // highlight-next-line\n      initialParams: { itemId: 42 },\n    },\n  },\n});\n"})})}),(0,r.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Stack.Screen\n  name="Details"\n  component={DetailsScreen}\n  // highlight-next-line\n  initialParams={{ itemId: 42 }}\n/>\n'})})})]}),"\n",(0,r.jsx)(n.h3,{id:"id",children:"ID"}),"\n",(0,r.jsx)(n.p,{children:"A screen can have an ID to identify it. The ID is used differently based on the navigator type."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In a stack navigator, the ID is treated similarly to the name."}),"\n",(0,r.jsx)(n.li,{children:"In a tab or drawer navigator, the screen will remount if the ID changes."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This can be done by specifying the ",(0,r.jsx)(n.code,{children:"getId"})," callback. It receives an object with the route params:"]}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-next-line\n      getId: ({ params }) => params.userId,\n    },\n  },\n});\n"})})}),(0,r.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Stack.Screen\n  name="Profile"\n  component={ProfileScreen}\n  // highlight-next-line\n  getId={({ params }) => params.userId}\n/>\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, ",(0,r.jsx)(n.code,{children:"params.userId"})," is used as an ID for the ",(0,r.jsx)(n.code,{children:"Profile"})," screen with ",(0,r.jsx)(n.code,{children:"getId"}),". So if you navigate to ",(0,r.jsx)(n.code,{children:"Profile"})," with the same ",(0,r.jsx)(n.code,{children:"userId"}),", it'll update the params of the existing screen instead of pushing a new one. If you navigate to ",(0,r.jsx)(n.code,{children:"Profile"})," with a different ",(0,r.jsx)(n.code,{children:"userId"}),", it'll push a new screen onto the stack."]}),"\n",(0,r.jsx)(n.h3,{id:"component",children:"Component"}),"\n",(0,r.jsx)(n.p,{children:"Each screen must specify a component to render for that route."}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsxs)(o.A,{value:"static",label:"Static",default:!0,children:[(0,r.jsxs)(n.p,{children:["It can be passed under the ",(0,r.jsx)(n.code,{children:"screen"})," property in the screen configuration:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      // highlight-next-line\n      screen: ProfileScreen,\n    },\n  },\n});\n"})})]}),(0,r.jsxs)(o.A,{value:"dynamic",label:"Dynamic",children:[(0,r.jsx)(n.h4,{id:"component-1",children:(0,r.jsx)(n.code,{children:"component"})}),(0,r.jsxs)(n.p,{children:["It can be passed in the ",(0,r.jsx)(n.code,{children:"component"})," prop to the ",(0,r.jsx)(n.code,{children:"Screen"})," component:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Stack.Screen\n  name="Profile"\n  // highlight-next-line\n  component={ProfileScreen}\n/>\n'})}),(0,r.jsx)(n.h4,{id:"getcomponent",children:(0,r.jsx)(n.code,{children:"getComponent"})}),(0,r.jsxs)(n.p,{children:["It's also possible to pass a function in the ",(0,r.jsx)(n.code,{children:"getComponent"})," prop to lazily evaluate the component:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"<Stack.Screen\n  name=\"Profile\"\n  // highlight-next-line\n  getComponent={() => require('./ProfileScreen').default}\n/>\n"})}),(0,r.jsxs)(n.p,{children:["You can use this approach instead of the ",(0,r.jsx)(n.code,{children:"component"})," prop if you want the ",(0,r.jsx)(n.code,{children:"ProfileScreen"})," module to be lazily evaluated when needed. This is especially useful when using ",(0,r.jsx)(n.a,{href:"https://reactnative.dev/docs/ram-bundles-inline-requires",children:"ram bundles"})," to improve initial load."]}),(0,r.jsx)(n.h4,{id:"children",children:(0,r.jsx)(n.code,{children:"children"})}),(0,r.jsx)(n.p,{children:"Another way is to pass a render callback to return React Element to use for the screen:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Stack.Screen name="Profile">\n  // highlight-next-line\n  {(props) => <ProfileScreen {...props} />}\n</Stack.Screen>\n'})}),(0,r.jsxs)(n.p,{children:["You can use this approach instead of the ",(0,r.jsx)(n.code,{children:"component"})," prop if you need to pass additional props. Though we recommend using ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/useContext",children:"React context"})," for passing data instead."]}),(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["By default, React Navigation applies optimizations to screen components to prevent unnecessary renders. Using a render callback removes those optimizations. So if you use a render callback, you'll need to ensure that you use ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/memo",children:(0,r.jsx)(n.code,{children:"React.memo"})})," or ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/PureComponent",children:(0,r.jsx)(n.code,{children:"React.PureComponent"})})," for your screen components to avoid performance issues."]})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"layout",children:"Layout"}),"\n",(0,r.jsx)(n.p,{children:"A layout is a wrapper around the screen. It makes it easier to provide things such as an error boundary and suspense fallback for a screen, or wrap the screen with additional UI."}),"\n",(0,r.jsx)(n.p,{children:"It takes a function that returns a React element:"}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      layout: ({ children }) => (\n        <ErrorBoundary>\n          <React.Suspense\n            fallback={\n              <View style={styles.fallback}>\n                <Text style={styles.text}>Loading\u2026</Text>\n              </View>\n            }\n          >\n            {children}\n          </React.Suspense>\n        </ErrorBoundary>\n      ),\n      // highlight-end\n    },\n  },\n});\n"})})}),(0,r.jsxs)(o.A,{value:"dynamic",label:"Dynamic",children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Stack.Screen\n  name="MyScreen"\n  component={MyScreenComponent}\n  // highlight-start\n  layout={({ children }) => (\n    <ErrorBoundary>\n      <React.Suspense\n        fallback={\n          <View style={styles.fallback}>\n            <Text style={styles.text}>Loading\u2026</Text>\n          </View>\n        }\n      >\n        {children}\n      </React.Suspense>\n    </ErrorBoundary>\n  )}\n  // highlight-end\n/>\n'})}),(0,r.jsxs)(n.p,{children:["To specify a layout for all multiple screens, you can use ",(0,r.jsx)(n.code,{children:"screenLayout"})," in a ",(0,r.jsx)(n.a,{href:"/docs/8.x/group#screen-layout",children:"group"})," or ",(0,r.jsx)(n.a,{href:"/docs/8.x/navigator#screen-layout",children:"navigator"}),"."]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"navigation-key",children:"Navigation key"}),"\n",(0,r.jsx)(n.p,{children:"A navigation key is an optional key for this screen. This doesn't need to be unique. If the key changes, existing screens with this name will be removed (if used in a stack navigator) or reset (if used in a tab or drawer navigator)."}),"\n",(0,r.jsx)(n.p,{children:"This can be useful when we have some screens that we want to be removed or reset when the condition changes:"}),"\n",(0,r.jsxs)(s.A,{groupId:"config",queryString:"config",children:[(0,r.jsxs)(o.A,{value:"static",label:"Static",default:!0,children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Stack = createNativeStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-next-line\n      navigationKey: 'user',\n    },\n  },\n});\n"})}),(0,r.jsxs)(n.p,{children:["For the static API, we recommend using the ",(0,r.jsx)(n.a,{href:"/docs/8.x/group#navigation-key",children:(0,r.jsx)(n.code,{children:"groups"})})," instead of the ",(0,r.jsx)(n.code,{children:"navigationKey"})," for each screen as you can dynamically add or remove groups with the ",(0,r.jsx)(n.a,{href:"/docs/8.x/static-configuration#if",children:(0,r.jsx)(n.code,{children:"if"})})," property."]})]}),(0,r.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"<Stack.Screen\n  // highlight-next-line\n  navigationKey={isSignedIn ? 'user' : 'guest'}\n  name=\"Profile\"\n  component={ProfileScreen}\n/>\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"event-listeners",children:"Event listeners"}),"\n",(0,r.jsxs)(n.p,{children:["Event listeners can be used to subscribe to various events emitted for the screen. See ",(0,r.jsxs)(n.a,{href:"/docs/8.x/navigation-events#listeners-prop-on-screen",children:[(0,r.jsx)(n.code,{children:"listeners"})," prop on ",(0,r.jsx)(n.code,{children:"Screen"})]})," for more details."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>s});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var i=t(74848);function s(e){let{children:n,hidden:t,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>I});var a=t(96540),r=t(34164),i=t(17559),s=t(23104),o=t(56347),c=t(205),l=t(57485),d=t(31682),h=t(70679);function u(e){var n,t;return null!=(n=null==(t=a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const r=(0,o.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace(Object.assign({},r.location,{search:n.toString()}))}),[i,r])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=p(e),[s,o]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(n=a.find((e=>e.default)))?n:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[l,d]=g({queryString:t,groupId:r}),[u,f]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[r,i]=(0,h.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),v=(()=>{const e=null!=l?l:u;return m({value:e,tabValues:i})?e:null})();(0,c.A)((()=>{v&&o(v)}),[v]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error("Can't select invalid tab value="+e);o(e),d(e),f(e)}),[d,f,i]),tabValues:i}}var v=t(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function j(e){let{className:n,block:t,selectedValue:a,selectValue:i,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),r=o[t].value;r!==a&&(l(n),i(r))},h=e=>{var n;let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var a;const n=c.indexOf(e.currentTarget)+1;t=null!=(a=c[n])?a:c[0];break}case"ArrowLeft":{var r;const n=c.indexOf(e.currentTarget)-1;t=null!=(r=c[n])?r:c[c.length-1];break}}null==(n=t)||n.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,b.jsx)("li",Object.assign({role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{c.push(e)},onKeyDown:h,onClick:d},i,{className:(0,r.A)("tabs__item",x.tabItem,null==i?void 0:i.className,{"tabs__item--active":a===n}),children:null!=t?t:n}),n)}))})}function S(e){let{lazy:n,children:t,selectedValue:i}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function y(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,r.A)(i.G.tabs.container,"tabs-container",x.tabList),children:[(0,b.jsx)(j,Object.assign({},n,e)),(0,b.jsx)(S,Object.assign({},n,e))]})}function I(e){const n=(0,v.A)();return(0,b.jsx)(y,Object.assign({},e,{children:u(e.children)}),String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(96540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);