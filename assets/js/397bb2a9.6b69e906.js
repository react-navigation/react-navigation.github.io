"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[83294],{35682:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>g,frontMatter:()=>c,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"navigator","title":"Navigator","description":"A navigator is responsible for managing and rendering a set of screens. It can be created using the createXNavigator functions, e.g. createStackNavigator, createNativeStackNavigator, createBottomTabNavigator, createMaterialTopTabNavigator, createDrawerNavigator etc.:","source":"@site/versioned_docs/version-8.x/navigator.md","sourceDirName":".","slug":"/navigator","permalink":"/docs/8.x/navigator","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-8.x/navigator.md","tags":[],"version":"8.x","frontMatter":{"id":"navigator","title":"Navigator","sidebar_label":"Navigator"},"sidebar":"docs","previous":{"title":"ServerContainer","permalink":"/docs/8.x/server-container"},"next":{"title":"Group","permalink":"/docs/8.x/group"}}');var r=t(74848),i=t(28453),o=t(11470),s=t(19365);const c={id:"navigator",title:"Navigator",sidebar_label:"Navigator",rawMarkdown:'---\nid: navigator\ntitle: Navigator\nsidebar_label: Navigator\n---\n\nimport Tabs from \'@theme/Tabs\';\nimport TabItem from \'@theme/TabItem\';\n\nA navigator is responsible for managing and rendering a set of screens. It can be created using the `createXNavigator` functions, e.g. [`createStackNavigator`](stack-navigator.md), [`createNativeStackNavigator`](native-stack-navigator.md), [`createBottomTabNavigator`](bottom-tab-navigator.md), [`createMaterialTopTabNavigator`](material-top-tab-navigator.md), [`createDrawerNavigator`](drawer-navigator.md) etc.:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst MyStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nconst Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\nIn addition to the built-in navigators, it\'s also possible to build your custom navigators or use third-party navigators. See [custom navigators](custom-navigators.md) for more details.\n\n## Configuration\n\nDifferent navigators accept different configuration options. You can find the list of options for each navigator in their respective documentation.\n\nThere is a set of common configurations that are shared across all navigators:\n\n### Initial route name\n\nThe name of the route to render on the first load of the navigator.\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst MyStack = createNativeStackNavigator({\n  // highlight-next-line\n  initialRouteName: \'Home\',\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nconst Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-next-line\n      initialRouteName="Home"\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Layout\n\nA layout is a wrapper around the navigator. It can be useful for augmenting the navigators with additional UI with a wrapper.\n\nThe difference from adding a wrapper around the navigator manually is that the code in a layout callback has access to the navigator\'s state, options etc.\n\nIt takes a function that returns a React element:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst MyStack = createNativeStackNavigator({\n  // highlight-start\n  layout: ({ children, state, descriptors, navigation }) => (\n    <View style={styles.container}>\n      <Breadcrumbs\n        state={state}\n        descriptors={descriptors}\n        navigation={navigation}\n      />\n      {children}\n    </View>\n  ),\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nconst Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      layout={({ children, state, descriptors, navigation }) => (\n        <View style={styles.container}>\n          <Breadcrumbs\n            state={state}\n            descriptors={descriptors}\n            navigation={navigation}\n          />\n          {children}\n        </View>\n      )}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Screen options\n\nDefault options to use for all the screens in the navigator. It accepts either an object or a function returning an object:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst MyStack = createNativeStackNavigator({\n  // highlight-start\n  screenOptions: {\n    headerShown: false,\n  },\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nconst Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      screenOptions={{ headerShown: false }}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\nSee [Options for screens](screen-options.md) for more details and examples.\n\n### Screen listeners\n\nEvent listeners can be used to subscribe to various events emitted for the screen. See [`screenListeners` prop on the navigator](navigation-events.md#screenlisteners-prop-on-the-navigator) for more details.\n\n### Screen layout\n\nA screen layout is a wrapper around each screen in the navigator. It makes it easier to provide things such as an error boundary and suspense fallback for all screens in the navigator, or wrap each screen with additional UI.\n\nIt takes a function that returns a React element:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst MyStack = createNativeStackNavigator({\n  // highlight-start\n  screenLayout: ({ children }) => (\n    <ErrorBoundary>\n      <React.Suspense\n        fallback={\n          <View style={styles.fallback}>\n            <Text style={styles.text}>Loading\u2026</Text>\n          </View>\n        }\n      >\n        {children}\n      </React.Suspense>\n    </ErrorBoundary>\n  ),\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nconst Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      screenLayout={({ children }) => (\n        <ErrorBoundary>\n          <React.Suspense\n            fallback={\n              <View style={styles.fallback}>\n                <Text style={styles.text}>Loading\u2026</Text>\n              </View>\n            }\n          >\n            {children}\n          </React.Suspense>\n        </ErrorBoundary>\n      )}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Router\n\nRouters can be customized with the `router` prop on navigator to override how navigation actions are handled.\n\nIt takes a function that receives the original router and returns an object with overrides:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst MyStack = createNativeStackNavigator({\n  // highlight-start\n  router: (original) => ({\n    getStateForAction(state, action) {\n      if (action.type === \'SOME_ACTION\') {\n        // Custom logic\n      }\n\n      // Fallback to original behavior\n      return original.getStateForAction(state, action);\n    },\n  }),\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\nconst Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      router={(original) => ({\n        getStateForAction(state, action) {\n          if (action.type === \'SOME_ACTION\') {\n            // Custom logic\n          }\n\n          // Fallback to original behavior\n          return original.getStateForAction(state, action);\n        },\n      })}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\nThe function passed to `router` **must be a pure function and cannot reference outside dynamic variables**.\n\nThe overrides object is shallow merged with the original router. So you don\'t need to specify all properties of the router, only the ones you want to override.\n\nSee [custom routers](custom-routers.md) for more details on routers.\n\n### Route names change behavior\n\n:::warning\n\nThis API is experimental and may change in a minor release.\n\n:::\n\nWhen the list of available routes in a navigator changes dynamically, e.g. based on conditional rendering, looping over data from an API etc., the navigator needs to update the [navigation state](navigation-state.md) according to the new list of routes.\n\nBy default, it works as follows:\n\n- Any routes not present in the new available list of routes are removed from the navigation state\n- If the currently focused route is still present in the new available list of routes, it remains focused.\n- If the currently focused route has been removed, but the navigation state has other routes that are present in the new available list, the first route in from the list of rendered routes becomes focused.\n- If none of the routes in the navigation state are present in the new available list of routes, one of the following things can happen based on the `routeNamesChangeBehavior` prop:\n  - `\'firstMatch\'` - The first route defined in the new list of routes becomes focused. This is the default behavior based on [`getStateForRouteNamesChange`](custom-routers.md) in the router.\n  - `\'lastUnhandled\'` - The last state that was unhandled due to conditional rendering is restored.\n\nExample cases where state might have been unhandled:\n\n- Opened a deep link to a screen, but a login screen was shown.\n- Navigated to a screen containing a navigator, but a different screen was shown.\n- Reset the navigator to a state with different routes not matching the available list of routes.\n\nIn these cases, specifying `\'lastUnhandled\'` will reuse the unhandled state if present. If there\'s no unhandled state, it will fallback to `\'firstMatch\'` behavior.\n\nCaveats:\n\n- Direct navigation is only handled for `NAVIGATE` actions.\n- Unhandled state is restored only if the current state becomes invalid, i.e. it doesn\'t contain any currently defined screens.\n\nExample usage:\n\n<Tabs groupId="config" queryString="config">\n<TabItem value="static" label="Static" default>\n\n```js\nconst RootStack = createNativeStackNavigator({\n  // highlight-next-line\n  routeNamesChangeBehavior: \'lastUnhandled\',\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: \'Sign in\',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value="dynamic" label="Dynamic">\n\n```js\n<Stack.Navigator\n  // highlight-next-line\n  routeNamesChangeBehavior="lastUnhandled"\n>\n  {isSignedIn ? (\n    <Stack.Screen name="Home" component={HomeScreen} />\n  ) : (\n    <Stack.Screen name="SignIn" component={SignInScreen} />\n  )}\n</Stack.Navigator>\n```\n\n</TabItem>\n</Tabs>\n\nThe most common use case for this is to [show the correct screen based on authentication based on deep link](auth-flow.md#handling-deep-links-after-auth).\n'},l=void 0,d={},h=[{value:"Configuration",id:"configuration",level:2},{value:"Initial route name",id:"initial-route-name",level:3},{value:"Layout",id:"layout",level:3},{value:"Screen options",id:"screen-options",level:3},{value:"Screen listeners",id:"screen-listeners",level:3},{value:"Screen layout",id:"screen-layout",level:3},{value:"Router",id:"router",level:3},{value:"Route names change behavior",id:"route-names-change-behavior",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A navigator is responsible for managing and rendering a set of screens. It can be created using the ",(0,r.jsx)(n.code,{children:"createXNavigator"})," functions, e.g. ",(0,r.jsx)(n.a,{href:"/docs/8.x/stack-navigator",children:(0,r.jsx)(n.code,{children:"createStackNavigator"})}),", ",(0,r.jsx)(n.a,{href:"/docs/8.x/native-stack-navigator",children:(0,r.jsx)(n.code,{children:"createNativeStackNavigator"})}),", ",(0,r.jsx)(n.a,{href:"/docs/8.x/bottom-tab-navigator",children:(0,r.jsx)(n.code,{children:"createBottomTabNavigator"})}),", ",(0,r.jsx)(n.a,{href:"/docs/8.x/material-top-tab-navigator",children:(0,r.jsx)(n.code,{children:"createMaterialTopTabNavigator"})}),", ",(0,r.jsx)(n.a,{href:"/docs/8.x/drawer-navigator",children:(0,r.jsx)(n.code,{children:"createDrawerNavigator"})})," etc.:"]}),"\n",(0,r.jsxs)(o.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MyStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})})}),(0,r.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["In addition to the built-in navigators, it's also possible to build your custom navigators or use third-party navigators. See ",(0,r.jsx)(n.a,{href:"/docs/8.x/custom-navigators",children:"custom navigators"})," for more details."]}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Different navigators accept different configuration options. You can find the list of options for each navigator in their respective documentation."}),"\n",(0,r.jsx)(n.p,{children:"There is a set of common configurations that are shared across all navigators:"}),"\n",(0,r.jsx)(n.h3,{id:"initial-route-name",children:"Initial route name"}),"\n",(0,r.jsx)(n.p,{children:"The name of the route to render on the first load of the navigator."}),"\n",(0,r.jsxs)(o.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MyStack = createNativeStackNavigator({\n  // highlight-next-line\n  initialRouteName: 'Home',\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})})}),(0,r.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-next-line\n      initialRouteName="Home"\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})})})]}),"\n",(0,r.jsx)(n.h3,{id:"layout",children:"Layout"}),"\n",(0,r.jsx)(n.p,{children:"A layout is a wrapper around the navigator. It can be useful for augmenting the navigators with additional UI with a wrapper."}),"\n",(0,r.jsx)(n.p,{children:"The difference from adding a wrapper around the navigator manually is that the code in a layout callback has access to the navigator's state, options etc."}),"\n",(0,r.jsx)(n.p,{children:"It takes a function that returns a React element:"}),"\n",(0,r.jsxs)(o.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MyStack = createNativeStackNavigator({\n  // highlight-start\n  layout: ({ children, state, descriptors, navigation }) => (\n    <View style={styles.container}>\n      <Breadcrumbs\n        state={state}\n        descriptors={descriptors}\n        navigation={navigation}\n      />\n      {children}\n    </View>\n  ),\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})})}),(0,r.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      layout={({ children, state, descriptors, navigation }) => (\n        <View style={styles.container}>\n          <Breadcrumbs\n            state={state}\n            descriptors={descriptors}\n            navigation={navigation}\n          />\n          {children}\n        </View>\n      )}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})})})]}),"\n",(0,r.jsx)(n.h3,{id:"screen-options",children:"Screen options"}),"\n",(0,r.jsx)(n.p,{children:"Default options to use for all the screens in the navigator. It accepts either an object or a function returning an object:"}),"\n",(0,r.jsxs)(o.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MyStack = createNativeStackNavigator({\n  // highlight-start\n  screenOptions: {\n    headerShown: false,\n  },\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})})}),(0,r.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      screenOptions={{ headerShown: false }}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"/docs/8.x/screen-options",children:"Options for screens"})," for more details and examples."]}),"\n",(0,r.jsx)(n.h3,{id:"screen-listeners",children:"Screen listeners"}),"\n",(0,r.jsxs)(n.p,{children:["Event listeners can be used to subscribe to various events emitted for the screen. See ",(0,r.jsxs)(n.a,{href:"/docs/8.x/navigation-events#screenlisteners-prop-on-the-navigator",children:[(0,r.jsx)(n.code,{children:"screenListeners"})," prop on the navigator"]})," for more details."]}),"\n",(0,r.jsx)(n.h3,{id:"screen-layout",children:"Screen layout"}),"\n",(0,r.jsx)(n.p,{children:"A screen layout is a wrapper around each screen in the navigator. It makes it easier to provide things such as an error boundary and suspense fallback for all screens in the navigator, or wrap each screen with additional UI."}),"\n",(0,r.jsx)(n.p,{children:"It takes a function that returns a React element:"}),"\n",(0,r.jsxs)(o.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MyStack = createNativeStackNavigator({\n  // highlight-start\n  screenLayout: ({ children }) => (\n    <ErrorBoundary>\n      <React.Suspense\n        fallback={\n          <View style={styles.fallback}>\n            <Text style={styles.text}>Loading\u2026</Text>\n          </View>\n        }\n      >\n        {children}\n      </React.Suspense>\n    </ErrorBoundary>\n  ),\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})})}),(0,r.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      screenLayout={({ children }) => (\n        <ErrorBoundary>\n          <React.Suspense\n            fallback={\n              <View style={styles.fallback}>\n                <Text style={styles.text}>Loading\u2026</Text>\n              </View>\n            }\n          >\n            {children}\n          </React.Suspense>\n        </ErrorBoundary>\n      )}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})})})]}),"\n",(0,r.jsx)(n.h3,{id:"router",children:"Router"}),"\n",(0,r.jsxs)(n.p,{children:["Routers can be customized with the ",(0,r.jsx)(n.code,{children:"router"})," prop on navigator to override how navigation actions are handled."]}),"\n",(0,r.jsx)(n.p,{children:"It takes a function that receives the original router and returns an object with overrides:"}),"\n",(0,r.jsxs)(o.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MyStack = createNativeStackNavigator({\n  // highlight-start\n  router: (original) => ({\n    getStateForAction(state, action) {\n      if (action.type === 'SOME_ACTION') {\n        // Custom logic\n      }\n\n      // Fallback to original behavior\n      return original.getStateForAction(state, action);\n    },\n  }),\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})})}),(0,r.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      router={(original) => ({\n        getStateForAction(state, action) {\n          if (action.type === \'SOME_ACTION\') {\n            // Custom logic\n          }\n\n          // Fallback to original behavior\n          return original.getStateForAction(state, action);\n        },\n      })}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["The function passed to ",(0,r.jsx)(n.code,{children:"router"})," ",(0,r.jsx)(n.strong,{children:"must be a pure function and cannot reference outside dynamic variables"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The overrides object is shallow merged with the original router. So you don't need to specify all properties of the router, only the ones you want to override."}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"/docs/8.x/custom-routers",children:"custom routers"})," for more details on routers."]}),"\n",(0,r.jsx)(n.h3,{id:"route-names-change-behavior",children:"Route names change behavior"}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"This API is experimental and may change in a minor release."})}),"\n",(0,r.jsxs)(n.p,{children:["When the list of available routes in a navigator changes dynamically, e.g. based on conditional rendering, looping over data from an API etc., the navigator needs to update the ",(0,r.jsx)(n.a,{href:"/docs/8.x/navigation-state",children:"navigation state"})," according to the new list of routes."]}),"\n",(0,r.jsx)(n.p,{children:"By default, it works as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Any routes not present in the new available list of routes are removed from the navigation state"}),"\n",(0,r.jsx)(n.li,{children:"If the currently focused route is still present in the new available list of routes, it remains focused."}),"\n",(0,r.jsx)(n.li,{children:"If the currently focused route has been removed, but the navigation state has other routes that are present in the new available list, the first route in from the list of rendered routes becomes focused."}),"\n",(0,r.jsxs)(n.li,{children:["If none of the routes in the navigation state are present in the new available list of routes, one of the following things can happen based on the ",(0,r.jsx)(n.code,{children:"routeNamesChangeBehavior"})," prop:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'firstMatch'"})," - The first route defined in the new list of routes becomes focused. This is the default behavior based on ",(0,r.jsx)(n.a,{href:"/docs/8.x/custom-routers",children:(0,r.jsx)(n.code,{children:"getStateForRouteNamesChange"})})," in the router."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"'lastUnhandled'"})," - The last state that was unhandled due to conditional rendering is restored."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example cases where state might have been unhandled:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Opened a deep link to a screen, but a login screen was shown."}),"\n",(0,r.jsx)(n.li,{children:"Navigated to a screen containing a navigator, but a different screen was shown."}),"\n",(0,r.jsx)(n.li,{children:"Reset the navigator to a state with different routes not matching the available list of routes."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In these cases, specifying ",(0,r.jsx)(n.code,{children:"'lastUnhandled'"})," will reuse the unhandled state if present. If there's no unhandled state, it will fallback to ",(0,r.jsx)(n.code,{children:"'firstMatch'"})," behavior."]}),"\n",(0,r.jsx)(n.p,{children:"Caveats:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Direct navigation is only handled for ",(0,r.jsx)(n.code,{children:"NAVIGATE"})," actions."]}),"\n",(0,r.jsx)(n.li,{children:"Unhandled state is restored only if the current state becomes invalid, i.e. it doesn't contain any currently defined screens."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example usage:"}),"\n",(0,r.jsxs)(o.A,{groupId:"config",queryString:"config",children:[(0,r.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const RootStack = createNativeStackNavigator({\n  // highlight-next-line\n  routeNamesChangeBehavior: 'lastUnhandled',\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: 'Sign in',\n      },\n    },\n  },\n});\n"})})}),(0,r.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Stack.Navigator\n  // highlight-next-line\n  routeNamesChangeBehavior="lastUnhandled"\n>\n  {isSignedIn ? (\n    <Stack.Screen name="Home" component={HomeScreen} />\n  ) : (\n    <Stack.Screen name="SignIn" component={SignInScreen} />\n  )}\n</Stack.Navigator>\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["The most common use case for this is to ",(0,r.jsx)(n.a,{href:"/docs/8.x/auth-flow#handling-deep-links-after-auth",children:"show the correct screen based on authentication based on deep link"}),"."]})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>o});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var i=t(74848);function o(e){let{children:n,hidden:t,className:o}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,o),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>j});var a=t(96540),r=t(34164),i=t(17559),o=t(23104),s=t(56347),c=t(205),l=t(57485),d=t(31682),h=t(70679);function u(e){var n,t;return null!=(n=null==(t=a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function g(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace(Object.assign({},r.location,{search:n.toString()}))}),[i,r])]}function v(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=g(e),[o,s]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(n=a.find((e=>e.default)))?n:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[l,d]=f({queryString:t,groupId:r}),[u,v]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[r,i]=(0,h.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),S=(()=>{const e=null!=l?l:u;return m({value:e,tabValues:i})?e:null})();(0,c.A)((()=>{S&&s(S)}),[S]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error("Can't select invalid tab value="+e);s(e),d(e),v(e)}),[d,v,i]),tabValues:i}}var S=t(92303);const p={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function x(e){let{className:n,block:t,selectedValue:a,selectValue:i,tabValues:s}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),r=s[t].value;r!==a&&(l(n),i(r))},h=e=>{var n;let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var a;const n=c.indexOf(e.currentTarget)+1;t=null!=(a=c[n])?a:c[0];break}case"ArrowLeft":{var r;const n=c.indexOf(e.currentTarget)-1;t=null!=(r=c[n])?r:c[c.length-1];break}}null==(n=t)||n.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:s.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,b.jsx)("li",Object.assign({role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{c.push(e)},onKeyDown:h,onClick:d},i,{className:(0,r.A)("tabs__item",p.tabItem,null==i?void 0:i.className,{"tabs__item--active":a===n}),children:null!=t?t:n}),n)}))})}function y(e){let{lazy:n,children:t,selectedValue:i}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function k(e){const n=v(e);return(0,b.jsxs)("div",{className:(0,r.A)(i.G.tabs.container,"tabs-container",p.tabList),children:[(0,b.jsx)(x,Object.assign({},n,e)),(0,b.jsx)(y,Object.assign({},n,e))]})}function j(e){const n=(0,S.A)();return(0,b.jsx)(k,Object.assign({},e,{children:u(e.children)}),String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);