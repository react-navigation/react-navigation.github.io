"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[49999],{88758:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"navigation-state","title":"Navigation state reference","description":"The navigation state is the state where React Navigation stores the navigation structure and history of the app. It\'s useful to know about the structure of the navigation state if you need to do advanced operations such as resetting the state, providing a custom initial state etc.","source":"@site/versioned_docs/version-5.x/navigation-state.md","sourceDirName":".","slug":"/navigation-state","permalink":"/docs/5.x/navigation-state","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-5.x/navigation-state.md","tags":[],"version":"5.x","frontMatter":{"id":"navigation-state","title":"Navigation state reference","sidebar_label":"Navigation state"},"sidebar":"docs","previous":{"title":"Navigation events","permalink":"/docs/5.x/navigation-events"},"next":{"title":"Link","permalink":"/docs/5.x/link"}}');var i=n(74848),s=n(28453);const o={id:"navigation-state",title:"Navigation state reference",sidebar_label:"Navigation state",rawMarkdown:"---\nid: navigation-state\ntitle: Navigation state reference\nsidebar_label: Navigation state\n---\n\nThe navigation state is the state where React Navigation stores the navigation structure and history of the app. It's useful to know about the structure of the navigation state if you need to do advanced operations such as [resetting the state](navigation-actions.md#reset), [providing a custom initial state](navigation-container.md#initialstate) etc.\n\nIt's a JavaScript object which looks like this:\n\n```js\nconst state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    { key: 'home-1', name: 'Home', params: { sortBy: 'latest' } },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n  stale: false,\n};\n```\n\nThere are few properties present in every navigation state object:\n\n- `type` - Type of the navigator that the state belongs to, e.g. `stack`, `tab`, `drawer`.\n- `key` - Unique key to identify the navigator.\n- `routeNames` - Name of the screens defined in the navigator. This is an unique array containing strings for each screen.\n- `routes` - List of route objects (screens) which are rendered in the navigator. It also represents the history in a stack navigator. There should be at least one item present in this array.\n- `index` - Index of the focused route object in the `routes` array.\n- `history` - A list of visited items. This is an optional property and not present in all navigators. For example, it's only present in tab and drawer navigators in the core. The shape of the items in the `history` array can vary depending on the navigator. There should be at least one item present in this array.\n- `stale` - A navigation state is assumed to be stale unless the `stale` property is explicitly set to `false`. This means that the state object needs to be [\"rehydrated\"](#partial-state-objects).\n\nEach route object in a `routes` array may contain the following properties:\n\n- `key` - Unique key of the screen. Created automatically or added while navigating to this screen.\n- `name` - Name of the screen. Defined in navigator component hierarchy.\n- `params` - An optional object containing params which is defined while navigating e.g. `navigate('Home', { sortBy: 'latest' })`.\n- `state` - An optional object containing the navigation state of a child navigator nested inside this screen.\n\nFor example, a stack navigator containing a tab navigator nested inside it's home screen may have a navigation state object like this:\n\n```js\nconst state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    {\n      key: 'home-1',\n      name: 'Home',\n      state: {\n        key: 'tab-1',\n        routeNames: ['Feed', 'Library', 'Favorites'],\n        routes: [\n          { key: 'feed-1', name: 'Feed', params: { sortBy: 'latest' } },\n          { key: 'library-1', name: 'Library' },\n          { key: 'favorites-1', name: 'Favorites' },\n        ],\n        index: 0,\n      },\n    },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n};\n```\n\nIt's important to note that even if there's a nested navigator, the `state` property on the `route` object is not added until a navigation happens, hence it's not guaranteed to exist.\n\n## Partial state objects\n\nEarlier there was a mention of `stale` property in the navigation state. A stale navigation state means that the state object needs to be rehydrated or fixed or fixed up, such as adding missing keys, removing invalid screens etc. before being used. As a user, you don't need to worry about it, React Navigation will fix up any issues in a state object automatically unless `stale` is set to `false`. If you're writing a [custom router](custom-routers.md), the `getRehydratedState` method let's you write custom rehydration logic to fix up state objects.\n\nThis also applies to the `index` property: `index` should be the last route in a stack, and if a different value was specified, React Navigation fixes it. For example, if you wanted to reset your app's navigation state to have it display the `Profile` route, and have the `Home` route displayed upon going back, and did the below,\n\n```js\nnavigation.reset({\n  index: 0,\n  routes: [{ name: 'Home' }, { name: 'Profile' }],\n});\n```\n\nReact Navigation would correct `index` to 1, and display the route and perform navigation as intended.\n\nThis feature comes handy when doing operations such as [reset](navigation-actions.md#reset), [providing a initial state](navigation-container.md#initialstate) etc., as you can safely omit many properties from the navigation state object and relying on React Navigation to add those properties for you, making your code simpler. For example, you can only provide a `routes` array without any keys and React Navigation will automatically add everything that's needed to make it work:\n\n```js\nconst state = {\n  routes: [{ name: 'Home' }, { name: 'Profile' }],\n};\n```\n\nAfter rehydration, it'll look something like this:\n\n```js\nconst state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    { key: 'home-1', name: 'Home' },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n  stale: false,\n};\n```\n\nHere, React Navigation filled in the missing bits such as keys, route names, index etc.\n\nIt's also possible to provide invalid data such as non-existent screens and it'll be fixed automatically. While it's not recommended to write code with invalid state objects, it can be super useful if you do things like [state persistence](state-persistence.md), where the configured screens might have changed after an update, which could cause problems if React Navigation didn't fix the state object automatically.\n\n> If you want React Navigation to fix invalid state, you need to make sure that you don't have `stale: false` in the state object. State objects with `stale: false` are assumed to be valid state objects and React Navigation won't attempt to fix them.\n\nWhen you're providing a state object in [`initialState`](navigation-container.md#initialstate), React Navigation will always assume that it's a stale state object, which makes sure that things like state persistence work smoothly without extra manipulation of the state object.\n"},r=void 0,c={},d=[{value:"Partial state objects",id:"partial-state-objects",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["The navigation state is the state where React Navigation stores the navigation structure and history of the app. It's useful to know about the structure of the navigation state if you need to do advanced operations such as ",(0,i.jsx)(t.a,{href:"/docs/5.x/navigation-actions#reset",children:"resetting the state"}),", ",(0,i.jsx)(t.a,{href:"/docs/5.x/navigation-container#initialstate",children:"providing a custom initial state"})," etc."]}),"\n",(0,i.jsx)(t.p,{children:"It's a JavaScript object which looks like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    { key: 'home-1', name: 'Home', params: { sortBy: 'latest' } },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n  stale: false,\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"There are few properties present in every navigation state object:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"type"})," - Type of the navigator that the state belongs to, e.g. ",(0,i.jsx)(t.code,{children:"stack"}),", ",(0,i.jsx)(t.code,{children:"tab"}),", ",(0,i.jsx)(t.code,{children:"drawer"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"key"})," - Unique key to identify the navigator."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"routeNames"})," - Name of the screens defined in the navigator. This is an unique array containing strings for each screen."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"routes"})," - List of route objects (screens) which are rendered in the navigator. It also represents the history in a stack navigator. There should be at least one item present in this array."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"index"})," - Index of the focused route object in the ",(0,i.jsx)(t.code,{children:"routes"})," array."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"history"})," - A list of visited items. This is an optional property and not present in all navigators. For example, it's only present in tab and drawer navigators in the core. The shape of the items in the ",(0,i.jsx)(t.code,{children:"history"})," array can vary depending on the navigator. There should be at least one item present in this array."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"stale"})," - A navigation state is assumed to be stale unless the ",(0,i.jsx)(t.code,{children:"stale"})," property is explicitly set to ",(0,i.jsx)(t.code,{children:"false"}),". This means that the state object needs to be ",(0,i.jsx)(t.a,{href:"#partial-state-objects",children:'"rehydrated"'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Each route object in a ",(0,i.jsx)(t.code,{children:"routes"})," array may contain the following properties:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"key"})," - Unique key of the screen. Created automatically or added while navigating to this screen."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"name"})," - Name of the screen. Defined in navigator component hierarchy."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"params"})," - An optional object containing params which is defined while navigating e.g. ",(0,i.jsx)(t.code,{children:"navigate('Home', { sortBy: 'latest' })"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"state"})," - An optional object containing the navigation state of a child navigator nested inside this screen."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"For example, a stack navigator containing a tab navigator nested inside it's home screen may have a navigation state object like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    {\n      key: 'home-1',\n      name: 'Home',\n      state: {\n        key: 'tab-1',\n        routeNames: ['Feed', 'Library', 'Favorites'],\n        routes: [\n          { key: 'feed-1', name: 'Feed', params: { sortBy: 'latest' } },\n          { key: 'library-1', name: 'Library' },\n          { key: 'favorites-1', name: 'Favorites' },\n        ],\n        index: 0,\n      },\n    },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It's important to note that even if there's a nested navigator, the ",(0,i.jsx)(t.code,{children:"state"})," property on the ",(0,i.jsx)(t.code,{children:"route"})," object is not added until a navigation happens, hence it's not guaranteed to exist."]}),"\n",(0,i.jsx)(t.h2,{id:"partial-state-objects",children:"Partial state objects"}),"\n",(0,i.jsxs)(t.p,{children:["Earlier there was a mention of ",(0,i.jsx)(t.code,{children:"stale"})," property in the navigation state. A stale navigation state means that the state object needs to be rehydrated or fixed or fixed up, such as adding missing keys, removing invalid screens etc. before being used. As a user, you don't need to worry about it, React Navigation will fix up any issues in a state object automatically unless ",(0,i.jsx)(t.code,{children:"stale"})," is set to ",(0,i.jsx)(t.code,{children:"false"}),". If you're writing a ",(0,i.jsx)(t.a,{href:"/docs/5.x/custom-routers",children:"custom router"}),", the ",(0,i.jsx)(t.code,{children:"getRehydratedState"})," method let's you write custom rehydration logic to fix up state objects."]}),"\n",(0,i.jsxs)(t.p,{children:["This also applies to the ",(0,i.jsx)(t.code,{children:"index"})," property: ",(0,i.jsx)(t.code,{children:"index"})," should be the last route in a stack, and if a different value was specified, React Navigation fixes it. For example, if you wanted to reset your app's navigation state to have it display the ",(0,i.jsx)(t.code,{children:"Profile"})," route, and have the ",(0,i.jsx)(t.code,{children:"Home"})," route displayed upon going back, and did the below,"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"navigation.reset({\n  index: 0,\n  routes: [{ name: 'Home' }, { name: 'Profile' }],\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["React Navigation would correct ",(0,i.jsx)(t.code,{children:"index"})," to 1, and display the route and perform navigation as intended."]}),"\n",(0,i.jsxs)(t.p,{children:["This feature comes handy when doing operations such as ",(0,i.jsx)(t.a,{href:"/docs/5.x/navigation-actions#reset",children:"reset"}),", ",(0,i.jsx)(t.a,{href:"/docs/5.x/navigation-container#initialstate",children:"providing a initial state"})," etc., as you can safely omit many properties from the navigation state object and relying on React Navigation to add those properties for you, making your code simpler. For example, you can only provide a ",(0,i.jsx)(t.code,{children:"routes"})," array without any keys and React Navigation will automatically add everything that's needed to make it work:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  routes: [{ name: 'Home' }, { name: 'Profile' }],\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"After rehydration, it'll look something like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    { key: 'home-1', name: 'Home' },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n  stale: false,\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here, React Navigation filled in the missing bits such as keys, route names, index etc."}),"\n",(0,i.jsxs)(t.p,{children:["It's also possible to provide invalid data such as non-existent screens and it'll be fixed automatically. While it's not recommended to write code with invalid state objects, it can be super useful if you do things like ",(0,i.jsx)(t.a,{href:"/docs/5.x/state-persistence",children:"state persistence"}),", where the configured screens might have changed after an update, which could cause problems if React Navigation didn't fix the state object automatically."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["If you want React Navigation to fix invalid state, you need to make sure that you don't have ",(0,i.jsx)(t.code,{children:"stale: false"})," in the state object. State objects with ",(0,i.jsx)(t.code,{children:"stale: false"})," are assumed to be valid state objects and React Navigation won't attempt to fix them."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["When you're providing a state object in ",(0,i.jsx)(t.a,{href:"/docs/5.x/navigation-container#initialstate",children:(0,i.jsx)(t.code,{children:"initialState"})}),", React Navigation will always assume that it's a stale state object, which makes sure that things like state persistence work smoothly without extra manipulation of the state object."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(96540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);