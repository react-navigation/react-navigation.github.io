"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[81785],{76040:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>g,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"combine-static-with-dynamic","title":"Combining static and dynamic APIs","description":"While the static API has many advantages, it doesn\'t fit use cases where the navigation configuration needs to be dynamic. So React Navigation supports interop between the static and dynamic APIs.","source":"@site/versioned_docs/version-7.x/combine-static-with-dynamic.md","sourceDirName":".","slug":"/combine-static-with-dynamic","permalink":"/docs/combine-static-with-dynamic","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/combine-static-with-dynamic.md","tags":[],"version":"7.x","frontMatter":{"id":"combine-static-with-dynamic","title":"Combining static and dynamic APIs","sidebar_label":"Static and dynamic APIs"},"sidebar":"docs","previous":{"title":"Screen tracking","permalink":"/docs/screen-tracking"},"next":{"title":"Troubleshooting","permalink":"/docs/troubleshooting"}}');var i=t(74848),o=t(28453);const r={id:"combine-static-with-dynamic",title:"Combining static and dynamic APIs",sidebar_label:"Static and dynamic APIs",rawMarkdown:"---\nid: combine-static-with-dynamic\ntitle: Combining static and dynamic APIs\nsidebar_label: Static and dynamic APIs\n---\n\nWhile the static API has many advantages, it doesn't fit use cases where the navigation configuration needs to be dynamic. So React Navigation supports interop between the static and dynamic APIs.\n\nKeep in mind that the features provided by the static API such as automatic linking configuration and automatic TypeScript types need the whole configuration to be static. If part of the configuration is dynamic, you'll need to handle those parts manually.\n\nThere are 2 ways you may want to combine the static and dynamic APIs:\n\n## Static root navigator, dynamic nested navigator\n\nThis is useful if you want to keep your configuration static, but need to use a dynamic configuration for a specific navigator.\n\nLet's consider the following example:\n\n- You have a root stack navigator that contains a tab navigator in a screen.\n- The tab navigator is defined using the dynamic API.\n\nOur static configuration would look like this:\n\n```js\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n    Feed: {\n      screen: FeedScreen,\n      linking: {\n        path: 'feed',\n      },\n    },\n  },\n});\n```\n\nHere, `FeedScreen` is a component that renders a tab navigator and is defined using the dynamic API:\n\n```js\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\n\nconst Tab = createBottomTabNavigator();\n\nfunction FeedScreen() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name=\"Latest\" component={LatestScreen} />\n      <Tab.Screen name=\"Popular\" component={PopularScreen} />\n    </Tab.Navigator>\n  );\n}\n```\n\nThis code will work, but we're missing 2 things:\n\n- Linking configuration for the screens in the top tab navigator.\n- TypeScript types for the screens in the top tab navigator.\n\nSince the nested navigator is defined using the dynamic API, we need to handle these manually. For the linking configuration, we can define the screens in the `linking` property of the `Feed` screen:\n\n```js\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n    Feed: {\n      screen: FeedScreen,\n      linking: {\n        path: 'feed',\n        // highlight-start\n        screens: {\n          Latest: 'latest',\n          Popular: 'popular',\n        },\n        // highlight-end\n      },\n    },\n  },\n});\n```\n\nHere the `screens` property is the same as how you'd define it with `linking` config with the dynamic API. It can contain configuration for any nested navigators as well. See [configuring links](configuring-links.md) for more details on the API.\n\nFor the TypeScript types, we can define the type of the `FeedScreen` component:\n\n```tsx\nimport {\n  StaticScreenProps,\n  NavigatorScreenParams,\n} from '@react-navigation/native';\n\ntype FeedParamList = {\n  Latest: undefined;\n  Popular: undefined;\n};\n\n// highlight-next-line\ntype Props = StaticScreenProps<NavigatorScreenParams<FeedParamList>>;\n\n// highlight-next-line\nfunction FeedScreen(_: Props) {\n  // ...\n}\n```\n\nIn the above snippet:\n\n1. We first define the param list type for screens in the navigator that defines params for each screen\n2. Then we use the `NavigatorScreenParams` type to get the type of route's `params` which will include types for the nested screens\n3. Finally, we use the type of `params` with `StaticScreenProps` to define the type of the screen component\n\nThis is based on how we'd define the type for a screen with a nested navigator with the dynamic API. See [Type checking screens and params in nested navigator](typescript.md#type-checking-screens-and-params-in-nested-navigator).\n\n## Dynamic root navigator, static nested navigator\n\nThis is useful if you already have a dynamic configuration, but want to migrate to the static API. This way you can migrate one navigator at a time.\n\nLet's consider the following example:\n\n- You have a root stack navigator that contains a tab navigator in a screen.\n- The root stack navigator is defined using the dynamic API.\n\nOur dynamic configuration would look like this:\n\n```js\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst RootStack = createNativeStackNavigator();\n\nfunction RootStackScreen() {\n  return (\n    <RootStack.Navigator>\n      <RootStack.Screen name=\"Home\" component={HomeScreen} />\n      <RootStack.Screen name=\"Feed\" component={FeedScreen} />\n    </RootStack.Navigator>\n  );\n}\n```\n\nHere, `FeedScreen` is a component that renders a tab navigator and is defined using the static API:\n\n```js\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\n\nconst FeedTabs = createBottomTabNavigator({\n  screens: {\n    Latest: {\n      screen: LatestScreen,\n    },\n    Popular: {\n      screen: PopularScreen,\n    },\n  },\n});\n```\n\nTo use the `FeedTabs` navigator for the `Feed` screen, we need to use the `createComponentForStaticNavigation` function:\n\n```js\nimport { createComponentForStaticNavigation } from '@react-navigation/native';\n\n// highlight-next-line\nconst FeedScreen = createComponentForStaticNavigation(FeedTabs, 'Feed');\n```\n\nIn addition, we can generate the TypeScript types for the `FeedTabs` navigator and use it in the types of `RootStack` without needing to write them manually:\n\n```tsx\nimport {\n  StaticParamList,\n  NavigatorScreenParams,\n} from '@react-navigation/native';\n\n// highlight-next-line\ntype FeedTabsParamList = StaticParamList<typeof FeedTabs>;\n\ntype RootStackParamList = {\n  Home: undefined;\n  // highlight-next-line\n  Feed: NavigatorScreenParams<FeedTabsParamList>;\n};\n```\n\nSimilarly, we can generate the linking configuration for the `FeedTabs` navigator and use it in the linking configuration passed to `NavigationContainer`:\n\n```js\nimport { createPathConfigForStaticNavigation } from '@react-navigation/native';\n\n// highlight-next-line\nconst feedScreens = createPathConfigForStaticNavigation(FeedTabs);\n\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n  config: {\n    screens: {\n      Home: '',\n      Feed: {\n        path: 'feed',\n        // highlight-next-line\n        screens: feedScreens,\n      },\n    },\n  },\n};\n```\n\nThis will generate the linking configuration for the `Feed` screen based on the configuration of the `FeedTabs` navigator.\n"},c=void 0,s={},d=[{value:"Static root navigator, dynamic nested navigator",id:"static-root-navigator-dynamic-nested-navigator",level:2},{value:"Dynamic root navigator, static nested navigator",id:"dynamic-root-navigator-static-nested-navigator",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"While the static API has many advantages, it doesn't fit use cases where the navigation configuration needs to be dynamic. So React Navigation supports interop between the static and dynamic APIs."}),"\n",(0,i.jsx)(n.p,{children:"Keep in mind that the features provided by the static API such as automatic linking configuration and automatic TypeScript types need the whole configuration to be static. If part of the configuration is dynamic, you'll need to handle those parts manually."}),"\n",(0,i.jsx)(n.p,{children:"There are 2 ways you may want to combine the static and dynamic APIs:"}),"\n",(0,i.jsx)(n.h2,{id:"static-root-navigator-dynamic-nested-navigator",children:"Static root navigator, dynamic nested navigator"}),"\n",(0,i.jsx)(n.p,{children:"This is useful if you want to keep your configuration static, but need to use a dynamic configuration for a specific navigator."}),"\n",(0,i.jsx)(n.p,{children:"Let's consider the following example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You have a root stack navigator that contains a tab navigator in a screen."}),"\n",(0,i.jsx)(n.li,{children:"The tab navigator is defined using the dynamic API."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Our static configuration would look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n    Feed: {\n      screen: FeedScreen,\n      linking: {\n        path: 'feed',\n      },\n    },\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"FeedScreen"})," is a component that renders a tab navigator and is defined using the dynamic API:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'import { createBottomTabNavigator } from \'@react-navigation/bottom-tabs\';\n\nconst Tab = createBottomTabNavigator();\n\nfunction FeedScreen() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Latest" component={LatestScreen} />\n      <Tab.Screen name="Popular" component={PopularScreen} />\n    </Tab.Navigator>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This code will work, but we're missing 2 things:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linking configuration for the screens in the top tab navigator."}),"\n",(0,i.jsx)(n.li,{children:"TypeScript types for the screens in the top tab navigator."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Since the nested navigator is defined using the dynamic API, we need to handle these manually. For the linking configuration, we can define the screens in the ",(0,i.jsx)(n.code,{children:"linking"})," property of the ",(0,i.jsx)(n.code,{children:"Feed"})," screen:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n    Feed: {\n      screen: FeedScreen,\n      linking: {\n        path: 'feed',\n        // highlight-start\n        screens: {\n          Latest: 'latest',\n          Popular: 'popular',\n        },\n        // highlight-end\n      },\n    },\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here the ",(0,i.jsx)(n.code,{children:"screens"})," property is the same as how you'd define it with ",(0,i.jsx)(n.code,{children:"linking"})," config with the dynamic API. It can contain configuration for any nested navigators as well. See ",(0,i.jsx)(n.a,{href:"/docs/configuring-links",children:"configuring links"})," for more details on the API."]}),"\n",(0,i.jsxs)(n.p,{children:["For the TypeScript types, we can define the type of the ",(0,i.jsx)(n.code,{children:"FeedScreen"})," component:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import {\n  StaticScreenProps,\n  NavigatorScreenParams,\n} from '@react-navigation/native';\n\ntype FeedParamList = {\n  Latest: undefined;\n  Popular: undefined;\n};\n\n// highlight-next-line\ntype Props = StaticScreenProps<NavigatorScreenParams<FeedParamList>>;\n\n// highlight-next-line\nfunction FeedScreen(_: Props) {\n  // ...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the above snippet:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"We first define the param list type for screens in the navigator that defines params for each screen"}),"\n",(0,i.jsxs)(n.li,{children:["Then we use the ",(0,i.jsx)(n.code,{children:"NavigatorScreenParams"})," type to get the type of route's ",(0,i.jsx)(n.code,{children:"params"})," which will include types for the nested screens"]}),"\n",(0,i.jsxs)(n.li,{children:["Finally, we use the type of ",(0,i.jsx)(n.code,{children:"params"})," with ",(0,i.jsx)(n.code,{children:"StaticScreenProps"})," to define the type of the screen component"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This is based on how we'd define the type for a screen with a nested navigator with the dynamic API. See ",(0,i.jsx)(n.a,{href:"/docs/typescript#type-checking-screens-and-params-in-nested-navigator",children:"Type checking screens and params in nested navigator"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"dynamic-root-navigator-static-nested-navigator",children:"Dynamic root navigator, static nested navigator"}),"\n",(0,i.jsx)(n.p,{children:"This is useful if you already have a dynamic configuration, but want to migrate to the static API. This way you can migrate one navigator at a time."}),"\n",(0,i.jsx)(n.p,{children:"Let's consider the following example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You have a root stack navigator that contains a tab navigator in a screen."}),"\n",(0,i.jsx)(n.li,{children:"The root stack navigator is defined using the dynamic API."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Our dynamic configuration would look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'import { createNativeStackNavigator } from \'@react-navigation/native-stack\';\n\nconst RootStack = createNativeStackNavigator();\n\nfunction RootStackScreen() {\n  return (\n    <RootStack.Navigator>\n      <RootStack.Screen name="Home" component={HomeScreen} />\n      <RootStack.Screen name="Feed" component={FeedScreen} />\n    </RootStack.Navigator>\n  );\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"FeedScreen"})," is a component that renders a tab navigator and is defined using the static API:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\n\nconst FeedTabs = createBottomTabNavigator({\n  screens: {\n    Latest: {\n      screen: LatestScreen,\n    },\n    Popular: {\n      screen: PopularScreen,\n    },\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To use the ",(0,i.jsx)(n.code,{children:"FeedTabs"})," navigator for the ",(0,i.jsx)(n.code,{children:"Feed"})," screen, we need to use the ",(0,i.jsx)(n.code,{children:"createComponentForStaticNavigation"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { createComponentForStaticNavigation } from '@react-navigation/native';\n\n// highlight-next-line\nconst FeedScreen = createComponentForStaticNavigation(FeedTabs, 'Feed');\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In addition, we can generate the TypeScript types for the ",(0,i.jsx)(n.code,{children:"FeedTabs"})," navigator and use it in the types of ",(0,i.jsx)(n.code,{children:"RootStack"})," without needing to write them manually:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import {\n  StaticParamList,\n  NavigatorScreenParams,\n} from '@react-navigation/native';\n\n// highlight-next-line\ntype FeedTabsParamList = StaticParamList<typeof FeedTabs>;\n\ntype RootStackParamList = {\n  Home: undefined;\n  // highlight-next-line\n  Feed: NavigatorScreenParams<FeedTabsParamList>;\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, we can generate the linking configuration for the ",(0,i.jsx)(n.code,{children:"FeedTabs"})," navigator and use it in the linking configuration passed to ",(0,i.jsx)(n.code,{children:"NavigationContainer"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { createPathConfigForStaticNavigation } from '@react-navigation/native';\n\n// highlight-next-line\nconst feedScreens = createPathConfigForStaticNavigation(FeedTabs);\n\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n  config: {\n    screens: {\n      Home: '',\n      Feed: {\n        path: 'feed',\n        // highlight-next-line\n        screens: feedScreens,\n      },\n    },\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will generate the linking configuration for the ",(0,i.jsx)(n.code,{children:"Feed"})," screen based on the configuration of the ",(0,i.jsx)(n.code,{children:"FeedTabs"})," navigator."]})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var a=t(96540);const i={},o=a.createContext(i);function r(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);