"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([["46268"],{15986(e,n,t){t.r(n),t.d(n,{metadata:()=>a,default:()=>u,frontMatter:()=>c,contentTitle:()=>d,toc:()=>h,assets:()=>l});var a=JSON.parse('{"id":"typescript","title":"Type checking with TypeScript","description":"React Navigation can be configured to type-check screens and their params, as well as various other APIs using TypeScript. This provides better intelliSense and type safety when working with React Navigation.","source":"@site/versioned_docs/version-8.x/typescript.md","sourceDirName":".","slug":"/typescript","permalink":"/docs/8.x/typescript","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-8.x/typescript.md","tags":[],"version":"8.x","frontMatter":{"id":"typescript","title":"Type checking with TypeScript","sidebar_label":"Configuring TypeScript"},"sidebar":"docs","previous":{"title":"Writing tests","permalink":"/docs/8.x/testing"},"next":{"title":"Troubleshooting","permalink":"/docs/8.x/troubleshooting"}}'),o=t(74848),r=t(28453),i=t(78010),s=t(57250);let c={id:"typescript",title:"Type checking with TypeScript",sidebar_label:"Configuring TypeScript"},d,l={},h=[{value:"Setting up the types",id:"setting-up-the-types",level:2},{value:"Specify the root navigator&#39;s type",id:"specify-the-root-navigators-type",level:3},{value:"Specify param types for screens",id:"specify-param-types-for-screens",level:3},{value:"Using typed hooks",id:"using-typed-hooks",level:2},{value:"Nesting navigator using dynamic API",id:"nesting-navigator-using-dynamic-api",level:2},{value:"Typechecking the navigator",id:"typechecking-the-navigator",level:2},{value:"Type checking screens",id:"type-checking-screens",level:2},{value:"Nesting navigators",id:"nesting-navigators",level:2},{value:"Type checking screens and params in nested navigator",id:"type-checking-screens-and-params-in-nested-navigator",level:3},{value:"Combining navigation props",id:"combining-navigation-props",level:3},{value:"Annotating hooks",id:"annotating-hooks",level:2},{value:"Annotating <code>options</code> and <code>screenOptions</code>",id:"annotating-options-and-screenoptions",level:2},{value:"Annotating <code>ref</code> on <code>NavigationContainer</code>",id:"annotating-ref-on-navigationcontainer",level:2},{value:"Specifying root navigator type",id:"specifying-root-navigator-type",level:2},{value:"Organizing types",id:"organizing-types",level:2}];function p(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"React Navigation can be configured to type-check screens and their params, as well as various other APIs using TypeScript. This provides better intelliSense and type safety when working with React Navigation."}),"\n",(0,o.jsxs)(n.p,{children:["First, make sure you have the following configuration in your ",(0,o.jsx)(n.code,{children:"tsconfig.json"})," under ",(0,o.jsx)(n.code,{children:"compilerOptions"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"strict: true"})," or ",(0,o.jsx)(n.code,{children:"strictNullChecks: true"})," - Necessary for intelliSense and type inference to work correctly."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'moduleResolution: "bundler"'})," - Necessary to resolve the types correctly and match the behavior of ",(0,o.jsx)(n.a,{href:"https://metrobundler.dev/",children:"Metro"})," and other bundlers."]}),"\n"]}),"\n",(0,o.jsxs)(i.A,{groupId:"config",queryString:"config",children:[(0,o.jsxs)(s.A,{value:"static",label:"Static",default:!0,children:[(0,o.jsx)(n.h2,{id:"setting-up-the-types",children:"Setting up the types"}),(0,o.jsx)(n.p,{children:"There are 2 steps to configure TypeScript with the static API:"}),(0,o.jsx)(n.h3,{id:"specify-the-root-navigators-type",children:"Specify the root navigator's type"}),(0,o.jsxs)(n.p,{children:["For the type-inference to work, React Navigation needs to know the type of the root navigator in your app. To do this, you can declare a module augmentation for ",(0,o.jsx)(n.code,{children:"@react-navigation/core"})," and extend the ",(0,o.jsx)(n.code,{children:"RootNavigator"})," interface with the type of your root navigator."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: FeedScreen,\n    Profile: ProfileScreen,\n  },\n});\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeTabs,\n  },\n});\n\n// highlight-next-line\ntype RootStackType = typeof RootStack;\n\n// highlight-start\ndeclare module '@react-navigation/core' {\n  interface RootNavigator extends RootStackType {}\n}\n// highlight-end\n"})}),(0,o.jsxs)(n.p,{children:["This is needed to type-check hooks such as ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation",children:(0,o.jsx)(n.code,{children:"useNavigation"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-route",children:(0,o.jsx)(n.code,{children:"useRoute"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation-state",children:(0,o.jsx)(n.code,{children:"useNavigationState"})})," etc."]}),(0,o.jsx)(n.h3,{id:"specify-param-types-for-screens",children:"Specify param types for screens"}),(0,o.jsx)(n.p,{children:"After setting up the type for the root navigator, all we need to do is specify the type of params that our screens accept."}),(0,o.jsx)(n.p,{children:"This can be done in 2 ways:"}),(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["The type annotation for the component specified in ",(0,o.jsx)(n.code,{children:"screen"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type { StaticScreenProps } from '@react-navigation/native';\n\n// highlight-start\ntype ProfileParams = {\n  userId: string;\n};\n// highlight-end\n\n// highlight-next-line\nfunction ProfileScreen({ route }: StaticScreenProps<ProfileParams>) {\n  // ...\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the above example, the type of ",(0,o.jsx)(n.code,{children:"route.params"})," is ",(0,o.jsx)(n.code,{children:"{ userId: string }"})," based on the type annotation in ",(0,o.jsx)(n.code,{children:"StaticScreenProps<ProfileParams>"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If you aren't using the ",(0,o.jsx)(n.code,{children:"route"})," object in the component, you can specify the ",(0,o.jsx)(n.code,{children:"props"})," as ",(0,o.jsx)(n.code,{children:"_"})," to avoid unused variable warnings:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// highlight-next-line\nfunction ProfileScreen(_: StaticScreenProps<ProfileParams>) {\n  // ...\n}\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["The path pattern specified in the linking config (e.g. for ",(0,o.jsx)(n.code,{children:"linking: 'profile/:userId'"}),", the type of ",(0,o.jsx)(n.code,{children:"route.params"})," is ",(0,o.jsx)(n.code,{children:"{ userId: string }"}),"). The type can be further customized by using a ",(0,o.jsxs)(n.a,{href:"/docs/8.x/configuring-links#passing-params",children:[(0,o.jsx)(n.code,{children:"parse"})," function in the linking config"]}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"linking: {\n  path: 'profile/:userId',\n  parse: {\n    userId: (id) => parseInt(id, 10),\n  },\n},\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The above example would make the type of ",(0,o.jsx)(n.code,{children:"route.params"})," be ",(0,o.jsx)(n.code,{children:"{ userId: number }"})," since the ",(0,o.jsx)(n.code,{children:"parse"})," function converts the string from the URL to a number."]}),"\n"]}),"\n"]}),(0,o.jsxs)(n.p,{children:["If both ",(0,o.jsx)(n.code,{children:"screen"})," and ",(0,o.jsx)(n.code,{children:"linking"})," specify params, the final type of ",(0,o.jsx)(n.code,{children:"route.params"})," is the intersection of both types."]}),(0,o.jsx)(n.p,{children:"This is how the complete example would look like:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const MyStack = createNativeStackNavigator({\n  screens: {\n    // highlight-start\n    Profile: createNativeStackScreen({\n      screen: ProfileScreen,\n      linking: {\n        path: 'profile/:userId',\n        parse: {\n          userId: (id) => parseInt(id, 10),\n        },\n      },\n    }),\n    // highlight-end\n  },\n});\n"})}),(0,o.jsx)(n.p,{children:"If your app supports deep linking or runs on the Web, it is recommended to specify params that appear in the path pattern in the linking config. Any additional params (e.g. query params) can be specified in the component's props."}),(0,o.jsxs)(n.p,{children:["If you have specified the params in ",(0,o.jsx)(n.code,{children:"linking"}),", it's recommended to not specify them again in the component's props, and use ",(0,o.jsx)(n.code,{children:"useRoute('ScreenName')"})," instead to get the correctly typed ",(0,o.jsx)(n.code,{children:"route"})," object."]}),(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"createXScreen"})," helper functions enable type inference in screen configuration callbacks like ",(0,o.jsx)(n.code,{children:"options"}),", ",(0,o.jsx)(n.code,{children:"listeners"}),", etc. Each navigator exports its own version of the helper function:"]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"createNativeStackScreen"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/native-stack"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"createStackScreen"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/stack"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"createBottomTabScreen"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"createDrawerScreen"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/drawer"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"createMaterialTopTabScreen"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/material-top-tabs"})]}),"\n"]}),(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/static-configuration#createxscreen",children:"Static configuration"})," for more details."]}),(0,o.jsx)(n.h2,{id:"using-typed-hooks",children:"Using typed hooks"}),(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-route",children:(0,o.jsx)(n.code,{children:"useRoute"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation",children:(0,o.jsx)(n.code,{children:"useNavigation"})}),", and ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation-state",children:(0,o.jsx)(n.code,{children:"useNavigationState"})})," hooks accept the name of the current screen or any parent screen where it's nested as an argument to infer the correct types."]}),(0,o.jsx)(n.p,{children:"Once the types are set up, these hooks are automatically typed based on the name of the screen passed to them."}),(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"useRoute"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function ProfileScreen() {\n  const route = useRoute('Profile');\n\n  // The params are correctly typed here\n  const { userId } = route.params;\n\n  // ...\n}\n"})}),(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"useNavigation"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function ProfileScreen() {\n  const navigation = useNavigation('Profile');\n\n  // Helpers like `push` are correctly typed here\n  navigation.push('Feed');\n\n  // ...\n}\n"})}),(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"useNavigationState"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function ProfileScreen() {\n  const focusedRouteName = useNavigationState(\n    'Profile',\n    // The state is correctly typed here\n    (state) => state.routes[state.index].name\n  );\n\n  // The `focusedRouteName` type is one of the route names\n  // defined in the navigator where `Profile` is defined\n  console.log(focusedRouteName);\n\n  // ...\n}\n"})}),(0,o.jsx)(n.p,{children:"It's also possible to use these hooks without specifying the screen name - which can be useful in re-usable components that can be used across multiple screens. In this case, different things happen based on the hook."}),(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useRoute"})," hook returns a union of all routes in the app, and can be narrowed down using type guards:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function Header() {\n  const route = useRoute();\n\n  // The route is an union of all routes in the app\n  console.log(route.name);\n\n  // It's possible to narrow down the type using type guards\n  if (route.name === 'Profile') {\n    // Here route.params is correctly typed\n    const { userId } = route.params;\n  }\n\n  // ...\n}\n"})}),(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useNavigation"})," hook returns a generic navigation object that refers to the root navigator. This means that any navigation actions can be called as if they are used in a screen of the root navigator:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function Header() {\n  const navigation = useNavigation();\n\n  // A generic navigation object that refers to the root navigator\n  navigation.navigate('Profile', { userId: '123' });\n\n  // ...\n}\n"})}),(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useNavigationState"})," hook returns a generic navigation state without any navigator-specific types:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function Header() {\n  const focusedRouteName = useNavigationState((state) => {\n    // The state is a generic navigation state\n    return state.routes[state.index].name;\n  });\n\n  // The `focusedRouteName` type is `string`\n  console.log(focusedRouteName);\n\n  // ...\n}\n"})}),(0,o.jsx)(n.h2,{id:"nesting-navigator-using-dynamic-api",children:"Nesting navigator using dynamic API"}),(0,o.jsx)(n.p,{children:"Consider the following example:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const Tab = createBottomTabNavigator();\n\nfunction HomeTabs() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Feed" component={FeedScreen} />\n      <Tab.Screen name="Profile" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: HomeTabs,\n  },\n});\n'})}),(0,o.jsxs)(n.p,{children:["Here, the ",(0,o.jsx)(n.code,{children:"HomeTabs"})," component is defined using the dynamic API. This means that React Navigation won't know about the screens defined in the nested navigator and the types for those screens. To fix this, we'd need to specify the types for the nested navigator explicitly."]}),(0,o.jsxs)(n.p,{children:["This can be done by annotating the type of the ",(0,o.jsx)(n.a,{href:"/docs/8.x/route-object",children:(0,o.jsx)(n.code,{children:"route"})})," prop that the screen component receives:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'type HomeTabsParamList = {\n  Feed: undefined;\n  Profile: undefined;\n};\n\n// highlight-start\ntype HomeTabsProps = StaticScreenProps<\n  NavigatorScreenParams<HomeTabsParamList>\n>;\n// highlight-end\n\n// highlight-next-line\nfunction HomeTabs(_: HomeTabsProps) {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Feed" component={FeedScreen} />\n      <Tab.Screen name="Profile" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n'})}),(0,o.jsxs)(n.p,{children:["Here the ",(0,o.jsx)(n.code,{children:"HomeTabsParamList"})," type defines the mapping of route names in the tab navigator to the types of their params. We then use the ",(0,o.jsx)(n.code,{children:"NavigatorScreenParams"})," utility to say that these are the screens in a nested navigator in the ",(0,o.jsx)(n.code,{children:"HomeTabs"})," component."]}),(0,o.jsxs)(n.p,{children:["Now, React Navigation knows about the screens in the nested navigator and their params, and the types can be inferred with hooks such as ",(0,o.jsx)(n.code,{children:"useRoute"}),"."]})]}),(0,o.jsxs)(s.A,{value:"dynamic",label:"Dynamic",children:[(0,o.jsx)(n.p,{children:"When using the dynamic API, it is necessary to specify the types for each screen as well as the nesting structure as it cannot be inferred from the code."}),(0,o.jsx)(n.h2,{id:"typechecking-the-navigator",children:"Typechecking the navigator"}),(0,o.jsxs)(n.p,{children:["To typecheck our route name and params, the first thing we need to do is to create an object type with mappings for route names to the params of the route. For example, say we have a route called ",(0,o.jsx)(n.code,{children:"Profile"})," in our root navigator which should have a param ",(0,o.jsx)(n.code,{children:"userId"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"type RootStackParamList = {\n  Profile: { userId: string };\n};\n"})}),(0,o.jsx)(n.p,{children:"Similarly, we need to do the same for each route:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"type RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Feed: { sort: 'latest' | 'top' } | undefined;\n};\n"})}),(0,o.jsxs)(n.p,{children:["Specifying ",(0,o.jsx)(n.code,{children:"undefined"})," means that the route doesn't have params. A union type with ",(0,o.jsx)(n.code,{children:"undefined"})," (e.g. ",(0,o.jsx)(n.code,{children:"SomeType | undefined"}),") means that params are optional."]}),(0,o.jsxs)(n.p,{children:["After we have defined the mapping, we need to tell our navigator to use it. To do that, we can pass it as a generic to the ",(0,o.jsx)(n.a,{href:"/docs/8.x/static-configuration",children:(0,o.jsx)(n.code,{children:"createXNavigator"})})," functions:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { createStackNavigator } from '@react-navigation/stack';\n\nconst RootStack = createStackNavigator<RootStackParamList>();\n"})}),(0,o.jsx)(n.p,{children:"And then we can use it:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'<RootStack.Navigator initialRouteName="Home">\n  <RootStack.Screen name="Home" component={Home} />\n  <RootStack.Screen\n    name="Profile"\n    component={Profile}\n    initialParams={{ userId: user.id }}\n  />\n  <RootStack.Screen name="Feed" component={Feed} />\n</RootStack.Navigator>\n'})}),(0,o.jsxs)(n.p,{children:["This will provide type checking and intelliSense for props of the ",(0,o.jsx)(n.a,{href:"/docs/8.x/navigator",children:(0,o.jsx)(n.code,{children:"Navigator"})})," and ",(0,o.jsx)(n.a,{href:"/docs/8.x/screen",children:(0,o.jsx)(n.code,{children:"Screen"})})," components."]}),(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["The type containing the mapping must be a type alias (e.g. ",(0,o.jsx)(n.code,{children:"type RootStackParamList = { ... }"}),"). It cannot be an interface (e.g. ",(0,o.jsx)(n.code,{children:"interface RootStackParamList { ... }"}),"). It also shouldn't extend ",(0,o.jsx)(n.code,{children:"ParamListBase"})," (e.g. ",(0,o.jsx)(n.code,{children:"interface RootStackParamList extends ParamListBase { ... }"}),"). Doing so will result in incorrect type checking which allows you to pass incorrect route names."]})}),(0,o.jsx)(n.h2,{id:"type-checking-screens",children:"Type checking screens"}),(0,o.jsxs)(n.p,{children:["To typecheck our screens, we need to annotate the ",(0,o.jsx)(n.code,{children:"navigation"})," and the ",(0,o.jsx)(n.code,{children:"route"})," props received by a screen. The navigator packages in React Navigation export generic types to define types for both the ",(0,o.jsx)(n.code,{children:"navigation"})," and ",(0,o.jsx)(n.code,{children:"route"})," props from the corresponding navigator."]}),(0,o.jsxs)(n.p,{children:["For example, you can use ",(0,o.jsx)(n.code,{children:"NativeStackScreenProps"})," for the Native Stack Navigator."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import type { NativeStackScreenProps } from '@react-navigation/native-stack';\n\ntype RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Feed: { sort: 'latest' | 'top' } | undefined;\n};\n\ntype Props = NativeStackScreenProps<RootStackParamList, 'Profile'>;\n"})}),(0,o.jsx)(n.p,{children:"The type takes 2 generics:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The param list object we defined earlier"}),"\n",(0,o.jsx)(n.li,{children:"The name of the route the screen belongs to"}),"\n"]}),(0,o.jsxs)(n.p,{children:["This allows us to type check route names and params which you're navigating using ",(0,o.jsx)(n.a,{href:"/docs/8.x/navigation-object#navigate",children:(0,o.jsx)(n.code,{children:"navigate"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/stack-actions#push",children:(0,o.jsx)(n.code,{children:"push"})})," etc. The name of the current route is necessary to type check the params in ",(0,o.jsx)(n.code,{children:"route.params"})," and when you call ",(0,o.jsx)(n.a,{href:"navigation-actions#setparams",children:(0,o.jsx)(n.code,{children:"setParams"})})," or ",(0,o.jsx)(n.a,{href:"navigation-actions#replaceparams",children:(0,o.jsx)(n.code,{children:"replaceParams"})}),"."]}),(0,o.jsxs)(n.p,{children:["Similarly, you can import ",(0,o.jsx)(n.code,{children:"StackScreenProps"})," from ",(0,o.jsx)(n.a,{href:"/docs/8.x/stack-navigator",children:(0,o.jsx)(n.code,{children:"@react-navigation/stack"})}),", ",(0,o.jsx)(n.code,{children:"DrawerScreenProps"})," from ",(0,o.jsx)(n.a,{href:"/docs/8.x/drawer-navigator",children:(0,o.jsx)(n.code,{children:"@react-navigation/drawer"})}),", ",(0,o.jsx)(n.code,{children:"BottomTabScreenProps"})," from ",(0,o.jsx)(n.a,{href:"/docs/8.x/bottom-tab-navigator",children:(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs"})})," and so on."]}),(0,o.jsxs)(n.p,{children:["Then you can use the ",(0,o.jsx)(n.code,{children:"Props"})," type you defined above to annotate your component."]}),(0,o.jsx)(n.p,{children:"For function components:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"function ProfileScreen({ route, navigation }: Props) {\n  // ...\n}\n"})}),(0,o.jsx)(n.p,{children:"For class components:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"class ProfileScreen extends React.Component<Props> {\n  render() {\n    // ...\n  }\n}\n"})}),(0,o.jsxs)(n.p,{children:["You can get the types for ",(0,o.jsx)(n.code,{children:"navigation"})," and ",(0,o.jsx)(n.code,{children:"route"})," from the ",(0,o.jsx)(n.code,{children:"Props"})," type as follows:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"type ProfileScreenNavigationProp = Props['navigation'];\n\ntype ProfileScreenRouteProp = Props['route'];\n"})}),(0,o.jsxs)(n.p,{children:["Alternatively, you can also annotate the ",(0,o.jsx)(n.code,{children:"navigation"})," and ",(0,o.jsx)(n.code,{children:"route"})," objects separately."]}),(0,o.jsxs)(n.p,{children:["To get the type for the ",(0,o.jsx)(n.code,{children:"navigation"})," prop, we need to import the corresponding type from the navigator. For example, ",(0,o.jsx)(n.code,{children:"NativeStackNavigationProp"})," for ",(0,o.jsx)(n.code,{children:"@react-navigation/native-stack"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import type { NativeStackNavigationProp } from '@react-navigation/native-stack';\n\ntype ProfileScreenNavigationProp = NativeStackNavigationProp<\n  RootStackParamList,\n  'Profile'\n>;\n"})}),(0,o.jsxs)(n.p,{children:["Similarly, you can import ",(0,o.jsx)(n.code,{children:"StackNavigationProp"})," from ",(0,o.jsx)(n.a,{href:"/docs/8.x/stack-navigator",children:(0,o.jsx)(n.code,{children:"@react-navigation/stack"})}),", ",(0,o.jsx)(n.code,{children:"DrawerNavigationProp"})," from ",(0,o.jsx)(n.a,{href:"/docs/8.x/drawer-navigator",children:(0,o.jsx)(n.code,{children:"@react-navigation/drawer"})}),", ",(0,o.jsx)(n.code,{children:"BottomTabNavigationProp"})," from ",(0,o.jsx)(n.a,{href:"/docs/8.x/bottom-tab-navigator",children:(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs"})})," etc."]}),(0,o.jsxs)(n.p,{children:["To get the type for the ",(0,o.jsx)(n.code,{children:"route"})," object, we need to use the ",(0,o.jsx)(n.code,{children:"RouteProp"})," type from ",(0,o.jsx)(n.code,{children:"@react-navigation/native"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import type { RouteProp } from '@react-navigation/native';\n\ntype ProfileScreenRouteProp = RouteProp<RootStackParamList, 'Profile'>;\n"})}),(0,o.jsxs)(n.p,{children:["We recommend creating a separate file: ",(0,o.jsx)(n.code,{children:"types.tsx"})," - where you keep the types and import from there in your component files instead of repeating them in each file."]}),(0,o.jsx)(n.h2,{id:"nesting-navigators",children:"Nesting navigators"}),(0,o.jsx)(n.h3,{id:"type-checking-screens-and-params-in-nested-navigator",children:"Type checking screens and params in nested navigator"}),(0,o.jsxs)(n.p,{children:["You can ",(0,o.jsx)(n.a,{href:"/docs/8.x/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator",children:"navigate to a screen in a nested navigator"})," by passing ",(0,o.jsx)(n.code,{children:"screen"})," and ",(0,o.jsx)(n.code,{children:"params"})," properties for the nested screen:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"navigation.navigate('Home', {\n  screen: 'Feed',\n  params: { sort: 'latest' },\n});\n"})}),(0,o.jsxs)(n.p,{children:["To be able to type check this, we need to extract the params from the screen containing the nested navigator. This can be done using the ",(0,o.jsx)(n.code,{children:"NavigatorScreenParams"})," utility:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { NavigatorScreenParams } from '@react-navigation/native';\n\ntype TabParamList = {\n  Home: NavigatorScreenParams<StackParamList>;\n  Profile: { userId: string };\n};\n"})}),(0,o.jsx)(n.h3,{id:"combining-navigation-props",children:"Combining navigation props"}),(0,o.jsxs)(n.p,{children:["When you nest navigators, the navigation prop of the screen is a combination of multiple navigation props. For example, if we have a tab inside a stack, the ",(0,o.jsx)(n.code,{children:"navigation"})," prop will have both ",(0,o.jsx)(n.a,{href:"/docs/8.x/tab-actions#jumpto",children:(0,o.jsx)(n.code,{children:"jumpTo"})})," (from the tab navigator) and ",(0,o.jsx)(n.a,{href:"/docs/8.x/stack-actions#push",children:(0,o.jsx)(n.code,{children:"push"})})," (from the stack navigator). To make it easier to combine types from multiple navigators, you can use the ",(0,o.jsx)(n.code,{children:"CompositeScreenProps"})," type."]}),(0,o.jsxs)(n.p,{children:["For example, if we have a ",(0,o.jsx)(n.code,{children:"Profile"})," in a navigator, nested inside ",(0,o.jsx)(n.code,{children:"Account"})," screen of a stack navigator, we can combine the types as follows:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type { CompositeScreenProps } from '@react-navigation/native';\nimport type { BottomTabScreenProps } from '@react-navigation/bottom-tabs';\nimport type { StackScreenProps } from '@react-navigation/stack';\n\ntype ProfileScreenProps = CompositeScreenProps<\n  BottomTabScreenProps<TabParamList, 'Profile'>,\n  StackScreenProps<StackParamList, 'Account'>\n>;\n"})}),(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"CompositeScreenProps"})," type takes 2 parameters:"]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The first parameter is the type for the navigator that owns this screen, in our case the tab navigator which contains the ",(0,o.jsx)(n.code,{children:"Profile"})," screen"]}),"\n",(0,o.jsxs)(n.li,{children:["The second parameter is the type of props for a parent navigator, in our case the stack navigator which contains the ",(0,o.jsx)(n.code,{children:"Account"})," screen"]}),"\n"]}),(0,o.jsxs)(n.p,{children:["For multiple parent navigators, this second parameter can nest another ",(0,o.jsx)(n.code,{children:"CompositeScreenProps"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"type ProfileScreenProps = CompositeScreenProps<\n  BottomTabScreenProps<TabParamList, 'Profile'>,\n  CompositeScreenProps<\n    StackScreenProps<StackParamList, 'Account'>,\n    DrawerScreenProps<DrawerParamList, 'Home'>\n  >\n>;\n"})}),(0,o.jsxs)(n.p,{children:["If annotating the ",(0,o.jsx)(n.code,{children:"navigation"})," prop separately, you can use ",(0,o.jsx)(n.code,{children:"CompositeNavigationProp"})," instead. The usage is similar to ",(0,o.jsx)(n.code,{children:"CompositeScreenProps"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type { CompositeNavigationProp } from '@react-navigation/native';\nimport type { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';\nimport type { StackNavigationProp } from '@react-navigation/stack';\n\ntype ProfileScreenNavigationProp = CompositeNavigationProp<\n  BottomTabNavigationProp<TabParamList, 'Profile'>,\n  StackNavigationProp<StackParamList, 'Account'>\n>;\n"})}),(0,o.jsx)(n.h2,{id:"annotating-hooks",children:"Annotating hooks"}),(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-route",children:(0,o.jsx)(n.code,{children:"useRoute"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation",children:(0,o.jsx)(n.code,{children:"useNavigation"})}),", and ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation-state",children:(0,o.jsx)(n.code,{children:"useNavigationState"})})," hooks accept the name of the current screen or any parent screen where it's nested as an argument for limited type inference in dynamic API after ",(0,o.jsx)(n.a,{href:"#specifying-root-navigator-type",children:"specifying root navigator type"}),"."]}),(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"useRoute"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function ProfileScreen() {\n  const route = useRoute('Profile');\n\n  // The params are correctly typed here\n  const { userId } = route.params;\n\n  // ...\n}\n"})}),(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"useNavigation"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function ProfileScreen() {\n  const navigation = useNavigation('Profile');\n\n  // Helpers like `getState` are correctly typed here\n  const state = navigation.getState();\n\n  // ...\n}\n"})}),(0,o.jsxs)(n.p,{children:["This will automatically infer the type for methods such as ",(0,o.jsx)(n.code,{children:"getState"}),", ",(0,o.jsx)(n.code,{children:"setParams"})," etc. However, it doesn't include navigator-specific types, and they cannot be automatically inferred when using the dynamic configuration."]}),(0,o.jsxs)(n.p,{children:["So if we want to use a navigator-specific method (e.g. ",(0,o.jsx)(n.code,{children:"push"})," from stack navigator), we need to annotate the type of the returned ",(0,o.jsx)(n.code,{children:"navigation"})," object."]}),(0,o.jsxs)(n.p,{children:["This can be done using ",(0,o.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions",children:"type assertion"})," with the ",(0,o.jsx)(n.code,{children:"as"})," keyword:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function ProfileScreen() {\n  const navigation = useNavigation('Profile') as ProfileScreenNavigationProp;\n\n  // ...\n}\n"})}),(0,o.jsx)(n.admonition,{type:"danger",children:(0,o.jsxs)(n.p,{children:["Annotating ",(0,o.jsx)(n.code,{children:"useNavigation"})," isn't type-safe because we cannot verify that the provided type matches the actual navigators."]})}),(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"useNavigationState"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function ProfileScreen() {\n  const focusedRouteName = useNavigationState(\n    'Profile',\n    // The state is correctly typed here\n    (state) => state.routes[state.index].name\n  );\n\n  // The `focusedRouteName` type is one of the route names\n  // defined in the navigator where `Profile` is defined\n  console.log(focusedRouteName);\n\n  // ...\n}\n"})}),(0,o.jsxs)(n.h2,{id:"annotating-options-and-screenoptions",children:["Annotating ",(0,o.jsx)(n.code,{children:"options"})," and ",(0,o.jsx)(n.code,{children:"screenOptions"})]}),(0,o.jsxs)(n.p,{children:["When you pass the ",(0,o.jsx)(n.code,{children:"options"})," to a ",(0,o.jsx)(n.code,{children:"Screen"})," or ",(0,o.jsx)(n.code,{children:"screenOptions"})," prop to a ",(0,o.jsx)(n.code,{children:"Navigator"})," component, they are already type-checked and you don't need to do anything special. However, sometimes you might want to extract the options to a separate object, and you might want to annotate it."]}),(0,o.jsxs)(n.p,{children:["To annotate the options, we need to import the corresponding type from the navigator. For example, ",(0,o.jsx)(n.code,{children:"StackNavigationOptions"})," for ",(0,o.jsx)(n.code,{children:"@react-navigation/stack"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type { StackNavigationOptions } from '@react-navigation/stack';\n\nconst options: StackNavigationOptions = {\n  headerShown: false,\n};\n"})}),(0,o.jsxs)(n.p,{children:["Similarly, you can import ",(0,o.jsx)(n.code,{children:"DrawerNavigationOptions"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/drawer"}),", ",(0,o.jsx)(n.code,{children:"BottomTabNavigationOptions"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs"})," etc."]}),(0,o.jsxs)(n.p,{children:["When using the function form of ",(0,o.jsx)(n.code,{children:"options"})," and ",(0,o.jsx)(n.code,{children:"screenOptions"}),", you can annotate the arguments with a type exported from the navigator, e.g. ",(0,o.jsx)(n.code,{children:"StackOptionsArgs"})," for ",(0,o.jsx)(n.code,{children:"@react-navigation/stack"}),", ",(0,o.jsx)(n.code,{children:"DrawerOptionsArgs"})," for ",(0,o.jsx)(n.code,{children:"@react-navigation/drawer"}),", ",(0,o.jsx)(n.code,{children:"BottomTabOptionsArgs"})," for ",(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs"})," etc.:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type {\n  StackNavigationOptions,\n  StackOptionsArgs,\n} from '@react-navigation/stack';\n\nconst options = ({ route }: StackOptionsArgs): StackNavigationOptions => {\n  return {\n    headerTitle: route.name,\n  };\n};\n"})}),(0,o.jsxs)(n.p,{children:["If you want to annotate the type of params in the ",(0,o.jsx)(n.code,{children:"route"})," object, you can use pass the param list and route name as generics to the ",(0,o.jsx)(n.code,{children:"StackOptionsArgs"})," type:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type {\n  StackNavigationOptions,\n  StackOptionsArgs,\n} from '@react-navigation/stack';\n\nconst options = ({\n  route,\n}: StackOptionsArgs<RootStackParamList, 'Profile'>): StackNavigationOptions => {\n  const { userId } = route.params;\n\n  return {\n    headerTitle: `Profile of ${userId}`,\n  };\n};\n"})}),(0,o.jsxs)(n.h2,{id:"annotating-ref-on-navigationcontainer",children:["Annotating ",(0,o.jsx)(n.code,{children:"ref"})," on ",(0,o.jsx)(n.code,{children:"NavigationContainer"})]}),(0,o.jsxs)(n.p,{children:["If you use the ",(0,o.jsx)(n.code,{children:"createNavigationContainerRef()"})," method to create the ref, you can annotate it to type-check navigation actions:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { createNavigationContainerRef } from '@react-navigation/native';\n\n// ...\n\nconst navigationRef = createNavigationContainerRef<RootStackParamList>();\n"})}),(0,o.jsxs)(n.p,{children:["Similarly, for ",(0,o.jsx)(n.code,{children:"useNavigationContainerRef()"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { useNavigationContainerRef } from '@react-navigation/native';\n\n// ...\n\nconst navigationRef = useNavigationContainerRef<RootStackParamList>();\n"})}),(0,o.jsxs)(n.p,{children:["If you're using a regular ",(0,o.jsx)(n.code,{children:"ref"})," object, you can pass a generic to the ",(0,o.jsx)(n.code,{children:"NavigationContainerRef"})," type.."]}),(0,o.jsxs)(n.p,{children:["Example when using ",(0,o.jsx)(n.code,{children:"React.useRef"})," hook:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type { NavigationContainerRef } from '@react-navigation/native';\n\n// ...\n\nconst navigationRef =\n  React.useRef<NavigationContainerRef<RootStackParamList>>(null);\n"})}),(0,o.jsxs)(n.p,{children:["Example when using ",(0,o.jsx)(n.code,{children:"React.createRef"}),":"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type { NavigationContainerRef } from '@react-navigation/native';\n\n// ...\n\nconst navigationRef =\n  React.createRef<NavigationContainerRef<RootStackParamList>>();\n"})}),(0,o.jsx)(n.h2,{id:"specifying-root-navigator-type",children:"Specifying root navigator type"}),(0,o.jsxs)(n.p,{children:["You can specify the type for your root navigator which will enable automatic type inference (with limitations) for ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-route",children:(0,o.jsx)(n.code,{children:"useRoute"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation",children:(0,o.jsx)(n.code,{children:"useNavigation"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation-state",children:(0,o.jsx)(n.code,{children:"useNavigationState"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/link",children:(0,o.jsx)(n.code,{children:"Link"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/navigation-container#ref",children:(0,o.jsx)(n.code,{children:"ref"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/navigation-container#linking",children:(0,o.jsx)(n.code,{children:"linking"})})," etc."]}),(0,o.jsxs)(n.p,{children:["To do this, you can use module augmentation for ",(0,o.jsx)(n.code,{children:"@react-navigation/core"})," and extend the ",(0,o.jsx)(n.code,{children:"RootNavigator"})," interface with the type of your root navigator."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const RootStack = createNativeStackNavigator<RootStackParamList>();\n\nfunction App() {\n  // ...\n}\n\n// highlight-next-line\ntype RootStackType = typeof RootStack;\n\n// highlight-start\ndeclare module '@react-navigation/core' {\n  interface RootNavigator extends RootStackType {}\n}\n// highlight-end\n"})}),(0,o.jsxs)(n.p,{children:["Here ",(0,o.jsx)(n.code,{children:"RootStack"})," refers to the navigator used at the root of your app."]}),(0,o.jsx)(n.h2,{id:"organizing-types",children:"Organizing types"}),(0,o.jsx)(n.p,{children:"When writing types for React Navigation, there are a couple of things we recommend to keep things organized."}),(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["It's good to create a separate file (e.g. ",(0,o.jsx)(n.code,{children:"navigation/types.tsx"}),") that contains the types related to React Navigation."]}),"\n",(0,o.jsxs)(n.li,{children:["Instead of using ",(0,o.jsx)(n.code,{children:"CompositeNavigationProp"})," directly in your components, it's better to create a helper type that you can reuse."]}),"\n",(0,o.jsx)(n.li,{children:"Specifying a global type for your root navigator would avoid manual annotations in many places."}),"\n"]}),(0,o.jsx)(n.p,{children:"Considering these recommendations, the file containing the types may look something like this:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type {\n  CompositeScreenProps,\n  NavigatorScreenParams,\n} from '@react-navigation/native';\nimport type { StackScreenProps } from '@react-navigation/stack';\nimport type { BottomTabScreenProps } from '@react-navigation/bottom-tabs';\n\nexport type RootStackParamList = {\n  Home: NavigatorScreenParams<HomeTabParamList>;\n  PostDetails: { id: string };\n  NotFound: undefined;\n};\n\nexport type RootStackScreenProps<T extends keyof RootStackParamList> =\n  StackScreenProps<RootStackParamList, T>;\n\nexport type HomeTabParamList = {\n  Popular: undefined;\n  Latest: undefined;\n};\n\nexport type HomeTabScreenProps<T extends keyof HomeTabParamList> =\n  CompositeScreenProps<\n    BottomTabScreenProps<HomeTabParamList, T>,\n    RootStackScreenProps<keyof RootStackParamList, 'Home'>\n  >;\n"})}),(0,o.jsx)(n.p,{children:"Then, you'd set up the global type for your root navigator in the same file where your root navigator is defined:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { createStackNavigator } from '@react-navigation/stack';\nimport type { RootStackParamList } from './navigation/types';\n\nconst RootStack = createStackNavigator<RootStackParamList>();\n\nfunction App() {\n  // ...\n}\n\n// Specify the global type for the root navigator\ntype RootStackType = typeof RootStack;\n\ndeclare module '@react-navigation/core' {\n  interface RootNavigator extends RootStackType {}\n}\n"})}),(0,o.jsx)(n.p,{children:"Now, when annotating your components, you can write:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import type { HomeTabScreenProps } from './navigation/types';\n\nfunction PopularScreen({ navigation, route }: HomeTabScreenProps<'Popular'>) {\n  // ...\n}\n"})})]})]})]})}function u(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},57250(e,n,t){t.d(n,{A:()=>r});var a=t(74848);t(96540);var o=t(34164);function r(e){let{children:n,hidden:t,className:r}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,o.A)("tabItem_Ymn6",r),hidden:t,children:n})}},78010(e,n,t){t.d(n,{A:()=>b});var a=t(74848),o=t(96540),r=t(34164),i=t(88287),s=t(28584),c=t(56347),d=t(99989),l=t(96629),h=t(80618),p=t(41367);function u(e){var n,t;return null!=(n=null==(t=o.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))?void 0:t.filter(Boolean))?n:[]}function g(e){let{value:n,tabValues:t}=e;return t.some(e=>e.value===n)}var m=t(19863);function x(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},a=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.forEach(function(n){var a;a=t[n],n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a})}return e}function f(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):(function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t.push.apply(t,a)}return t})(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}),e}function j(e){let{className:n,block:t,selectedValue:o,selectValue:i,tabValues:c}=e,d=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),h=e=>{let n=e.currentTarget,t=c[d.indexOf(n)].value;t!==o&&(l(n),i(t))},p=e=>{var n,t;let a=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{let t=d.indexOf(e.currentTarget)+1;a=null!=(n=d[t])?n:d[0];break}case"ArrowLeft":{let n=d.indexOf(e.currentTarget)-1;a=null!=(t=d[n])?t:d[d.length-1]}}null==a||a.focus()};return(0,a.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:c.map(e=>{let{value:n,label:t,attributes:i}=e;return(0,a.jsx)("li",f(x({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,ref:e=>{d.push(e)},onKeyDown:p,onClick:h},i),{className:(0,r.A)("tabs__item","tabItem_LNqP",null==i?void 0:i.className,{"tabs__item--active":o===n}),children:null!=t?t:n}),n)})})}function v(e){let{lazy:n,children:t,selectedValue:i}=e,s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){let e=s.find(e=>e.props.value===i);return e?(0,o.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,a.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==i}))})}function y(e){let n=function(e){let n,{defaultValue:t,queryString:a=!1,groupId:r}=e,i=function(e){let{values:n,children:t}=e;return(0,o.useMemo)(()=>{let e=null!=n?n:u(t).map(e=>{let{props:{value:n,label:t,attributes:a,default:o}}=e;return{value:n,label:t,attributes:a,default:o}}),a=(0,h.XI)(e,(e,n)=>e.value===n.value);if(a.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(a.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'));return e},[n,t])}(e),[s,m]=(0,o.useState)(()=>(function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!g({value:t,tabValues:a}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(t,'" but none of its children has the corresponding value. Available values are: ').concat(a.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return t}let o=null!=(n=a.find(e=>e.default))?n:a[0];if(!o)throw Error("Unexpected error: 0 tabValues");return o.value})({defaultValue:t,tabValues:i})),[x,f]=function(e){let{queryString:n=!1,groupId:t}=e,a=(0,c.W6)(),r=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(r),(0,o.useCallback)(e=>{var n,t;if(!r)return;let o=new URLSearchParams(a.location.search);o.set(r,e),a.replace((n=function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},a=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.forEach(function(n){var a;a=t[n],n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a})}return e}({},a.location),t=t={search:o.toString()},Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):(function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t.push.apply(t,a)}return t})(Object(t)).forEach(function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}),n))},[r,a])]}({queryString:a,groupId:r}),[j,v]=function(e){let{groupId:n}=e,t=n?"docusaurus.tab.".concat(n):null,[a,r]=(0,p.Dv)(t);return[a,(0,o.useCallback)(e=>{t&&r.set(e)},[t,r])]}({groupId:r}),y=g({value:n=null!=x?x:j,tabValues:i})?n:null;return(0,d.A)(()=>{y&&m(y)},[y]),{selectedValue:s,selectValue:(0,o.useCallback)(e=>{if(!g({value:e,tabValues:i}))throw Error("Can't select invalid tab value=".concat(e));m(e),f(e),v(e)},[f,v,i]),tabValues:i}}(e);return(0,a.jsxs)("div",{className:(0,r.A)(i.G.tabs.container,"tabs-container","tabList__CuJ"),children:[(0,a.jsx)(j,x({},n,e)),(0,a.jsx)(v,x({},n,e))]})}function b(e){let n=(0,m.A)();return(0,a.jsx)(y,f(x({},e),{children:u(e.children)}),String(n))}},28453(e,n,t){t.d(n,{R:()=>i,x:()=>s});var a=t(96540);let o={},r=a.createContext(o);function i(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);