"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[69325],{32471:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"navigation-state","title":"Navigation state reference","description":"The navigation state is the state where React Navigation stores the navigation structure and history of the app. It\'s useful to know about the structure of the navigation state if you need to do advanced operations such as resetting the state, providing a custom initial state etc.","source":"@site/versioned_docs/version-8.x/navigation-state.md","sourceDirName":".","slug":"/navigation-state","permalink":"/docs/8.x/navigation-state","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-8.x/navigation-state.md","tags":[],"version":"8.x","frontMatter":{"id":"navigation-state","title":"Navigation state reference","sidebar_label":"Navigation state"},"sidebar":"docs","previous":{"title":"Navigation events","permalink":"/docs/8.x/navigation-events"},"next":{"title":"Link","permalink":"/docs/8.x/link"}}');var i=n(74848),s=n(28453);const o={id:"navigation-state",title:"Navigation state reference",sidebar_label:"Navigation state"},r=void 0,c={},d=[{value:"Stale state objects",id:"stale-state-objects",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["The navigation state is the state where React Navigation stores the navigation structure and history of the app. It's useful to know about the structure of the navigation state if you need to do advanced operations such as ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-actions#reset",children:"resetting the state"}),", ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-container#initialstate",children:"providing a custom initial state"})," etc."]}),"\n",(0,i.jsx)(t.p,{children:"It's a JavaScript object which looks like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    { key: 'home-1', name: 'Home', params: { sortBy: 'latest' } },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n  stale: false,\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"There are few properties present in every navigation state object:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"type"})," - Type of the navigator that the state belongs to, e.g. ",(0,i.jsx)(t.code,{children:"stack"}),", ",(0,i.jsx)(t.code,{children:"tab"}),", ",(0,i.jsx)(t.code,{children:"drawer"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"key"})," - Unique key to identify the navigator."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"routeNames"})," - Name of the screens defined in the navigator. This is an unique array containing strings for each screen."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"routes"})," - List of route objects (screens) which are rendered in the navigator. It also represents the history in a stack navigator. There should be at least one item present in this array."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"index"})," - Index of the focused route object in the ",(0,i.jsx)(t.code,{children:"routes"})," array."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"history"})," - A list of visited items. This is an optional property and not present in all navigators. For example, it's only present in tab and drawer navigators in the core. The shape of the items in the ",(0,i.jsx)(t.code,{children:"history"})," array can vary depending on the navigator. There should be at least one item present in this array."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"stale"})," - A navigation state is assumed to be stale unless the ",(0,i.jsx)(t.code,{children:"stale"})," property is explicitly set to ",(0,i.jsx)(t.code,{children:"false"}),". This means that the state object needs to be ",(0,i.jsx)(t.a,{href:"#stale-state-objects",children:'"rehydrated"'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Each route object in a ",(0,i.jsx)(t.code,{children:"routes"})," array may contain the following properties:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"key"})," - Unique key of the screen. Created automatically or added while navigating to this screen."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"name"})," - Name of the screen. Defined in navigator component hierarchy."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"params"})," - An optional object containing params which is defined while navigating e.g. ",(0,i.jsx)(t.code,{children:"navigate('Home', { sortBy: 'latest' })"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"state"})," - An optional object containing the ",(0,i.jsx)(t.a,{href:"#stale-state-objects",children:"stale navigation state"})," of a child navigator nested inside this screen."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"For example, a stack navigator containing a tab navigator nested inside it's home screen may have a navigation state object like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    {\n      key: 'home-1',\n      name: 'Home',\n      state: {\n        key: 'tab-1',\n        routeNames: ['Feed', 'Library', 'Favorites'],\n        routes: [\n          { key: 'feed-1', name: 'Feed', params: { sortBy: 'latest' } },\n          { key: 'library-1', name: 'Library' },\n          { key: 'favorites-1', name: 'Favorites' },\n        ],\n        index: 0,\n      },\n    },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It's important to note that even if there's a nested navigator, the ",(0,i.jsx)(t.code,{children:"state"})," property on the ",(0,i.jsx)(t.code,{children:"route"})," object is not added until a navigation happens, hence it's not guaranteed to exist."]}),"\n",(0,i.jsx)(t.h2,{id:"stale-state-objects",children:"Stale state objects"}),"\n",(0,i.jsxs)(t.p,{children:["Earlier there was a mention of ",(0,i.jsx)(t.code,{children:"stale"})," property in the navigation state. If the ",(0,i.jsx)(t.code,{children:"stale"})," property is set to ",(0,i.jsx)(t.code,{children:"true"})," or is missing, the state is assumed to be stale. A stale navigation state means that the state object may be partial, such as missing keys or routes, contain invalid routes, or may not be up-to-date. A stale state can be a result of ",(0,i.jsx)(t.a,{href:"/docs/8.x/deep-linking",children:"deep linking"}),", r",(0,i.jsx)(t.a,{href:"/docs/8.x/state-persistence",children:"estoring from a persisted state"})," etc."]}),"\n",(0,i.jsxs)(t.p,{children:["If you're accessing the navigation state of a navigator using the built-in APIs such as ",(0,i.jsx)(t.a,{href:"/docs/8.x/use-navigation-state",children:(0,i.jsx)(t.code,{children:"useNavigationState()"})}),", ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-object#getstate",children:(0,i.jsx)(t.code,{children:"navigation.getState()"})})," etc., the state object is guaranteed to be complete and not stale. However, if you try to access a child navigator's state with the ",(0,i.jsx)(t.code,{children:"state"})," property on the ",(0,i.jsx)(t.code,{children:"route"})," object, it maybe a stale or partial state object. So it's not recommended to use this property directly."]}),"\n",(0,i.jsxs)(t.p,{children:["Using the ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-container#getrootstate",children:(0,i.jsx)(t.code,{children:"ref.getRootState()"})})," API will always return a complete and up-to-date state object for the current navigation tree, including any nested child navigators."]}),"\n",(0,i.jsxs)(t.p,{children:["When React Navigation encounters stale or partial state, it will automatically fix it up before using it. This includes adding missing keys, removing any invalid routes, ensuring the ",(0,i.jsx)(t.code,{children:"index"})," is correct etc. This process of fixing stale state is called ",(0,i.jsx)(t.strong,{children:"rehydration"}),". If you're writing a ",(0,i.jsx)(t.a,{href:"/docs/8.x/custom-routers",children:"custom router"}),", the ",(0,i.jsx)(t.code,{children:"getRehydratedState"})," method lets you write custom rehydration logic to fix up state objects."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, ",(0,i.jsx)(t.code,{children:"index"})," should be the last route in a stack, and if a different value was specified, React Navigation fixes it. For example, if you wanted to reset your app's navigation state to have it display the ",(0,i.jsx)(t.code,{children:"Profile"})," route, and have the ",(0,i.jsx)(t.code,{children:"Home"})," route displayed upon going back, and dispatched the following action:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"navigation.reset({\n  index: 0,\n  routes: [{ name: 'Home' }, { name: 'Profile' }],\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["React Navigation would correct ",(0,i.jsx)(t.code,{children:"index"})," to ",(0,i.jsx)(t.code,{children:"1"})," before the routes are displayed."]}),"\n",(0,i.jsxs)(t.p,{children:["This feature comes handy when doing operations such as ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-actions#reset",children:"reset"}),", ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-container#initialstate",children:"providing a initial state"})," etc., as you can safely omit many properties from the navigation state object and relying on React Navigation to add those properties for you, making your code simpler. For example, you can only provide a ",(0,i.jsx)(t.code,{children:"routes"})," array without any keys and React Navigation will automatically add everything that's needed to make it work:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  routes: [{ name: 'Home' }, { name: 'Profile' }],\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"After rehydration, it'll look something like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const state = {\n  type: 'stack',\n  key: 'stack-1',\n  routeNames: ['Home', 'Profile', 'Settings'],\n  routes: [\n    { key: 'home-1', name: 'Home' },\n    { key: 'settings-1', name: 'Settings' },\n  ],\n  index: 1,\n  stale: false,\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here, React Navigation filled in the missing bits such as keys, route names, index etc."}),"\n",(0,i.jsxs)(t.p,{children:["It's also possible to provide invalid data such as non-existent screens and it'll be fixed automatically. While it's not recommended to write code with invalid state objects, it can be super useful if you do things like ",(0,i.jsx)(t.a,{href:"/docs/8.x/state-persistence",children:"state persistence"}),", where the configured screens might have changed after an update, which could cause problems if React Navigation didn't fix the state object automatically."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["If you want React Navigation to fix invalid state, you need to make sure that you don't have ",(0,i.jsx)(t.code,{children:"stale: false"})," in the state object. State objects with ",(0,i.jsx)(t.code,{children:"stale: false"})," are assumed to be valid state objects and React Navigation won't attempt to fix them."]})}),"\n",(0,i.jsxs)(t.p,{children:["When you're providing a state object in ",(0,i.jsx)(t.a,{href:"/docs/8.x/navigation-container#initialstate",children:(0,i.jsx)(t.code,{children:"initialState"})}),", React Navigation will always assume that it's a stale state object, since navigation configuration may have changed since the last time. This makes sure that things like ",(0,i.jsx)(t.a,{href:"/docs/8.x/state-persistence",children:"state persistence"})," work smoothly without extra manipulation of the state object."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(96540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);