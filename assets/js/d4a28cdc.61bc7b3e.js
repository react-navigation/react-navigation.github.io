"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[54498],{29506:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"typescript","title":"Type checking with TypeScript","description":"React Navigation is written with TypeScript and exports type definitions for TypeScript projects.","source":"@site/versioned_docs/version-5.x/typescript.md","sourceDirName":".","slug":"/typescript","permalink":"/docs/5.x/typescript","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-5.x/typescript.md","tags":[],"version":"5.x","frontMatter":{"id":"typescript","title":"Type checking with TypeScript","sidebar_label":"Type checking with TypeScript"},"sidebar":"docs","previous":{"title":"Testing with Jest","permalink":"/docs/5.x/testing"},"next":{"title":"Redux integration","permalink":"/docs/5.x/redux-integration"}}');var o=t(74848),i=t(28453);const r={id:"typescript",title:"Type checking with TypeScript",sidebar_label:"Type checking with TypeScript",rawMarkdown:"---\nid: typescript\ntitle: Type checking with TypeScript\nsidebar_label: Type checking with TypeScript\n---\n\nReact Navigation is written with TypeScript and exports type definitions for TypeScript projects.\n\n## Type checking the navigator\n\nTo type check our route name and params, the first thing we need to do is to create an object type with mappings for route name to the params of the route. For example, say we have a route called `Profile` in our root navigator which should have a param `userId`:\n\n```tsx\ntype RootStackParamList = {\n  Profile: { userId: string };\n};\n```\n\nSimilarly, we need to do the same for each route:\n\n```tsx\ntype RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Feed: { sort: 'latest' | 'top' } | undefined;\n};\n```\n\nSpecifying `undefined` means that the route doesn't have params. A union type with `undefined` (e.g. `SomeType | undefined`) means that params are optional.\n\nAfter we have defined the mappings, we need to tell our navigator to use it. To do that, we can pass it as a generic to the `createXNavigator` functions:\n\n```tsx\nimport { createStackNavigator } from '@react-navigation/stack';\n\nconst RootStack = createStackNavigator<RootStackParamList>();\n```\n\nAnd then we can use it:\n\n```tsx\n<RootStack.Navigator initialRouteName=\"Home\">\n  <RootStack.Screen name=\"Home\" component={Home} />\n  <RootStack.Screen\n    name=\"Profile\"\n    component={Profile}\n    initialParams={{ userId: user.id }}\n  />\n  <RootStack.Screen name=\"Feed\" component={Feed} />\n</RootStack.Navigator>\n```\n\nThis will provide type checking and intelliSense for props of the `Navigator` and `Screen` components.\n\n## Type checking screens\n\nTo type check our screens, we need to annotate the `navigation` prop and the `route` prop received by a screen.\n\nTo annotate the `navigation` prop, we need to import the corresponding type from the navigator. For example, `StackNavigationProp` for `@react-navigation/stack`:\n\n```tsx\nimport { StackNavigationProp } from '@react-navigation/stack';\n\ntype ProfileScreenNavigationProp = StackNavigationProp<\n  RootStackParamList,\n  'Profile'\n>;\n\ntype Props = {\n  navigation: ProfileScreenNavigationProp;\n};\n```\n\nThe type for the navigation prop takes 2 generics, the param list object we defined earlier, and the name of the current route. This allows us to type check route names and params which you're navigating using `navigate`, `push` etc. The name of the current route is necessary to type check the params when you call `setParams`.\n\nSimilarly, you can import `DrawerNavigationProp` from `@react-navigation/drawer`, `BottomTabNavigationProp` from `@react-navigation/bottom-tabs` etc.\n\nTo annotate the `route` prop, we need to use the `RouteProp` type from `@react-navigation/native`:\n\n```tsx\nimport { RouteProp } from '@react-navigation/native';\n\ntype ProfileScreenRouteProp = RouteProp<RootStackParamList, 'Profile'>;\n\ntype Props = {\n  route: ProfileScreenRouteProp;\n};\n```\n\nThis allows us to type check the route object, such as `route.params`.\n\nTo summarize:\n\n```tsx\nimport { RouteProp } from '@react-navigation/native';\nimport { StackNavigationProp } from '@react-navigation/stack';\n\ntype RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Feed: { sort: 'latest' | 'top' } | undefined;\n};\n\ntype ProfileScreenRouteProp = RouteProp<RootStackParamList, 'Profile'>;\n\ntype ProfileScreenNavigationProp = StackNavigationProp<\n  RootStackParamList,\n  'Profile'\n>;\n\ntype Props = {\n  route: ProfileScreenRouteProp;\n  navigation: ProfileScreenNavigationProp;\n};\n```\n\nAlternatively, you can also import a generic type to define types for both the `navigation` and `route` props from the corresponding navigator:\n\n```tsx\nimport { StackScreenProps } from '@react-navigation/stack';\n\ntype RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Feed: { sort: 'latest' | 'top' } | undefined;\n};\n\ntype Props = StackScreenProps<RootStackParamList, 'Profile'>;\n```\n\nSimilarly, you can import `DrawerScreenProps` from `@react-navigation/drawer`, `BottomTabScreenProps` from `@react-navigation/bottom-tabs` etc.\n\nThen you can use the `Props` type to annotate your component.\n\nFor function components:\n\n```tsx\nfunction ProfileScreen({ route, navigation }: Props) {\n  // ...\n}\n```\n\nFor class components:\n\n```ts\nclass ProfileScreen extends React.Component<Props> {\n  render() {\n    // ...\n  }\n}\n```\n\nWe recommend creating a separate `types.tsx` file where you keep the types and import them in your component files instead of repeating them in each file.\n\n## Nesting navigators\n\n### Type checking screens and params in nested navigator\n\nYou can [navigate to a screen in a nested navigator](nesting-navigators.md#navigating-to-a-screen-in-a-nested-navigator) by passing `screen` and `params` properties for the nested screen:\n\n```ts\nnavigation.navigate('Home', {\n  screen: 'Feed',\n  params: { sort: 'latest' },\n});\n```\n\nTo be able to type check this, we need to extract the params from the screen containing the nested navigator. This can be done using the `NavigatorScreenParams` utility:\n\n```ts\nimport { NavigatorScreenParams } from '@react-navigation/native';\n\ntype TabParamList = {\n  Home: NavigatorScreenParams<StackParamList>;\n  Profile: { userId: string };\n};\n```\n\n### Combining navigation props\n\nWhen you nest navigators, the navigation prop of the screen is a combination of multiple navigation props. For example, if we have a tab inside a stack, the `navigation` prop will have both `jumpTo` (from the tab navigator) and `push` (from the stack navigator). To make it easier to combine types from multiple navigator, you can use the `CompositeNavigationProp` type:\n\n```ts\nimport { CompositeNavigationProp } from '@react-navigation/native';\nimport { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';\nimport { StackNavigationProp } from '@react-navigation/stack';\n\ntype ProfileScreenNavigationProp = CompositeNavigationProp<\n  BottomTabNavigationProp<TabParamList, 'Profile'>,\n  StackNavigationProp<StackParamList>\n>;\n```\n\nThe `CompositeNavigationProp` type takes 2 parameters, first parameter is the primary navigation type (type for the navigator that owns this screen, in our case the tab navigator which contains the `Profile` screen) and second parameter is the secondary navigation type (type for a parent navigator). The primary navigation type should always have the screen's route name as its second parameter.\n\nFor multiple parent navigators, this secondary type should be nested:\n\n```ts\ntype ProfileScreenNavigationProp = CompositeNavigationProp<\n  BottomTabNavigationProp<TabParamList, 'Profile'>,\n  CompositeNavigationProp<\n    StackNavigationProp<StackParamList>,\n    DrawerNavigationProp<DrawerParamList>\n  >\n>;\n```\n\n## Annotating `useNavigation`\n\nTo annotate the `navigation` prop that we get from `useNavigation`, we can use a type parameter:\n\n```ts\nconst navigation = useNavigation<ProfileScreenNavigationProp>();\n```\n\nIt's important to note that this isn't completely type-safe because the type parameter you use may not be correct and we cannot statically verify it.\n\n## Annotating `useRoute`\n\nTo annotate the `route` prop that we get from `useRoute`, we can use a type parameter:\n\n```ts\nconst route = useRoute<ProfileScreenRouteProp>();\n```\n\nIt's important to note that this isn't completely type-safe, similar to `useNavigation`.\n\n## Annotating `options` and `screenOptions`\n\nWhen you pass the `options` to a `Screen` or `screenOptions` prop to a `Navigator` component, they are already type-checked and you don't need to do anything special. However, sometimes you might want to extract the options to a separate object, and you might want to annotate it.\n\nTo annotate the options, we need to import the corresponding type from the navigator. For example, `StackNavigationOptions` for `@react-navigation/stack`:\n\n```ts\nimport { StackNavigationOptions } from '@react-navigation/stack';\n\nconst options: StackNavigationOptions = {\n  headerShown: false,\n};\n```\n\nSimilarly, you can import `DrawerNavigationOptions` from `@react-navigation/drawer`, `BottomTabNavigationOptions` from `@react-navigation/bottom-tabs` etc.\n\n## Annotating `ref` on `NavigationContainer`\n\nWhen adding a `ref` to `NavigationContainer`, you can use the `NavigationContainerRef` type to annotate it.\n\nExample when using `React.useRef` hook:\n\n```ts\nimport { NavigationContainerRef } from '@react-navigation/native';\n\n// ...\n\nconst navigationRef = React.useRef<NavigationContainerRef>(null);\n```\n\nExample when using `React.createRef`:\n\n```ts\nimport { NavigationContainerRef } from '@react-navigation/native';\n\n// ...\n\nconst navigationRef = React.createRef<NavigationContainerRef>();\n```\n"},s=void 0,c={},p=[{value:"Type checking the navigator",id:"type-checking-the-navigator",level:2},{value:"Type checking screens",id:"type-checking-screens",level:2},{value:"Nesting navigators",id:"nesting-navigators",level:2},{value:"Type checking screens and params in nested navigator",id:"type-checking-screens-and-params-in-nested-navigator",level:3},{value:"Combining navigation props",id:"combining-navigation-props",level:3},{value:"Annotating <code>useNavigation</code>",id:"annotating-usenavigation",level:2},{value:"Annotating <code>useRoute</code>",id:"annotating-useroute",level:2},{value:"Annotating <code>options</code> and <code>screenOptions</code>",id:"annotating-options-and-screenoptions",level:2},{value:"Annotating <code>ref</code> on <code>NavigationContainer</code>",id:"annotating-ref-on-navigationcontainer",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"React Navigation is written with TypeScript and exports type definitions for TypeScript projects."}),"\n",(0,o.jsx)(n.h2,{id:"type-checking-the-navigator",children:"Type checking the navigator"}),"\n",(0,o.jsxs)(n.p,{children:["To type check our route name and params, the first thing we need to do is to create an object type with mappings for route name to the params of the route. For example, say we have a route called ",(0,o.jsx)(n.code,{children:"Profile"})," in our root navigator which should have a param ",(0,o.jsx)(n.code,{children:"userId"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"type RootStackParamList = {\n  Profile: { userId: string };\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"Similarly, we need to do the same for each route:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"type RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Feed: { sort: 'latest' | 'top' } | undefined;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Specifying ",(0,o.jsx)(n.code,{children:"undefined"})," means that the route doesn't have params. A union type with ",(0,o.jsx)(n.code,{children:"undefined"})," (e.g. ",(0,o.jsx)(n.code,{children:"SomeType | undefined"}),") means that params are optional."]}),"\n",(0,o.jsxs)(n.p,{children:["After we have defined the mappings, we need to tell our navigator to use it. To do that, we can pass it as a generic to the ",(0,o.jsx)(n.code,{children:"createXNavigator"})," functions:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { createStackNavigator } from '@react-navigation/stack';\n\nconst RootStack = createStackNavigator<RootStackParamList>();\n"})}),"\n",(0,o.jsx)(n.p,{children:"And then we can use it:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'<RootStack.Navigator initialRouteName="Home">\n  <RootStack.Screen name="Home" component={Home} />\n  <RootStack.Screen\n    name="Profile"\n    component={Profile}\n    initialParams={{ userId: user.id }}\n  />\n  <RootStack.Screen name="Feed" component={Feed} />\n</RootStack.Navigator>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This will provide type checking and intelliSense for props of the ",(0,o.jsx)(n.code,{children:"Navigator"})," and ",(0,o.jsx)(n.code,{children:"Screen"})," components."]}),"\n",(0,o.jsx)(n.h2,{id:"type-checking-screens",children:"Type checking screens"}),"\n",(0,o.jsxs)(n.p,{children:["To type check our screens, we need to annotate the ",(0,o.jsx)(n.code,{children:"navigation"})," prop and the ",(0,o.jsx)(n.code,{children:"route"})," prop received by a screen."]}),"\n",(0,o.jsxs)(n.p,{children:["To annotate the ",(0,o.jsx)(n.code,{children:"navigation"})," prop, we need to import the corresponding type from the navigator. For example, ",(0,o.jsx)(n.code,{children:"StackNavigationProp"})," for ",(0,o.jsx)(n.code,{children:"@react-navigation/stack"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { StackNavigationProp } from '@react-navigation/stack';\n\ntype ProfileScreenNavigationProp = StackNavigationProp<\n  RootStackParamList,\n  'Profile'\n>;\n\ntype Props = {\n  navigation: ProfileScreenNavigationProp;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The type for the navigation prop takes 2 generics, the param list object we defined earlier, and the name of the current route. This allows us to type check route names and params which you're navigating using ",(0,o.jsx)(n.code,{children:"navigate"}),", ",(0,o.jsx)(n.code,{children:"push"})," etc. The name of the current route is necessary to type check the params when you call ",(0,o.jsx)(n.code,{children:"setParams"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Similarly, you can import ",(0,o.jsx)(n.code,{children:"DrawerNavigationProp"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/drawer"}),", ",(0,o.jsx)(n.code,{children:"BottomTabNavigationProp"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs"})," etc."]}),"\n",(0,o.jsxs)(n.p,{children:["To annotate the ",(0,o.jsx)(n.code,{children:"route"})," prop, we need to use the ",(0,o.jsx)(n.code,{children:"RouteProp"})," type from ",(0,o.jsx)(n.code,{children:"@react-navigation/native"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { RouteProp } from '@react-navigation/native';\n\ntype ProfileScreenRouteProp = RouteProp<RootStackParamList, 'Profile'>;\n\ntype Props = {\n  route: ProfileScreenRouteProp;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This allows us to type check the route object, such as ",(0,o.jsx)(n.code,{children:"route.params"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"To summarize:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { RouteProp } from '@react-navigation/native';\nimport { StackNavigationProp } from '@react-navigation/stack';\n\ntype RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Feed: { sort: 'latest' | 'top' } | undefined;\n};\n\ntype ProfileScreenRouteProp = RouteProp<RootStackParamList, 'Profile'>;\n\ntype ProfileScreenNavigationProp = StackNavigationProp<\n  RootStackParamList,\n  'Profile'\n>;\n\ntype Props = {\n  route: ProfileScreenRouteProp;\n  navigation: ProfileScreenNavigationProp;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Alternatively, you can also import a generic type to define types for both the ",(0,o.jsx)(n.code,{children:"navigation"})," and ",(0,o.jsx)(n.code,{children:"route"})," props from the corresponding navigator:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { StackScreenProps } from '@react-navigation/stack';\n\ntype RootStackParamList = {\n  Home: undefined;\n  Profile: { userId: string };\n  Feed: { sort: 'latest' | 'top' } | undefined;\n};\n\ntype Props = StackScreenProps<RootStackParamList, 'Profile'>;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Similarly, you can import ",(0,o.jsx)(n.code,{children:"DrawerScreenProps"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/drawer"}),", ",(0,o.jsx)(n.code,{children:"BottomTabScreenProps"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs"})," etc."]}),"\n",(0,o.jsxs)(n.p,{children:["Then you can use the ",(0,o.jsx)(n.code,{children:"Props"})," type to annotate your component."]}),"\n",(0,o.jsx)(n.p,{children:"For function components:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"function ProfileScreen({ route, navigation }: Props) {\n  // ...\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"For class components:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"class ProfileScreen extends React.Component<Props> {\n  render() {\n    // ...\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We recommend creating a separate ",(0,o.jsx)(n.code,{children:"types.tsx"})," file where you keep the types and import them in your component files instead of repeating them in each file."]}),"\n",(0,o.jsx)(n.h2,{id:"nesting-navigators",children:"Nesting navigators"}),"\n",(0,o.jsx)(n.h3,{id:"type-checking-screens-and-params-in-nested-navigator",children:"Type checking screens and params in nested navigator"}),"\n",(0,o.jsxs)(n.p,{children:["You can ",(0,o.jsx)(n.a,{href:"/docs/5.x/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator",children:"navigate to a screen in a nested navigator"})," by passing ",(0,o.jsx)(n.code,{children:"screen"})," and ",(0,o.jsx)(n.code,{children:"params"})," properties for the nested screen:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"navigation.navigate('Home', {\n  screen: 'Feed',\n  params: { sort: 'latest' },\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To be able to type check this, we need to extract the params from the screen containing the nested navigator. This can be done using the ",(0,o.jsx)(n.code,{children:"NavigatorScreenParams"})," utility:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { NavigatorScreenParams } from '@react-navigation/native';\n\ntype TabParamList = {\n  Home: NavigatorScreenParams<StackParamList>;\n  Profile: { userId: string };\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"combining-navigation-props",children:"Combining navigation props"}),"\n",(0,o.jsxs)(n.p,{children:["When you nest navigators, the navigation prop of the screen is a combination of multiple navigation props. For example, if we have a tab inside a stack, the ",(0,o.jsx)(n.code,{children:"navigation"})," prop will have both ",(0,o.jsx)(n.code,{children:"jumpTo"})," (from the tab navigator) and ",(0,o.jsx)(n.code,{children:"push"})," (from the stack navigator). To make it easier to combine types from multiple navigator, you can use the ",(0,o.jsx)(n.code,{children:"CompositeNavigationProp"})," type:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { CompositeNavigationProp } from '@react-navigation/native';\nimport { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';\nimport { StackNavigationProp } from '@react-navigation/stack';\n\ntype ProfileScreenNavigationProp = CompositeNavigationProp<\n  BottomTabNavigationProp<TabParamList, 'Profile'>,\n  StackNavigationProp<StackParamList>\n>;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"CompositeNavigationProp"})," type takes 2 parameters, first parameter is the primary navigation type (type for the navigator that owns this screen, in our case the tab navigator which contains the ",(0,o.jsx)(n.code,{children:"Profile"})," screen) and second parameter is the secondary navigation type (type for a parent navigator). The primary navigation type should always have the screen's route name as its second parameter."]}),"\n",(0,o.jsx)(n.p,{children:"For multiple parent navigators, this secondary type should be nested:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"type ProfileScreenNavigationProp = CompositeNavigationProp<\n  BottomTabNavigationProp<TabParamList, 'Profile'>,\n  CompositeNavigationProp<\n    StackNavigationProp<StackParamList>,\n    DrawerNavigationProp<DrawerParamList>\n  >\n>;\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"annotating-usenavigation",children:["Annotating ",(0,o.jsx)(n.code,{children:"useNavigation"})]}),"\n",(0,o.jsxs)(n.p,{children:["To annotate the ",(0,o.jsx)(n.code,{children:"navigation"})," prop that we get from ",(0,o.jsx)(n.code,{children:"useNavigation"}),", we can use a type parameter:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const navigation = useNavigation<ProfileScreenNavigationProp>();\n"})}),"\n",(0,o.jsx)(n.p,{children:"It's important to note that this isn't completely type-safe because the type parameter you use may not be correct and we cannot statically verify it."}),"\n",(0,o.jsxs)(n.h2,{id:"annotating-useroute",children:["Annotating ",(0,o.jsx)(n.code,{children:"useRoute"})]}),"\n",(0,o.jsxs)(n.p,{children:["To annotate the ",(0,o.jsx)(n.code,{children:"route"})," prop that we get from ",(0,o.jsx)(n.code,{children:"useRoute"}),", we can use a type parameter:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const route = useRoute<ProfileScreenRouteProp>();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["It's important to note that this isn't completely type-safe, similar to ",(0,o.jsx)(n.code,{children:"useNavigation"}),"."]}),"\n",(0,o.jsxs)(n.h2,{id:"annotating-options-and-screenoptions",children:["Annotating ",(0,o.jsx)(n.code,{children:"options"})," and ",(0,o.jsx)(n.code,{children:"screenOptions"})]}),"\n",(0,o.jsxs)(n.p,{children:["When you pass the ",(0,o.jsx)(n.code,{children:"options"})," to a ",(0,o.jsx)(n.code,{children:"Screen"})," or ",(0,o.jsx)(n.code,{children:"screenOptions"})," prop to a ",(0,o.jsx)(n.code,{children:"Navigator"})," component, they are already type-checked and you don't need to do anything special. However, sometimes you might want to extract the options to a separate object, and you might want to annotate it."]}),"\n",(0,o.jsxs)(n.p,{children:["To annotate the options, we need to import the corresponding type from the navigator. For example, ",(0,o.jsx)(n.code,{children:"StackNavigationOptions"})," for ",(0,o.jsx)(n.code,{children:"@react-navigation/stack"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { StackNavigationOptions } from '@react-navigation/stack';\n\nconst options: StackNavigationOptions = {\n  headerShown: false,\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Similarly, you can import ",(0,o.jsx)(n.code,{children:"DrawerNavigationOptions"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/drawer"}),", ",(0,o.jsx)(n.code,{children:"BottomTabNavigationOptions"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs"})," etc."]}),"\n",(0,o.jsxs)(n.h2,{id:"annotating-ref-on-navigationcontainer",children:["Annotating ",(0,o.jsx)(n.code,{children:"ref"})," on ",(0,o.jsx)(n.code,{children:"NavigationContainer"})]}),"\n",(0,o.jsxs)(n.p,{children:["When adding a ",(0,o.jsx)(n.code,{children:"ref"})," to ",(0,o.jsx)(n.code,{children:"NavigationContainer"}),", you can use the ",(0,o.jsx)(n.code,{children:"NavigationContainerRef"})," type to annotate it."]}),"\n",(0,o.jsxs)(n.p,{children:["Example when using ",(0,o.jsx)(n.code,{children:"React.useRef"})," hook:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { NavigationContainerRef } from '@react-navigation/native';\n\n// ...\n\nconst navigationRef = React.useRef<NavigationContainerRef>(null);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Example when using ",(0,o.jsx)(n.code,{children:"React.createRef"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { NavigationContainerRef } from '@react-navigation/native';\n\n// ...\n\nconst navigationRef = React.createRef<NavigationContainerRef>();\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(96540);const o={},i=a.createContext(o);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);