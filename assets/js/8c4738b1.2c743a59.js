"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[7989],{72708:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>h,default:()=>u,frontMatter:()=>l,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"configuring-links","title":"Configuring links","description":"In this guide, we will configure React Navigation to handle external links. This is necessary if you want to:","source":"@site/versioned_docs/version-7.x/configuring-links.md","sourceDirName":".","slug":"/configuring-links","permalink":"/docs/configuring-links","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/configuring-links.md","tags":[],"version":"7.x","frontMatter":{"id":"configuring-links","title":"Configuring links","sidebar_label":"Configuring links"},"sidebar":"docs","previous":{"title":"Deep linking","permalink":"/docs/deep-linking"},"next":{"title":"State persistence","permalink":"/docs/state-persistence"}}');var i=t(74848),s=t(28453),r=t(11470),o=t(19365),c=t(29571);const l={id:"configuring-links",title:"Configuring links",sidebar_label:"Configuring links",rawMarkdown:"---\nid: configuring-links\ntitle: Configuring links\nsidebar_label: Configuring links\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\nIn this guide, we will configure React Navigation to handle external links. This is necessary if you want to:\n\n1. Handle deep links in React Native apps on Android and iOS\n2. Enable URL integration in browser when using on web\n3. Use [`<Link />`](link.md) or [`useLinkTo`](use-link-to.md) to navigate using paths.\n\nMake sure that you have [configured deep links](deep-linking.md) in your app before proceeding. If you have an Android or iOS app, remember to specify the [`prefixes`](navigation-container.md#linkingprefixes) option.\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\nThe [`Navigation`](static-configuration.md#createstaticnavigation) component accepts a [`linking`](static-configuration.md#differences-in-the-linking-prop) prop that makes it easier to handle incoming links:\n\n```js\nimport { createStaticNavigation } from '@react-navigation/native';\n\n// highlight-start\nconst linking = {\n  enabled: 'auto' /* Automatically generate paths for all screens */,\n  prefixes: [\n    /* your linking prefixes */\n  ],\n};\n// highlight-end\n\nfunction App() {\n  return (\n    <Navigation\n      // highlight-next-line\n      linking={linking}\n      fallback={<Text>Loading...</Text>}\n    />\n  );\n}\n\nconst Navigation = createStaticNavigation(RootStack);\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\nThe `NavigationContainer` accepts a [`linking`](navigation-container.md#linking) prop that makes it easier to handle incoming links. The 2 of the most important properties you can specify in the `linking` prop are `prefixes` and `config`:\n\n```js\nimport { NavigationContainer } from '@react-navigation/native';\n\n// highlight-start\nconst linking = {\n  prefixes: [\n    /* your linking prefixes */\n  ],\n  config: {\n    /* configuration for matching screens with paths */\n  },\n};\n// highlight-end\n\nfunction App() {\n  return (\n    <NavigationContainer\n      // highlight-next-line\n      linking={linking}\n      fallback={<Text>Loading...</Text>}\n    >\n      {/* content */}\n    </NavigationContainer>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\nWhen you specify the `linking` prop, React Navigation will handle incoming links automatically. On Android and iOS, it'll use React Native's [`Linking` module](https://reactnative.dev/docs/linking) to handle incoming links, both when the app was opened with the link, and when new links are received when the app is open. On the Web, it'll use the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to sync the URL with the browser.\n\n:::warning\n\nCurrently there seems to be bug ([facebook/react-native#25675](https://github.com/facebook/react-native/issues/25675)) which results in it never resolving on Android. We add a timeout to avoid getting stuck forever, but it means that the link might not be handled in some cases.\n\n:::\n\nYou can also pass a [`fallback`](navigation-container.md#fallback) prop that controls what's displayed when React Navigation is trying to resolve the initial deep link URL.\n\n## Prefixes\n\nThe `prefixes` option can be used to specify custom schemes (e.g. `example://`) as well as host & domain names (e.g. `https://example.com`) if you have configured [Universal Links](https://developer.apple.com/ios/universal-links/) or [Android App Links](https://developer.android.com/training/app-links).\n\nFor example:\n\n```js\nconst linking = {\n  prefixes: ['example://', 'https://example.com'],\n};\n```\n\nNote that the `prefixes` option is not supported on Web. The host & domain names will be automatically determined from the Website URL in the browser. If your app runs only on Web, then you can omit this option from the config.\n\n### Multiple subdomains\u200b\n\nTo match all subdomains of an associated domain, you can specify a wildcard by prefixing `*`. before the beginning of a specific domain. Note that an entry for `*.example.com` does not match `example.com` because of the period after the asterisk. To enable matching for both `*.example.com` and `example.com`, you need to provide a separate prefix entry for each.\n\n```js\nconst linking = {\n  prefixes: ['example://', 'https://example.com', 'https://*.example.com'],\n};\n```\n\n## Filtering certain paths\n\nSometimes we may not want to handle all incoming links. For example, we may want to filter out links meant for authentication (e.g. `expo-auth-session`) or other purposes instead of navigating to a specific screen.\n\nTo achieve this, you can use the `filter` option:\n\n```js\nconst linking = {\n  prefixes: ['example://', 'https://example.com'],\n  // highlight-next-line\n  filter: (url) => !url.includes('+expo-auth-session'),\n};\n```\n\nThis is not supported on Web as we always need to handle the URL of the page.\n\n## Apps under subpaths\n\nIf your app is hosted under a subpath, you can specify the subpath at the top-level of the `config`. For example, if your app is hosted at `https://example.com/app`, you can specify the `path` as `app`:\n\n```js\nconst linking = {\n  prefixes: ['example://', 'https://example.com'],\n  config: {\n    // highlight-next-line\n    path: 'app',\n\n    // ...\n  },\n};\n```\n\nIt's not possible to specify params here since this doesn't belong to a screen, e.g. `app/:id` won't work.\n\n## Mapping path to route names\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\nIf you specify `enabled: 'auto'` in the `linking` prop, React Navigation will automatically generate paths for all screens. For example, if you have a `Profile` screen in the navigator, it'll automatically generate a path for it as `profile`.\n\nIf you wish to handle the configuration manually, or want to override the generated path for a specific screen, you can specify `linking` property next to the screen in the navigator to map a path to a screen. For example:\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      linking: {\n        path: 'user',\n      },\n      // highlight-end\n    },\n    Chat: {\n      screen: ChatScreen,\n      // highlight-start\n      linking: {\n        path: 'feed/:sort',\n      },\n      // highlight-end\n    },\n  },\n});\n```\n\nIn this example:\n\n- `Chat` screen that handles the URL `/feed` with the param `sort` (e.g. `/feed/latest` - the `Chat` screen will receive a param `sort` with the value `latest`).\n- `Profile` screen that handles the URL `/user`.\n\nSimilarly, when you have a nested navigator, you can specify the `linking` property for the screens in the navigator to handle the path for the nested screens:\n\n```js\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n      // highlight-start\n      linking: {\n        path: 'home',\n      },\n      // highlight-end\n    },\n    Settings: {\n      screen: SettingsScreen,\n      // highlight-start\n      linking: {\n        path: 'settings',\n      },\n      // highlight-end\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    HomeTabs: {\n      screen: HomeTabs,\n    },\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      linking: {\n        path: 'user',\n      },\n      // highlight-end\n    },\n    Chat: {\n      screen: ChatScreen,\n      // highlight-start\n      linking: {\n        path: 'feed/:sort',\n      },\n      // highlight-end\n    },\n  },\n});\n```\n\nIn the above example, the following path formats are handled:\n\n- `/home` navigates to the `HomeTabs` -> `Home` screen\n- `/settings` navigates to the `HomeTabs` -> `Settings` screen\n- `/user` navigates to the `Profile` screen\n- `/feed/:sort` navigates to the `Chat` screen with the param `sort`\n\n### How does automatic path generation work?\n\nWhen using automatic path generation with `enabled: 'auto'`, the following rules are applied:\n\n- Screens with an explicit `linking` property are not used for path generation and will be added as-is.\n- Screen names will be converted from `PascalCase` to `kebab-case` to use as the path (e.g. `NewsFeed` -> `news-feed`).\n- Unless a screen has explicit empty path (`path: ''`) to use for the homepage, the first leaf screen encountered will be used as the homepage.\n- Path generation only handles leaf screens, i.e. no path is generated for screens containing nested navigators. It's still possible to specify a path for them with an explicit `linking` property.\n\nLet's say we have the following navigation structure:\n\n```js\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n    Settings: {\n      screen: SettingsScreen,\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    HomeTabs: {\n      screen: HomeTabs,\n    },\n    Profile: {\n      screen: ProfileScreen,\n    },\n    Chat: {\n      screen: ChatScreen,\n    },\n  },\n});\n```\n\nWith automatic path generation, the following paths will be generated:\n\n- `/` navigates to the `HomeTabs` -> `Home` screen\n- `/settings` navigates to the `HomeTabs` -> `Settings` screen\n- `/profile` navigates to the `Profile` screen\n- `/chat` navigates to the `Chat` screen\n\nIf the URL contains a query string, it'll be passed as params to the screen. For example, the URL `/profile?user=jane` will pass the `user` param to the `Profile` screen.\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\nIf you specify a `linking` option, by default React Navigation will use the path segments as the route name when parsing the URL. However, directly translating path segments to route names may not be the expected behavior.\n\nYou can specify the [`config`](navigation-container.md#linkingconfig) option in `linking` to control how the deep link is parsed to suit your needs. The config should specify the mapping between route names and path patterns:\n\n```js\nconst config = {\n  screens: {\n    Chat: 'feed/:sort',\n    Profile: 'user',\n  },\n};\n```\n\nIn this example:\n\n- `Chat` screen that handles the URL `/feed` with the param `sort` (e.g. `/feed/latest` - the `Chat` screen will receive a param `sort` with the value `latest`).\n- `Profile` screen that handles the URL `/user`.\n\nThe config option can then be passed in the `linking` prop to the container:\n\n```js\nimport { NavigationContainer } from '@react-navigation/native';\n\nconst config = {\n  screens: {\n    Chat: 'feed/:sort',\n    Profile: 'user',\n  },\n};\n\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n  config,\n};\n\nfunction App() {\n  return (\n    <NavigationContainer linking={linking} fallback={<Text>Loading...</Text>}>\n      {/* content */}\n    </NavigationContainer>\n  );\n}\n```\n\nThe config object must match the navigation structure for your app. For example, the above configuration is if you have `Chat` and `Profile` screens in the navigator at the root:\n\n```js\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name=\"Chat\" component={ChatScreen} />\n      <Stack.Screen name=\"Profile\" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n```\n\nIf your `Chat` screen is inside a nested navigator, we'd need to account for that. For example, consider the following structure where your `Profile` screen is at the root, but the `Chat` screen is nested inside `Home`:\n\n```js\nfunction App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name=\"Home\" component={HomeScreen} />\n      <Stack.Screen name=\"Profile\" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n\nfunction HomeScreen() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name=\"Chat\" component={ChatScreen} />\n    </Tab.Navigator>\n  );\n}\n```\n\nFor the above structure, our configuration will look like this:\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      screens: {\n        Chat: 'feed/:sort',\n      },\n    },\n    Profile: 'user',\n  },\n};\n```\n\nSimilarly, any nesting needs to be reflected in the configuration.\n</TabItem>\n</Tabs>\n\n<details>\n<summary>How it works</summary>\n\nThe linking works by translating the URL to a valid [navigation state](navigation-state.md) and vice versa using the configuration provided. For example, the path `/rooms/chat?user=jane` may be translated to a state object like this:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'rooms',\n      state: {\n        routes: [\n          {\n            name: 'chat',\n            params: { user: 'jane' },\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\nFor example, you might want to parse the path `/feed/latest` to something like:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Chat',\n      params: {\n        sort: 'latest',\n      },\n    },\n  ];\n}\n```\n\nSee [Navigation State reference](navigation-state.md) for more details on how the state object is structured.\n\n</details>\n\n## Passing params\n\nA common use case is to pass params to a screen to pass some data. For example, you may want the `Profile` screen to have an `id` param to know which user's profile it is. It's possible to pass params to a screen through a URL when handling deep links.\n\nBy default, query params are parsed to get the params for a screen. For example, with the above example, the URL `/user?id=jane` will pass the `id` param to the `Profile` screen.\n\nYou can also customize how the params are parsed from the URL. Let's say you want the URL to look like `/user/jane` where the `id` param is `jane` instead of having the `id` in query params. You can do this by specifying `user/:id` for the `path`. **When the path segment starts with `:`, it'll be treated as a param**. For example, the URL `/user/jane` would resolve to `Profile` screen with the string `jane` as a value of the `id` param and will be available in `route.params.id` in `Profile` screen.\n\nBy default, all params are treated as strings. You can also customize how to parse them by specifying a function in the `parse` property to parse the param, and a function in the `stringify` property to convert it back to a string.\n\nIf you wanted to resolve `/user/@jane/settings` to result in the params `{ id: 'jane' section: 'settings' }`, you could make `Profile`'s config to look like this:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      linking: {\n        path: 'user/:id/:section',\n        parse: {\n          id: (id) => id.replace(/^@/, ''),\n        },\n        stringify: {\n          id: (id) => `@${id}`,\n        },\n      },\n      // highlight-end\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Profile: {\n      // highlight-start\n      path: 'user/:id/:section',\n      parse: {\n        id: (id) => id.replace(/^@/, ''),\n      },\n      stringify: {\n        id: (id) => `@${id}`,\n      },\n      // highlight-end\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\n<details>\n<summary>Result Navigation State</summary>\n\nWith this configuration, the path `/user/@jane/settings` will resolve to the following state object:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'jane', section: 'settings' },\n    },\n  ],\n};\n```\n\n</details>\n\n## Marking params as optional\n\nSometimes a param may or may not be present in the URL depending on certain conditions. For example, in the above scenario, you may not always have the section parameter in the URL, i.e. both `/user/jane/settings` and `/user/jane` should go to the `Profile` screen, but the `section` param (with the value `settings` in this case) may or may not be present.\n\nIn this case, you would need to mark the `section` param as optional. You can do it by adding the `?` suffix after the param name:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      linking: {\n        // highlight-next-line\n        path: 'user/:id/:section?',\n        parse: {\n          id: (id) => `user-${id}`,\n        },\n        stringify: {\n          id: (id) => id.replace(/^user-/, ''),\n        },\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Profile: {\n      // highlight-next-line\n      path: 'user/:id/:section?',\n      parse: {\n        id: (id) => `user-${id}`,\n      },\n      stringify: {\n        id: (id) => id.replace(/^user-/, ''),\n      },\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\n<details>\n<summary>Result Navigation State</summary>\n\nWith this configuration, the path `/user/jane` will resolve to the following state object:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-jane' },\n    },\n  ],\n};\n```\n\nIf the URL contains a `section` param (e.g. `/user/jane/settings`), this will result in the following with the same config:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-jane', section: 'settings' },\n    },\n  ],\n};\n```\n\n</details>\n\n## Handling unmatched routes or 404\n\nIf your app is opened with an invalid URL, most of the times you'd want to show an error page with some information. On the web, this is commonly known as 404 - or page not found error.\n\nTo handle this, you'll need to define a catch-all route that will be rendered if no other routes match the path. You can do it by specifying `*` for the path matching pattern:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: {\n      screen: FeedScreen,\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n    Settings: {\n      screen: SettingsScreen,\n      linking: {\n        path: 'settings',\n      },\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeTabs,\n    },\n    NotFound: {\n      screen: NotFoundScreen,\n      linking: {\n        // highlight-next-line\n        path: '*',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: 'settings',\n      },\n    },\n    NotFound: {\n      // highlight-start\n      path: '*',\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nHere, we have defined a route named `NotFound` and set it to match `*` aka everything. If the path didn't match `user/:id` or `settings`, it'll be matched by this route.\n\n<details>\n<summary>Result Navigation State</summary>\n\nWith this configuration, a path like `/library` or `/settings/notification` will resolve to the following state object:\n\n```js\nconst state = {\n  routes: [{ name: 'NotFound' }],\n};\n```\n\n</details>\n\nYou can even go more specific, for example, say if you want to show a different screen for invalid paths under `/settings`, you can specify such a pattern under `Settings`:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst SettingsStack = createStackNavigator({\n  screens: {\n    UserSettings: {\n      screen: UserSettingsScreen,\n      linking: {\n        path: 'user-settings',\n      },\n    },\n    InvalidSettings: {\n      screen: InvalidSettingsScreen,\n      linking: {\n        // highlight-next-line\n        path: '*',\n      },\n    },\n  },\n});\n\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: {\n      screen: FeedScreen,\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n    Settings: {\n      screen: SettingsStack,\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeTabs,\n    },\n    NotFound: {\n      screen: NotFoundScreen,\n      linking: {\n        path: '*',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: {\n          path: 'settings',\n          screens: {\n            InvalidSettings: '*',\n          },\n        },\n      },\n    },\n    NotFound: '*',\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\n<details>\n<summary>Result Navigation State</summary>\n\nWith this configuration, the path `/settings/notification` will resolve to the following state object:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        index: 1,\n        routes: [\n          { name: 'Feed' },\n          {\n            name: 'Settings',\n            state: {\n              routes: [\n                { name: 'InvalidSettings', path: '/settings/notification' },\n              ],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\n</details>\n\nThe `route` passed to the `NotFound` screen will contain a `path` property which corresponds to the path that opened the page. If you need, you can use this property to customize what's shown in this screen, e.g. load the page in a `WebView`:\n\n```js\nfunction NotFoundScreen({ route }) {\n  if (route.path) {\n    return <WebView source={{ uri: `https://mywebsite.com/${route.path}` }} />;\n  }\n\n  return <Text>This screen doesn't exist!</Text>;\n}\n```\n\nWhen doing server rendering, you'd also want to return correct status code for 404 errors. See [server rendering docs](server-rendering.md#handling-404-or-other-status-codes) for a guide on how to handle it.\n\n## Rendering an initial route\n\nSometimes you want to ensure that a certain screen will always be present as the first screen in the navigator's state. You can use the `initialRouteName` property to specify the screen to use for the initial screen.\n\nIn the above example, if you want the `Feed` screen to be the initial route in the navigator under `Home`, your config will look like this:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: {\n      screen: FeedScreen,\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n    Settings: {\n      screen: SettingsScreen,\n      linking: {\n        path: 'settings',\n      },\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeTabs,\n      linking: {\n        // highlight-next-line\n        initialRouteName: 'Feed',\n      },\n    },\n    NotFound: {\n      screen: NotFoundScreen,\n      linking: {\n        path: '*',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      // highlight-next-line\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: 'settings',\n      },\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\n<details>\n<summary>Result Navigation State</summary>\n\nWith this configuration, the path `/users/42` will resolve to the following state object:\n\n```js\nconst state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        index: 1,\n        routes: [\n          { name: 'Feed' },\n          {\n            name: 'Profile',\n            params: { id: '42' },\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\n</details>\n\n:::warning\n\nThe `initialRouteName` will add the screen to React Navigation's state only. If your app is running on the Web, the browser's history will not contain this screen as the user has never visited it. So, if the user presses the browser's back button, it'll not go back to this screen.\n\n:::\n\nAnother thing to keep in mind is that it's not possible to pass params to the initial screen through the URL. So make sure that your initial route doesn't need any params or specify `initialParams` in the screen configuration to pass the required params.\n\nIn this case, any params in the URL are only passed to the `Profile` screen which matches the path pattern `users/:id`, and the `Feed` screen doesn't receive any params. If you want to have the same params in the `Feed` screen, you can specify a [custom `getStateFromPath` function](navigation-container.md#linkinggetstatefrompath) and copy those params.\n\nSimilarly, if you want to access params of a parent screen from a child screen, you can use [React Context](https://react.dev/reference/react/useContext) to expose them.\n\n## Matching exact paths\n\nBy default, paths defined for each screen are matched against the URL relative to their parent screen's path. Consider the following config:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst ProfileTabs = createBottomTabNavigator({\n  screens: {\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: ProfileTabs,\n      linking: {\n        path: 'feed',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: 'feed',\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nHere, you have a `path` property defined for the `Home` screen, as well as the child `Profile` screen. The profile screen specifies the path `users/:id`, but since it's nested inside a screen with the path `feed`, it'll try to match the pattern `feed/users/:id`.\n\nThis will result in the URL `/feed` navigating to `Home` screen, and `/feed/users/cal` navigating to the `Profile` screen.\n\nIn this case, it makes more sense to navigate to the `Profile` screen using a URL like `/users/cal`, rather than `/feed/users/cal`. To achieve this, you can override the relative matching behavior to `exact` matching:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst ProfileTabs = createBottomTabNavigator({\n  screens: {\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n        // highlight-next-line\n        exact: true,\n      },\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: ProfileTabs,\n      linking: {\n        path: 'feed',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: 'feed',\n      screens: {\n        Profile: {\n          path: 'users/:id',\n          // highlight-next-line\n          exact: true,\n        },\n      },\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nWith `exact` property set to `true`, `Profile` will ignore the parent screen's `path` config and you'll be able to navigate to `Profile` using a URL like `users/cal`.\n\n## Omitting a screen from path\n\nSometimes, you may not want to have the route name of a screen in the path. For example, let's say you have a `Home` screen and the following config. When the page is opened in the browser you'll get `/home` as the URL:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: ProfileScreen,\n      linking: {\n        path: 'home',\n      },\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: 'home',\n    },\n    Profile: 'users/:id',\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nBut it'll be nicer if the URL was just `/` when visiting the home screen.\n\nYou can specify an empty string as path or not specify a path at all, and React Navigation won't add the screen to the path (think of it like adding empty string to the path, which doesn't change anything):\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: ProfileScreen,\n      linking: {\n        path: '',\n      },\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Home: {\n      path: '',\n    },\n    Profile: 'users/:id',\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\n## Serializing and parsing params\n\nSince URLs are strings, any params you have for routes are also converted to strings when constructing the path.\n\nFor example, say you have the URL `/chat/1589842744264` with the following config:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Chat: {\n      screen: ChatScreen,\n      linking: {\n        path: 'chat/:date',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Chat: 'chat/:date',\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nWhen handling the URL, your params will look like this:\n\n```json\n{ \"date\": \"1589842744264\" }\n```\n\nHere, the `date` param was parsed as a string because React Navigation doesn't know that it's supposed to be a timestamp, and hence number. You can customize it by providing a custom function to use for parsing:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Chat: {\n      screen: ChatScreen,\n      linking: {\n        path: 'chat/:date',\n        parse: {\n          date: Number,\n        },\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Chat: {\n      path: 'chat/:date',\n      parse: {\n        date: Number,\n      },\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nYou can also provide a your own function to serialize the params. For example, let's say that you want to use a DD-MM-YYYY format in the path instead of a timestamp:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Chat: {\n      screen: ChatScreen,\n      linking: {\n        path: 'chat/:date',\n        parse: {\n          date: (date) => new Date(date).getTime(),\n        },\n        stringify: {\n          date: (date) => {\n            const d = new Date(date);\n\n            return d.getFullYear() + '-' + d.getMonth() + '-' + d.getDate();\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Chat: {\n      path: 'chat/:date',\n      parse: {\n        date: (date) => new Date(date).getTime(),\n      },\n      stringify: {\n        date: (date) => {\n          const d = new Date(date);\n\n          return d.getFullYear() + '-' + d.getMonth() + '-' + d.getDate();\n        },\n      },\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nDepending on your requirements, you can use this functionality to parse and stringify more complex data.\n\n## Matching regular expressions\n\nIf you need more complex matching logic, you can use regular expressions to match the path. For example, if you want to use the pattern `@username` to match a user's profile, you can use a regular expression to match the path. This allows you to have the same path pattern for multiple screens, but fine-tune the matching logic to be more specific for a particular screen.\n\nRegular expressions can be specified between parentheses `(` and `)` in the after a param name. For example:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Feed: {\n      screen: FeedScreen,\n      linking: {\n        path: ':sort(latest|popular)',\n      },\n    },\n    Profile: {\n      screen: ProfileScreen,\n      linking: {\n        path: ':username(@[A-Za-z0-9_]+)',\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Feed: ':sort(latest|popular)',\n    Profile: ':username(@[A-Za-z0-9_]+)',\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nThis will only match the path if it starts with `@` followed by alphanumeric characters or underscores. For example, the URL `/@jane` will match the `Profile` screen, but `/jane` won't.\n\nRegular expressions are intended to only match path segments, not the entire path. So avoid using `/`, `^`, `$`, etc. in the regular expressions.\n\n:::warning\n\nRegular expressions are an advanced feature. They cannot be validated to warn you about potential issues, so it's up to you to ensure that the regular expression is correct.\n\n:::\n\n## Alias for paths\n\nIf you want to have multiple paths for the same screen, you can use the `alias` property to specify an array of paths. This can be useful to keep backward compatibility with old URLs while transitioning to a new URL structure.\n\nFor example, if you want to match both `/users/:id` and `/:id` to the `Profile` screen, you can do this:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nconst RootStack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      linking: {\n        path: ':id',\n        alias: ['users/:id'],\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nconst config = {\n  screens: {\n    Profile: {\n      path: ':id',\n      alias: ['users/:id'],\n    },\n  },\n};\n```\n\n</TabItem>\n</Tabs>\n\nIn this case, when the URL is `/users/jane` or `/jane`, it'll match the `Profile` screen. The `path` is the primary pattern that will be used to generate the URL, e.g. when navigating to the `Profile` screen in the app on the Web. The patterns in `alias` will be ignored when generating URLs. The `alias` patterns are not used for matching any child screens in nested navigators.\n\nOn the web, if a screen containing an alias contains a nested navigator, the URL matching the alias will only be used to match the screen, and will be updated to the URL of the focused child screen once the app renders.\n\nEach item in the `alias` array can be a string matching the syntax of the `path` property, or an object with the following properties:\n\n- `path` (required) - The path pattern to match.\n- `exact` - Whether to match the path exactly. Defaults to `false`. See [Matching exact paths](#matching-exact-paths) for more details.\n- `parse` - Function to parse path segments into param values. See [Passing params](#passing-params) for more details.\n\n## Advanced cases\n\nFor some advanced cases, specifying the mapping may not be sufficient. To handle such cases, you can specify a custom function to parse the URL into a state object ([`getStateFromPath`](navigation-container.md#linkinggetstatefrompath)), and a custom function to serialize the state object into an URL ([`getPathFromState`](navigation-container.md#linkinggetpathfromstate)).\n\nExample:\n\n```js\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n  getStateFromPath(path, options) {\n    // Return a state object here\n    // You can also reuse the default logic by importing `getStateFromPath` from `@react-navigation/native`\n  },\n  getPathFromState(state, config) {\n    // Return a path string here\n    // You can also reuse the default logic by importing `getPathFromState` from `@react-navigation/native`\n  },\n\n  // ...\n};\n```\n\n## Playground\n\nimport LinkingTester from '@site/src/components/LinkingTester'\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\nPlayground is not available for static config.\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\nYou can play around with customizing the config and path below, and see how the path is parsed.\n\n<LinkingTester />\n\n</TabItem>\n</Tabs>\n"},h=void 0,d={},p=[{value:"Prefixes",id:"prefixes",level:2},{value:"Multiple subdomains\u200b",id:"multiple-subdomains",level:3},{value:"Filtering certain paths",id:"filtering-certain-paths",level:2},{value:"Apps under subpaths",id:"apps-under-subpaths",level:2},{value:"Mapping path to route names",id:"mapping-path-to-route-names",level:2},{value:"How does automatic path generation work?",id:"how-does-automatic-path-generation-work",level:3},{value:"Passing params",id:"passing-params",level:2},{value:"Marking params as optional",id:"marking-params-as-optional",level:2},{value:"Handling unmatched routes or 404",id:"handling-unmatched-routes-or-404",level:2},{value:"Rendering an initial route",id:"rendering-an-initial-route",level:2},{value:"Matching exact paths",id:"matching-exact-paths",level:2},{value:"Omitting a screen from path",id:"omitting-a-screen-from-path",level:2},{value:"Serializing and parsing params",id:"serializing-and-parsing-params",level:2},{value:"Matching regular expressions",id:"matching-regular-expressions",level:2},{value:"Alias for paths",id:"alias-for-paths",level:2},{value:"Advanced cases",id:"advanced-cases",level:2},{value:"Playground",id:"playground",level:2}];function g(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"In this guide, we will configure React Navigation to handle external links. This is necessary if you want to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Handle deep links in React Native apps on Android and iOS"}),"\n",(0,i.jsx)(n.li,{children:"Enable URL integration in browser when using on web"}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.a,{href:"/docs/link",children:(0,i.jsx)(n.code,{children:"<Link />"})})," or ",(0,i.jsx)(n.a,{href:"/docs/use-link-to",children:(0,i.jsx)(n.code,{children:"useLinkTo"})})," to navigate using paths."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Make sure that you have ",(0,i.jsx)(n.a,{href:"/docs/deep-linking",children:"configured deep links"})," in your app before proceeding. If you have an Android or iOS app, remember to specify the ",(0,i.jsx)(n.a,{href:"/docs/navigation-container#linkingprefixes",children:(0,i.jsx)(n.code,{children:"prefixes"})})," option."]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsxs)(o.A,{value:"static",label:"Static",default:!0,children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/docs/static-configuration#createstaticnavigation",children:(0,i.jsx)(n.code,{children:"Navigation"})})," component accepts a ",(0,i.jsx)(n.a,{href:"/docs/static-configuration#differences-in-the-linking-prop",children:(0,i.jsx)(n.code,{children:"linking"})})," prop that makes it easier to handle incoming links:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { createStaticNavigation } from '@react-navigation/native';\n\n// highlight-start\nconst linking = {\n  enabled: 'auto' /* Automatically generate paths for all screens */,\n  prefixes: [\n    /* your linking prefixes */\n  ],\n};\n// highlight-end\n\nfunction App() {\n  return (\n    <Navigation\n      // highlight-next-line\n      linking={linking}\n      fallback={<Text>Loading...</Text>}\n    />\n  );\n}\n\nconst Navigation = createStaticNavigation(RootStack);\n"})})]}),(0,i.jsxs)(o.A,{value:"dynamic",label:"Dynamic",children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"NavigationContainer"})," accepts a ",(0,i.jsx)(n.a,{href:"/docs/navigation-container#linking",children:(0,i.jsx)(n.code,{children:"linking"})})," prop that makes it easier to handle incoming links. The 2 of the most important properties you can specify in the ",(0,i.jsx)(n.code,{children:"linking"})," prop are ",(0,i.jsx)(n.code,{children:"prefixes"})," and ",(0,i.jsx)(n.code,{children:"config"}),":"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { NavigationContainer } from '@react-navigation/native';\n\n// highlight-start\nconst linking = {\n  prefixes: [\n    /* your linking prefixes */\n  ],\n  config: {\n    /* configuration for matching screens with paths */\n  },\n};\n// highlight-end\n\nfunction App() {\n  return (\n    <NavigationContainer\n      // highlight-next-line\n      linking={linking}\n      fallback={<Text>Loading...</Text>}\n    >\n      {/* content */}\n    </NavigationContainer>\n  );\n}\n"})})]})]}),"\n",(0,i.jsxs)(n.p,{children:["When you specify the ",(0,i.jsx)(n.code,{children:"linking"})," prop, React Navigation will handle incoming links automatically. On Android and iOS, it'll use React Native's ",(0,i.jsxs)(n.a,{href:"https://reactnative.dev/docs/linking",children:[(0,i.jsx)(n.code,{children:"Linking"})," module"]})," to handle incoming links, both when the app was opened with the link, and when new links are received when the app is open. On the Web, it'll use the ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/History_API",children:"History API"})," to sync the URL with the browser."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Currently there seems to be bug (",(0,i.jsx)(n.a,{href:"https://github.com/facebook/react-native/issues/25675",children:"facebook/react-native#25675"}),") which results in it never resolving on Android. We add a timeout to avoid getting stuck forever, but it means that the link might not be handled in some cases."]})}),"\n",(0,i.jsxs)(n.p,{children:["You can also pass a ",(0,i.jsx)(n.a,{href:"/docs/navigation-container#fallback",children:(0,i.jsx)(n.code,{children:"fallback"})})," prop that controls what's displayed when React Navigation is trying to resolve the initial deep link URL."]}),"\n",(0,i.jsx)(n.h2,{id:"prefixes",children:"Prefixes"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"prefixes"})," option can be used to specify custom schemes (e.g. ",(0,i.jsx)(n.code,{children:"example://"}),") as well as host & domain names (e.g. ",(0,i.jsx)(n.code,{children:"https://example.com"}),") if you have configured ",(0,i.jsx)(n.a,{href:"https://developer.apple.com/ios/universal-links/",children:"Universal Links"})," or ",(0,i.jsx)(n.a,{href:"https://developer.android.com/training/app-links",children:"Android App Links"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const linking = {\n  prefixes: ['example://', 'https://example.com'],\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that the ",(0,i.jsx)(n.code,{children:"prefixes"})," option is not supported on Web. The host & domain names will be automatically determined from the Website URL in the browser. If your app runs only on Web, then you can omit this option from the config."]}),"\n",(0,i.jsx)(n.h3,{id:"multiple-subdomains",children:"Multiple subdomains\u200b"}),"\n",(0,i.jsxs)(n.p,{children:["To match all subdomains of an associated domain, you can specify a wildcard by prefixing ",(0,i.jsx)(n.code,{children:"*"}),". before the beginning of a specific domain. Note that an entry for ",(0,i.jsx)(n.code,{children:"*.example.com"})," does not match ",(0,i.jsx)(n.code,{children:"example.com"})," because of the period after the asterisk. To enable matching for both ",(0,i.jsx)(n.code,{children:"*.example.com"})," and ",(0,i.jsx)(n.code,{children:"example.com"}),", you need to provide a separate prefix entry for each."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const linking = {\n  prefixes: ['example://', 'https://example.com', 'https://*.example.com'],\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"filtering-certain-paths",children:"Filtering certain paths"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes we may not want to handle all incoming links. For example, we may want to filter out links meant for authentication (e.g. ",(0,i.jsx)(n.code,{children:"expo-auth-session"}),") or other purposes instead of navigating to a specific screen."]}),"\n",(0,i.jsxs)(n.p,{children:["To achieve this, you can use the ",(0,i.jsx)(n.code,{children:"filter"})," option:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const linking = {\n  prefixes: ['example://', 'https://example.com'],\n  // highlight-next-line\n  filter: (url) => !url.includes('+expo-auth-session'),\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is not supported on Web as we always need to handle the URL of the page."}),"\n",(0,i.jsx)(n.h2,{id:"apps-under-subpaths",children:"Apps under subpaths"}),"\n",(0,i.jsxs)(n.p,{children:["If your app is hosted under a subpath, you can specify the subpath at the top-level of the ",(0,i.jsx)(n.code,{children:"config"}),". For example, if your app is hosted at ",(0,i.jsx)(n.code,{children:"https://example.com/app"}),", you can specify the ",(0,i.jsx)(n.code,{children:"path"})," as ",(0,i.jsx)(n.code,{children:"app"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const linking = {\n  prefixes: ['example://', 'https://example.com'],\n  config: {\n    // highlight-next-line\n    path: 'app',\n\n    // ...\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It's not possible to specify params here since this doesn't belong to a screen, e.g. ",(0,i.jsx)(n.code,{children:"app/:id"})," won't work."]}),"\n",(0,i.jsx)(n.h2,{id:"mapping-path-to-route-names",children:"Mapping path to route names"}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsxs)(o.A,{value:"static",label:"Static",default:!0,children:[(0,i.jsxs)(n.p,{children:["If you specify ",(0,i.jsx)(n.code,{children:"enabled: 'auto'"})," in the ",(0,i.jsx)(n.code,{children:"linking"})," prop, React Navigation will automatically generate paths for all screens. For example, if you have a ",(0,i.jsx)(n.code,{children:"Profile"})," screen in the navigator, it'll automatically generate a path for it as ",(0,i.jsx)(n.code,{children:"profile"}),"."]}),(0,i.jsxs)(n.p,{children:["If you wish to handle the configuration manually, or want to override the generated path for a specific screen, you can specify ",(0,i.jsx)(n.code,{children:"linking"})," property next to the screen in the navigator to map a path to a screen. For example:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      linking: {\n        path: 'user',\n      },\n      // highlight-end\n    },\n    Chat: {\n      screen: ChatScreen,\n      // highlight-start\n      linking: {\n        path: 'feed/:sort',\n      },\n      // highlight-end\n    },\n  },\n});\n"})}),(0,i.jsx)(n.p,{children:"In this example:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Chat"})," screen that handles the URL ",(0,i.jsx)(n.code,{children:"/feed"})," with the param ",(0,i.jsx)(n.code,{children:"sort"})," (e.g. ",(0,i.jsx)(n.code,{children:"/feed/latest"})," - the ",(0,i.jsx)(n.code,{children:"Chat"})," screen will receive a param ",(0,i.jsx)(n.code,{children:"sort"})," with the value ",(0,i.jsx)(n.code,{children:"latest"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Profile"})," screen that handles the URL ",(0,i.jsx)(n.code,{children:"/user"}),"."]}),"\n"]}),(0,i.jsxs)(n.p,{children:["Similarly, when you have a nested navigator, you can specify the ",(0,i.jsx)(n.code,{children:"linking"})," property for the screens in the navigator to handle the path for the nested screens:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const HomeTabs = createBottomTabNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n      // highlight-start\n      linking: {\n        path: 'home',\n      },\n      // highlight-end\n    },\n    Settings: {\n      screen: SettingsScreen,\n      // highlight-start\n      linking: {\n        path: 'settings',\n      },\n      // highlight-end\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    HomeTabs: {\n      screen: HomeTabs,\n    },\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      linking: {\n        path: 'user',\n      },\n      // highlight-end\n    },\n    Chat: {\n      screen: ChatScreen,\n      // highlight-start\n      linking: {\n        path: 'feed/:sort',\n      },\n      // highlight-end\n    },\n  },\n});\n"})}),(0,i.jsx)(n.p,{children:"In the above example, the following path formats are handled:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/home"})," navigates to the ",(0,i.jsx)(n.code,{children:"HomeTabs"})," -> ",(0,i.jsx)(n.code,{children:"Home"})," screen"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/settings"})," navigates to the ",(0,i.jsx)(n.code,{children:"HomeTabs"})," -> ",(0,i.jsx)(n.code,{children:"Settings"})," screen"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/user"})," navigates to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/feed/:sort"})," navigates to the ",(0,i.jsx)(n.code,{children:"Chat"})," screen with the param ",(0,i.jsx)(n.code,{children:"sort"})]}),"\n"]}),(0,i.jsx)(n.h3,{id:"how-does-automatic-path-generation-work",children:"How does automatic path generation work?"}),(0,i.jsxs)(n.p,{children:["When using automatic path generation with ",(0,i.jsx)(n.code,{children:"enabled: 'auto'"}),", the following rules are applied:"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Screens with an explicit ",(0,i.jsx)(n.code,{children:"linking"})," property are not used for path generation and will be added as-is."]}),"\n",(0,i.jsxs)(n.li,{children:["Screen names will be converted from ",(0,i.jsx)(n.code,{children:"PascalCase"})," to ",(0,i.jsx)(n.code,{children:"kebab-case"})," to use as the path (e.g. ",(0,i.jsx)(n.code,{children:"NewsFeed"})," -> ",(0,i.jsx)(n.code,{children:"news-feed"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Unless a screen has explicit empty path (",(0,i.jsx)(n.code,{children:"path: ''"}),") to use for the homepage, the first leaf screen encountered will be used as the homepage."]}),"\n",(0,i.jsxs)(n.li,{children:["Path generation only handles leaf screens, i.e. no path is generated for screens containing nested navigators. It's still possible to specify a path for them with an explicit ",(0,i.jsx)(n.code,{children:"linking"})," property."]}),"\n"]}),(0,i.jsx)(n.p,{children:"Let's say we have the following navigation structure:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const HomeTabs = createBottomTabNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n    Settings: {\n      screen: SettingsScreen,\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    HomeTabs: {\n      screen: HomeTabs,\n    },\n    Profile: {\n      screen: ProfileScreen,\n    },\n    Chat: {\n      screen: ChatScreen,\n    },\n  },\n});\n"})}),(0,i.jsx)(n.p,{children:"With automatic path generation, the following paths will be generated:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/"})," navigates to the ",(0,i.jsx)(n.code,{children:"HomeTabs"})," -> ",(0,i.jsx)(n.code,{children:"Home"})," screen"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/settings"})," navigates to the ",(0,i.jsx)(n.code,{children:"HomeTabs"})," -> ",(0,i.jsx)(n.code,{children:"Settings"})," screen"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/profile"})," navigates to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/chat"})," navigates to the ",(0,i.jsx)(n.code,{children:"Chat"})," screen"]}),"\n"]}),(0,i.jsxs)(n.p,{children:["If the URL contains a query string, it'll be passed as params to the screen. For example, the URL ",(0,i.jsx)(n.code,{children:"/profile?user=jane"})," will pass the ",(0,i.jsx)(n.code,{children:"user"})," param to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen."]})]}),(0,i.jsxs)(o.A,{value:"dynamic",label:"Dynamic",children:[(0,i.jsxs)(n.p,{children:["If you specify a ",(0,i.jsx)(n.code,{children:"linking"})," option, by default React Navigation will use the path segments as the route name when parsing the URL. However, directly translating path segments to route names may not be the expected behavior."]}),(0,i.jsxs)(n.p,{children:["You can specify the ",(0,i.jsx)(n.a,{href:"/docs/navigation-container#linkingconfig",children:(0,i.jsx)(n.code,{children:"config"})})," option in ",(0,i.jsx)(n.code,{children:"linking"})," to control how the deep link is parsed to suit your needs. The config should specify the mapping between route names and path patterns:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Chat: 'feed/:sort',\n    Profile: 'user',\n  },\n};\n"})}),(0,i.jsx)(n.p,{children:"In this example:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Chat"})," screen that handles the URL ",(0,i.jsx)(n.code,{children:"/feed"})," with the param ",(0,i.jsx)(n.code,{children:"sort"})," (e.g. ",(0,i.jsx)(n.code,{children:"/feed/latest"})," - the ",(0,i.jsx)(n.code,{children:"Chat"})," screen will receive a param ",(0,i.jsx)(n.code,{children:"sort"})," with the value ",(0,i.jsx)(n.code,{children:"latest"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Profile"})," screen that handles the URL ",(0,i.jsx)(n.code,{children:"/user"}),"."]}),"\n"]}),(0,i.jsxs)(n.p,{children:["The config option can then be passed in the ",(0,i.jsx)(n.code,{children:"linking"})," prop to the container:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { NavigationContainer } from '@react-navigation/native';\n\nconst config = {\n  screens: {\n    Chat: 'feed/:sort',\n    Profile: 'user',\n  },\n};\n\nconst linking = {\n  prefixes: ['https://example.com', 'example://'],\n  config,\n};\n\nfunction App() {\n  return (\n    <NavigationContainer linking={linking} fallback={<Text>Loading...</Text>}>\n      {/* content */}\n    </NavigationContainer>\n  );\n}\n"})}),(0,i.jsxs)(n.p,{children:["The config object must match the navigation structure for your app. For example, the above configuration is if you have ",(0,i.jsx)(n.code,{children:"Chat"})," and ",(0,i.jsx)(n.code,{children:"Profile"})," screens in the navigator at the root:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'function App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Chat" component={ChatScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n'})}),(0,i.jsxs)(n.p,{children:["If your ",(0,i.jsx)(n.code,{children:"Chat"})," screen is inside a nested navigator, we'd need to account for that. For example, consider the following structure where your ",(0,i.jsx)(n.code,{children:"Profile"})," screen is at the root, but the ",(0,i.jsx)(n.code,{children:"Chat"})," screen is nested inside ",(0,i.jsx)(n.code,{children:"Home"}),":"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'function App() {\n  return (\n    <Stack.Navigator>\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}\n\nfunction HomeScreen() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Chat" component={ChatScreen} />\n    </Tab.Navigator>\n  );\n}\n'})}),(0,i.jsx)(n.p,{children:"For the above structure, our configuration will look like this:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      screens: {\n        Chat: 'feed/:sort',\n      },\n    },\n    Profile: 'user',\n  },\n};\n"})}),(0,i.jsx)(n.p,{children:"Similarly, any nesting needs to be reflected in the configuration."})]})]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"How it works"}),(0,i.jsxs)(n.p,{children:["The linking works by translating the URL to a valid ",(0,i.jsx)(n.a,{href:"/docs/navigation-state",children:"navigation state"})," and vice versa using the configuration provided. For example, the path ",(0,i.jsx)(n.code,{children:"/rooms/chat?user=jane"})," may be translated to a state object like this:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'rooms',\n      state: {\n        routes: [\n          {\n            name: 'chat',\n            params: { user: 'jane' },\n          },\n        ],\n      },\n    },\n  ],\n};\n"})}),(0,i.jsxs)(n.p,{children:["For example, you might want to parse the path ",(0,i.jsx)(n.code,{children:"/feed/latest"})," to something like:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Chat',\n      params: {\n        sort: 'latest',\n      },\n    },\n  ];\n}\n"})}),(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/docs/navigation-state",children:"Navigation State reference"})," for more details on how the state object is structured."]})]}),"\n",(0,i.jsx)(n.h2,{id:"passing-params",children:"Passing params"}),"\n",(0,i.jsxs)(n.p,{children:["A common use case is to pass params to a screen to pass some data. For example, you may want the ",(0,i.jsx)(n.code,{children:"Profile"})," screen to have an ",(0,i.jsx)(n.code,{children:"id"})," param to know which user's profile it is. It's possible to pass params to a screen through a URL when handling deep links."]}),"\n",(0,i.jsxs)(n.p,{children:["By default, query params are parsed to get the params for a screen. For example, with the above example, the URL ",(0,i.jsx)(n.code,{children:"/user?id=jane"})," will pass the ",(0,i.jsx)(n.code,{children:"id"})," param to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen."]}),"\n",(0,i.jsxs)(n.p,{children:["You can also customize how the params are parsed from the URL. Let's say you want the URL to look like ",(0,i.jsx)(n.code,{children:"/user/jane"})," where the ",(0,i.jsx)(n.code,{children:"id"})," param is ",(0,i.jsx)(n.code,{children:"jane"})," instead of having the ",(0,i.jsx)(n.code,{children:"id"})," in query params. You can do this by specifying ",(0,i.jsx)(n.code,{children:"user/:id"})," for the ",(0,i.jsx)(n.code,{children:"path"}),". ",(0,i.jsxs)(n.strong,{children:["When the path segment starts with ",(0,i.jsx)(n.code,{children:":"}),", it'll be treated as a param"]}),". For example, the URL ",(0,i.jsx)(n.code,{children:"/user/jane"})," would resolve to ",(0,i.jsx)(n.code,{children:"Profile"})," screen with the string ",(0,i.jsx)(n.code,{children:"jane"})," as a value of the ",(0,i.jsx)(n.code,{children:"id"})," param and will be available in ",(0,i.jsx)(n.code,{children:"route.params.id"})," in ",(0,i.jsx)(n.code,{children:"Profile"})," screen."]}),"\n",(0,i.jsxs)(n.p,{children:["By default, all params are treated as strings. You can also customize how to parse them by specifying a function in the ",(0,i.jsx)(n.code,{children:"parse"})," property to parse the param, and a function in the ",(0,i.jsx)(n.code,{children:"stringify"})," property to convert it back to a string."]}),"\n",(0,i.jsxs)(n.p,{children:["If you wanted to resolve ",(0,i.jsx)(n.code,{children:"/user/@jane/settings"})," to result in the params ",(0,i.jsx)(n.code,{children:"{ id: 'jane' section: 'settings' }"}),", you could make ",(0,i.jsx)(n.code,{children:"Profile"}),"'s config to look like this:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      // highlight-start\n      linking: {\n        path: 'user/:id/:section',\n        parse: {\n          id: (id) => id.replace(/^@/, ''),\n        },\n        stringify: {\n          id: (id) => `@${id}`,\n        },\n      },\n      // highlight-end\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Profile: {\n      // highlight-start\n      path: 'user/:id/:section',\n      parse: {\n        id: (id) => id.replace(/^@/, ''),\n      },\n      stringify: {\n        id: (id) => `@${id}`,\n      },\n      // highlight-end\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Result Navigation State"}),(0,i.jsxs)(n.p,{children:["With this configuration, the path ",(0,i.jsx)(n.code,{children:"/user/@jane/settings"})," will resolve to the following state object:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'jane', section: 'settings' },\n    },\n  ],\n};\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"marking-params-as-optional",children:"Marking params as optional"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes a param may or may not be present in the URL depending on certain conditions. For example, in the above scenario, you may not always have the section parameter in the URL, i.e. both ",(0,i.jsx)(n.code,{children:"/user/jane/settings"})," and ",(0,i.jsx)(n.code,{children:"/user/jane"})," should go to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen, but the ",(0,i.jsx)(n.code,{children:"section"})," param (with the value ",(0,i.jsx)(n.code,{children:"settings"})," in this case) may or may not be present."]}),"\n",(0,i.jsxs)(n.p,{children:["In this case, you would need to mark the ",(0,i.jsx)(n.code,{children:"section"})," param as optional. You can do it by adding the ",(0,i.jsx)(n.code,{children:"?"})," suffix after the param name:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      linking: {\n        // highlight-next-line\n        path: 'user/:id/:section?',\n        parse: {\n          id: (id) => `user-${id}`,\n        },\n        stringify: {\n          id: (id) => id.replace(/^user-/, ''),\n        },\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Profile: {\n      // highlight-next-line\n      path: 'user/:id/:section?',\n      parse: {\n        id: (id) => `user-${id}`,\n      },\n      stringify: {\n        id: (id) => id.replace(/^user-/, ''),\n      },\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Result Navigation State"}),(0,i.jsxs)(n.p,{children:["With this configuration, the path ",(0,i.jsx)(n.code,{children:"/user/jane"})," will resolve to the following state object:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-jane' },\n    },\n  ],\n};\n"})}),(0,i.jsxs)(n.p,{children:["If the URL contains a ",(0,i.jsx)(n.code,{children:"section"})," param (e.g. ",(0,i.jsx)(n.code,{children:"/user/jane/settings"}),"), this will result in the following with the same config:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Profile',\n      params: { id: 'user-jane', section: 'settings' },\n    },\n  ],\n};\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"handling-unmatched-routes-or-404",children:"Handling unmatched routes or 404"}),"\n",(0,i.jsx)(n.p,{children:"If your app is opened with an invalid URL, most of the times you'd want to show an error page with some information. On the web, this is commonly known as 404 - or page not found error."}),"\n",(0,i.jsxs)(n.p,{children:["To handle this, you'll need to define a catch-all route that will be rendered if no other routes match the path. You can do it by specifying ",(0,i.jsx)(n.code,{children:"*"})," for the path matching pattern:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: {\n      screen: FeedScreen,\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n    Settings: {\n      screen: SettingsScreen,\n      linking: {\n        path: 'settings',\n      },\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeTabs,\n    },\n    NotFound: {\n      screen: NotFoundScreen,\n      linking: {\n        // highlight-next-line\n        path: '*',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: 'settings',\n      },\n    },\n    NotFound: {\n      // highlight-start\n      path: '*',\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["Here, we have defined a route named ",(0,i.jsx)(n.code,{children:"NotFound"})," and set it to match ",(0,i.jsx)(n.code,{children:"*"})," aka everything. If the path didn't match ",(0,i.jsx)(n.code,{children:"user/:id"})," or ",(0,i.jsx)(n.code,{children:"settings"}),", it'll be matched by this route."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Result Navigation State"}),(0,i.jsxs)(n.p,{children:["With this configuration, a path like ",(0,i.jsx)(n.code,{children:"/library"})," or ",(0,i.jsx)(n.code,{children:"/settings/notification"})," will resolve to the following state object:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [{ name: 'NotFound' }],\n};\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["You can even go more specific, for example, say if you want to show a different screen for invalid paths under ",(0,i.jsx)(n.code,{children:"/settings"}),", you can specify such a pattern under ",(0,i.jsx)(n.code,{children:"Settings"}),":"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const SettingsStack = createStackNavigator({\n  screens: {\n    UserSettings: {\n      screen: UserSettingsScreen,\n      linking: {\n        path: 'user-settings',\n      },\n    },\n    InvalidSettings: {\n      screen: InvalidSettingsScreen,\n      linking: {\n        // highlight-next-line\n        path: '*',\n      },\n    },\n  },\n});\n\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: {\n      screen: FeedScreen,\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n    Settings: {\n      screen: SettingsStack,\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeTabs,\n    },\n    NotFound: {\n      screen: NotFoundScreen,\n      linking: {\n        path: '*',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: {\n          path: 'settings',\n          screens: {\n            InvalidSettings: '*',\n          },\n        },\n      },\n    },\n    NotFound: '*',\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Result Navigation State"}),(0,i.jsxs)(n.p,{children:["With this configuration, the path ",(0,i.jsx)(n.code,{children:"/settings/notification"})," will resolve to the following state object:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        index: 1,\n        routes: [\n          { name: 'Feed' },\n          {\n            name: 'Settings',\n            state: {\n              routes: [\n                { name: 'InvalidSettings', path: '/settings/notification' },\n              ],\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"route"})," passed to the ",(0,i.jsx)(n.code,{children:"NotFound"})," screen will contain a ",(0,i.jsx)(n.code,{children:"path"})," property which corresponds to the path that opened the page. If you need, you can use this property to customize what's shown in this screen, e.g. load the page in a ",(0,i.jsx)(n.code,{children:"WebView"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function NotFoundScreen({ route }) {\n  if (route.path) {\n    return <WebView source={{ uri: `https://mywebsite.com/${route.path}` }} />;\n  }\n\n  return <Text>This screen doesn't exist!</Text>;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When doing server rendering, you'd also want to return correct status code for 404 errors. See ",(0,i.jsx)(n.a,{href:"/docs/server-rendering#handling-404-or-other-status-codes",children:"server rendering docs"})," for a guide on how to handle it."]}),"\n",(0,i.jsx)(n.h2,{id:"rendering-an-initial-route",children:"Rendering an initial route"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes you want to ensure that a certain screen will always be present as the first screen in the navigator's state. You can use the ",(0,i.jsx)(n.code,{children:"initialRouteName"})," property to specify the screen to use for the initial screen."]}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, if you want the ",(0,i.jsx)(n.code,{children:"Feed"})," screen to be the initial route in the navigator under ",(0,i.jsx)(n.code,{children:"Home"}),", your config will look like this:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: {\n      screen: FeedScreen,\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n    Settings: {\n      screen: SettingsScreen,\n      linking: {\n        path: 'settings',\n      },\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeTabs,\n      linking: {\n        // highlight-next-line\n        initialRouteName: 'Feed',\n      },\n    },\n    NotFound: {\n      screen: NotFoundScreen,\n      linking: {\n        path: '*',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      // highlight-next-line\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: 'users/:id',\n        Settings: 'settings',\n      },\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Result Navigation State"}),(0,i.jsxs)(n.p,{children:["With this configuration, the path ",(0,i.jsx)(n.code,{children:"/users/42"})," will resolve to the following state object:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const state = {\n  routes: [\n    {\n      name: 'Home',\n      state: {\n        index: 1,\n        routes: [\n          { name: 'Feed' },\n          {\n            name: 'Profile',\n            params: { id: '42' },\n          },\n        ],\n      },\n    },\n  ],\n};\n"})})]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"initialRouteName"})," will add the screen to React Navigation's state only. If your app is running on the Web, the browser's history will not contain this screen as the user has never visited it. So, if the user presses the browser's back button, it'll not go back to this screen."]})}),"\n",(0,i.jsxs)(n.p,{children:["Another thing to keep in mind is that it's not possible to pass params to the initial screen through the URL. So make sure that your initial route doesn't need any params or specify ",(0,i.jsx)(n.code,{children:"initialParams"})," in the screen configuration to pass the required params."]}),"\n",(0,i.jsxs)(n.p,{children:["In this case, any params in the URL are only passed to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen which matches the path pattern ",(0,i.jsx)(n.code,{children:"users/:id"}),", and the ",(0,i.jsx)(n.code,{children:"Feed"})," screen doesn't receive any params. If you want to have the same params in the ",(0,i.jsx)(n.code,{children:"Feed"})," screen, you can specify a ",(0,i.jsxs)(n.a,{href:"/docs/navigation-container#linkinggetstatefrompath",children:["custom ",(0,i.jsx)(n.code,{children:"getStateFromPath"})," function"]})," and copy those params."]}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, if you want to access params of a parent screen from a child screen, you can use ",(0,i.jsx)(n.a,{href:"https://react.dev/reference/react/useContext",children:"React Context"})," to expose them."]}),"\n",(0,i.jsx)(n.h2,{id:"matching-exact-paths",children:"Matching exact paths"}),"\n",(0,i.jsx)(n.p,{children:"By default, paths defined for each screen are matched against the URL relative to their parent screen's path. Consider the following config:"}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const ProfileTabs = createBottomTabNavigator({\n  screens: {\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: ProfileTabs,\n      linking: {\n        path: 'feed',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: 'feed',\n      screens: {\n        Profile: 'users/:id',\n      },\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["Here, you have a ",(0,i.jsx)(n.code,{children:"path"})," property defined for the ",(0,i.jsx)(n.code,{children:"Home"})," screen, as well as the child ",(0,i.jsx)(n.code,{children:"Profile"})," screen. The profile screen specifies the path ",(0,i.jsx)(n.code,{children:"users/:id"}),", but since it's nested inside a screen with the path ",(0,i.jsx)(n.code,{children:"feed"}),", it'll try to match the pattern ",(0,i.jsx)(n.code,{children:"feed/users/:id"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This will result in the URL ",(0,i.jsx)(n.code,{children:"/feed"})," navigating to ",(0,i.jsx)(n.code,{children:"Home"})," screen, and ",(0,i.jsx)(n.code,{children:"/feed/users/cal"})," navigating to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen."]}),"\n",(0,i.jsxs)(n.p,{children:["In this case, it makes more sense to navigate to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen using a URL like ",(0,i.jsx)(n.code,{children:"/users/cal"}),", rather than ",(0,i.jsx)(n.code,{children:"/feed/users/cal"}),". To achieve this, you can override the relative matching behavior to ",(0,i.jsx)(n.code,{children:"exact"})," matching:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const ProfileTabs = createBottomTabNavigator({\n  screens: {\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n        // highlight-next-line\n        exact: true,\n      },\n    },\n  },\n});\n\nconst RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: ProfileTabs,\n      linking: {\n        path: 'feed',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: 'feed',\n      screens: {\n        Profile: {\n          path: 'users/:id',\n          // highlight-next-line\n          exact: true,\n        },\n      },\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["With ",(0,i.jsx)(n.code,{children:"exact"})," property set to ",(0,i.jsx)(n.code,{children:"true"}),", ",(0,i.jsx)(n.code,{children:"Profile"})," will ignore the parent screen's ",(0,i.jsx)(n.code,{children:"path"})," config and you'll be able to navigate to ",(0,i.jsx)(n.code,{children:"Profile"})," using a URL like ",(0,i.jsx)(n.code,{children:"users/cal"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"omitting-a-screen-from-path",children:"Omitting a screen from path"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes, you may not want to have the route name of a screen in the path. For example, let's say you have a ",(0,i.jsx)(n.code,{children:"Home"})," screen and the following config. When the page is opened in the browser you'll get ",(0,i.jsx)(n.code,{children:"/home"})," as the URL:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: ProfileScreen,\n      linking: {\n        path: 'home',\n      },\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: 'home',\n    },\n    Profile: 'users/:id',\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["But it'll be nicer if the URL was just ",(0,i.jsx)(n.code,{children:"/"})," when visiting the home screen."]}),"\n",(0,i.jsx)(n.p,{children:"You can specify an empty string as path or not specify a path at all, and React Navigation won't add the screen to the path (think of it like adding empty string to the path, which doesn't change anything):"}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Home: {\n      screen: ProfileScreen,\n      linking: {\n        path: '',\n      },\n    },\n    Profile: {\n      screen: HomeScreen,\n      linking: {\n        path: 'users/:id',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Home: {\n      path: '',\n    },\n    Profile: 'users/:id',\n  },\n};\n"})})})]}),"\n",(0,i.jsx)(n.h2,{id:"serializing-and-parsing-params",children:"Serializing and parsing params"}),"\n",(0,i.jsx)(n.p,{children:"Since URLs are strings, any params you have for routes are also converted to strings when constructing the path."}),"\n",(0,i.jsxs)(n.p,{children:["For example, say you have the URL ",(0,i.jsx)(n.code,{children:"/chat/1589842744264"})," with the following config:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Chat: {\n      screen: ChatScreen,\n      linking: {\n        path: 'chat/:date',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Chat: 'chat/:date',\n  },\n};\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:"When handling the URL, your params will look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{ "date": "1589842744264" }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, the ",(0,i.jsx)(n.code,{children:"date"})," param was parsed as a string because React Navigation doesn't know that it's supposed to be a timestamp, and hence number. You can customize it by providing a custom function to use for parsing:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Chat: {\n      screen: ChatScreen,\n      linking: {\n        path: 'chat/:date',\n        parse: {\n          date: Number,\n        },\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Chat: {\n      path: 'chat/:date',\n      parse: {\n        date: Number,\n      },\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:"You can also provide a your own function to serialize the params. For example, let's say that you want to use a DD-MM-YYYY format in the path instead of a timestamp:"}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Chat: {\n      screen: ChatScreen,\n      linking: {\n        path: 'chat/:date',\n        parse: {\n          date: (date) => new Date(date).getTime(),\n        },\n        stringify: {\n          date: (date) => {\n            const d = new Date(date);\n\n            return d.getFullYear() + '-' + d.getMonth() + '-' + d.getDate();\n          },\n        },\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Chat: {\n      path: 'chat/:date',\n      parse: {\n        date: (date) => new Date(date).getTime(),\n      },\n      stringify: {\n        date: (date) => {\n          const d = new Date(date);\n\n          return d.getFullYear() + '-' + d.getMonth() + '-' + d.getDate();\n        },\n      },\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:"Depending on your requirements, you can use this functionality to parse and stringify more complex data."}),"\n",(0,i.jsx)(n.h2,{id:"matching-regular-expressions",children:"Matching regular expressions"}),"\n",(0,i.jsxs)(n.p,{children:["If you need more complex matching logic, you can use regular expressions to match the path. For example, if you want to use the pattern ",(0,i.jsx)(n.code,{children:"@username"})," to match a user's profile, you can use a regular expression to match the path. This allows you to have the same path pattern for multiple screens, but fine-tune the matching logic to be more specific for a particular screen."]}),"\n",(0,i.jsxs)(n.p,{children:["Regular expressions can be specified between parentheses ",(0,i.jsx)(n.code,{children:"("})," and ",(0,i.jsx)(n.code,{children:")"})," in the after a param name. For example:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Feed: {\n      screen: FeedScreen,\n      linking: {\n        path: ':sort(latest|popular)',\n      },\n    },\n    Profile: {\n      screen: ProfileScreen,\n      linking: {\n        path: ':username(@[A-Za-z0-9_]+)',\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Feed: ':sort(latest|popular)',\n    Profile: ':username(@[A-Za-z0-9_]+)',\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["This will only match the path if it starts with ",(0,i.jsx)(n.code,{children:"@"})," followed by alphanumeric characters or underscores. For example, the URL ",(0,i.jsx)(n.code,{children:"/@jane"})," will match the ",(0,i.jsx)(n.code,{children:"Profile"})," screen, but ",(0,i.jsx)(n.code,{children:"/jane"})," won't."]}),"\n",(0,i.jsxs)(n.p,{children:["Regular expressions are intended to only match path segments, not the entire path. So avoid using ",(0,i.jsx)(n.code,{children:"/"}),", ",(0,i.jsx)(n.code,{children:"^"}),", ",(0,i.jsx)(n.code,{children:"$"}),", etc. in the regular expressions."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Regular expressions are an advanced feature. They cannot be validated to warn you about potential issues, so it's up to you to ensure that the regular expression is correct."})}),"\n",(0,i.jsx)(n.h2,{id:"alias-for-paths",children:"Alias for paths"}),"\n",(0,i.jsxs)(n.p,{children:["If you want to have multiple paths for the same screen, you can use the ",(0,i.jsx)(n.code,{children:"alias"})," property to specify an array of paths. This can be useful to keep backward compatibility with old URLs while transitioning to a new URL structure."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if you want to match both ",(0,i.jsx)(n.code,{children:"/users/:id"})," and ",(0,i.jsx)(n.code,{children:"/:id"})," to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen, you can do this:"]}),"\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const RootStack = createStackNavigator({\n  screens: {\n    Profile: {\n      screen: ProfileScreen,\n      linking: {\n        path: ':id',\n        alias: ['users/:id'],\n      },\n    },\n  },\n});\n"})})}),(0,i.jsx)(o.A,{value:"dynamic",label:"Dynamic",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const config = {\n  screens: {\n    Profile: {\n      path: ':id',\n      alias: ['users/:id'],\n    },\n  },\n};\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:["In this case, when the URL is ",(0,i.jsx)(n.code,{children:"/users/jane"})," or ",(0,i.jsx)(n.code,{children:"/jane"}),", it'll match the ",(0,i.jsx)(n.code,{children:"Profile"})," screen. The ",(0,i.jsx)(n.code,{children:"path"})," is the primary pattern that will be used to generate the URL, e.g. when navigating to the ",(0,i.jsx)(n.code,{children:"Profile"})," screen in the app on the Web. The patterns in ",(0,i.jsx)(n.code,{children:"alias"})," will be ignored when generating URLs. The ",(0,i.jsx)(n.code,{children:"alias"})," patterns are not used for matching any child screens in nested navigators."]}),"\n",(0,i.jsx)(n.p,{children:"On the web, if a screen containing an alias contains a nested navigator, the URL matching the alias will only be used to match the screen, and will be updated to the URL of the focused child screen once the app renders."}),"\n",(0,i.jsxs)(n.p,{children:["Each item in the ",(0,i.jsx)(n.code,{children:"alias"})," array can be a string matching the syntax of the ",(0,i.jsx)(n.code,{children:"path"})," property, or an object with the following properties:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"path"})," (required) - The path pattern to match."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"exact"})," - Whether to match the path exactly. Defaults to ",(0,i.jsx)(n.code,{children:"false"}),". See ",(0,i.jsx)(n.a,{href:"#matching-exact-paths",children:"Matching exact paths"})," for more details."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parse"})," - Function to parse path segments into param values. See ",(0,i.jsx)(n.a,{href:"#passing-params",children:"Passing params"})," for more details."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"advanced-cases",children:"Advanced cases"}),"\n",(0,i.jsxs)(n.p,{children:["For some advanced cases, specifying the mapping may not be sufficient. To handle such cases, you can specify a custom function to parse the URL into a state object (",(0,i.jsx)(n.a,{href:"/docs/navigation-container#linkinggetstatefrompath",children:(0,i.jsx)(n.code,{children:"getStateFromPath"})}),"), and a custom function to serialize the state object into an URL (",(0,i.jsx)(n.a,{href:"/docs/navigation-container#linkinggetpathfromstate",children:(0,i.jsx)(n.code,{children:"getPathFromState"})}),")."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const linking = {\n  prefixes: ['https://example.com', 'example://'],\n  getStateFromPath(path, options) {\n    // Return a state object here\n    // You can also reuse the default logic by importing `getStateFromPath` from `@react-navigation/native`\n  },\n  getPathFromState(state, config) {\n    // Return a path string here\n    // You can also reuse the default logic by importing `getPathFromState` from `@react-navigation/native`\n  },\n\n  // ...\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"playground",children:"Playground"}),"\n","\n",(0,i.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,i.jsx)(o.A,{value:"static",label:"Static",default:!0,children:(0,i.jsx)(n.p,{children:"Playground is not available for static config."})}),(0,i.jsxs)(o.A,{value:"dynamic",label:"Dynamic",children:[(0,i.jsx)(n.p,{children:"You can play around with customizing the config and path below, and see how the path is parsed."}),(0,i.jsx)(c.A,{})]})]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>r});t(96540);var a=t(34164);const i={tabItem:"tabItem_Ymn6"};var s=t(74848);function r(e){let{children:n,hidden:t,className:r}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,a.A)(i.tabItem,r),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>k});var a=t(96540),i=t(34164),s=t(17559),r=t(23104),o=t(56347),c=t(205),l=t(57485),h=t(31682),d=t(70679);function p(e){var n,t;return null!=(n=null==(t=a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function g(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:function(e){return p(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:i}}=e;return{value:n,label:t,attributes:a,default:i}}))}(t);return function(e){const n=(0,h.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function u(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const i=(0,o.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(s),(0,a.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(i.location.search);n.set(s,e),i.replace(Object.assign({},i.location,{search:n.toString()}))}),[s,i])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,s=g(e),[r,o]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!u({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const i=null!=(n=a.find((e=>e.default)))?n:a[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:s}))),[l,h]=m({queryString:t,groupId:i}),[p,f]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[i,s]=(0,d.Dv)(t);return[i,(0,a.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:i}),x=(()=>{const e=null!=l?l:p;return u({value:e,tabValues:s})?e:null})();(0,c.A)((()=>{x&&o(x)}),[x]);return{selectedValue:r,selectValue:(0,a.useCallback)((e=>{if(!u({value:e,tabValues:s}))throw new Error("Can't select invalid tab value="+e);o(e),h(e),f(e)}),[h,f,s]),tabValues:s}}var x=t(92303);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function y(e){let{className:n,block:t,selectedValue:a,selectValue:s,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),h=e=>{const n=e.currentTarget,t=c.indexOf(n),i=o[t].value;i!==a&&(l(n),s(i))},d=e=>{var n;let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{var a;const n=c.indexOf(e.currentTarget)+1;t=null!=(a=c[n])?a:c[0];break}case"ArrowLeft":{var i;const n=c.indexOf(e.currentTarget)-1;t=null!=(i=c[n])?i:c[c.length-1];break}}null==(n=t)||n.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,b.jsx)("li",Object.assign({role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{c.push(e)},onKeyDown:d,onClick:h},s,{className:(0,i.A)("tabs__item",j.tabItem,null==s?void 0:s.className,{"tabs__item--active":a===n}),children:null!=t?t:n}),n)}))})}function v(e){let{lazy:n,children:t,selectedValue:s}=e;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===s));return e?(0,a.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function _(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,i.A)(s.G.tabs.container,"tabs-container",j.tabList),children:[(0,b.jsx)(y,Object.assign({},n,e)),(0,b.jsx)(v,Object.assign({},n,e))]})}function k(e){const n=(0,x.A)();return(0,b.jsx)(_,Object.assign({},e,{children:p(e.children)}),String(n))}},29571:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>LinkingTester});var _docusaurus_theme_common__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(95293),_react_navigation_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(48220),prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(71765),react__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(96540),react_simple_code_editor__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(26069),react_simple_code_editor__WEBPACK_IMPORTED_MODULE_3___default=__webpack_require__.n(react_simple_code_editor__WEBPACK_IMPORTED_MODULE_3__),_RouteMap__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(66715),react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(74848);const parse=value=>eval("(function() { return "+value+"; }())");function Code(e){let{code:n,theme:t,language:a}=e;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__.f4,{code:n,theme:t,language:a,children:e=>{let{className:n,style:t,tokens:a,getLineProps:i,getTokenProps:s}=e;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("pre",{className:n,style:Object.assign({},t,styles.json),children:a.map(((e,n)=>(0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)("div",Object.assign({},i({line:e,key:n}),{key:n}),e.map(((e,n)=>(0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)("span",Object.assign({},s({token:e,key:n}),{key:n})))))))})}})}function LinkingTester(){const{colorMode:e}=(0,_docusaurus_theme_common__WEBPACK_IMPORTED_MODULE_6__.G)(),n="dark"===e?prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__.Zj.dracula:prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__.Zj.github,[t,a]=react__WEBPACK_IMPORTED_MODULE_2__.useState("{\n  screens: {\n    Home: {\n      initialRouteName: 'Feed',\n      screens: {\n        Profile: {\n          path: 'user/:id',\n          parse: {\n            id: id => id.replace(/^@/, ''),\n          },\n          screens: {\n            Settings: 'edit',\n          },\n        },\n      },\n    },\n    NoMatch: '*',\n  }\n}"),[i,s]=react__WEBPACK_IMPORTED_MODULE_2__.useState("/user/@vergil/edit"),[r,o]=react__WEBPACK_IMPORTED_MODULE_2__.useState((()=>parse(t))),[c,l]=react__WEBPACK_IMPORTED_MODULE_2__.useState("chart");let h,d;try{h=(0,_react_navigation_core__WEBPACK_IMPORTED_MODULE_0__.Bd)(i.replace(/(^\w+:|^)\/\//,""),r),h&&(d=(0,_react_navigation_core__WEBPACK_IMPORTED_MODULE_0__.U6)(h,r))}catch(p){}return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("input",{type:"text",value:i,placeholder:"Type a path, e.g. /user/@vergil/edit",onChange:e=>s(e.target.value),style:Object.assign({},styles.code,styles.input)}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_simple_code_editor__WEBPACK_IMPORTED_MODULE_3___default(),{value:t,placeholder:"Type linking config",onValueChange:e=>{a(e);try{const n=parse(e);o(n)}catch(p){}},highlight:e=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(prism_react_renderer__WEBPACK_IMPORTED_MODULE_1__.f4,{code:e,theme:n,language:"jsx",children:e=>{let{tokens:n,getLineProps:t,getTokenProps:a}=e;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment,{children:n.map(((e,n)=>(0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)("div",Object.assign({},t({line:e,key:n}),{key:n}),e.map(((e,n)=>(0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)("span",Object.assign({},a({token:e,key:n}),{key:n})))))))})}}),padding:16,style:Object.assign({},styles.code,styles.editor)}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div",{style:styles.preview,children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div",{style:styles.toggles,children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("button",{type:"button",style:styles.button,onClick:()=>l("chart"),children:"Chart"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("button",{type:"button",style:styles.button,onClick:()=>l("state"),children:"State"}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("button",{type:"button",style:styles.button,onClick:()=>l("action"),children:"Action"})]}),"state"===c?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(Code,{theme:n,code:JSON.stringify(h,null,2)||"",language:"json"}):"action"===c?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(Code,{theme:n,code:JSON.stringify(d,null,2)||"",language:"json"}):"chart"===c?h?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_RouteMap__WEBPACK_IMPORTED_MODULE_4__.A,{routes:h.routes}):(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("p",{style:styles.error,children:"Failed to parse the path. Make sure that the path matches the patterns specified in the config."}):null]})]})}const styles={code:{display:"block",fontFamily:"var(--ifm-font-family-monospace)",fontSize:"var(--ifm-code-font-size)",borderRadius:"var(--ifm-pre-border-radius)",margin:"var(--ifm-spacing-vertical) 0"},input:{display:"block",width:"100%",padding:"var(--ifm-pre-padding)",backgroundColor:"transparent",color:"inherit",border:"1px solid var(--ifm-contents-border-color)"},editor:{border:"1px solid var(--ifm-contents-border-color)"},preview:{position:"relative",border:"1px solid var(--ifm-contents-border-color)",borderRadius:"var(--ifm-pre-border-radius)",minHeight:70},json:{margin:0,fontFamily:"var(--ifm-font-family-monospace)",fontSize:"var(--ifm-code-font-size)",borderRadius:"var(--ifm-pre-border-radius)",padding:"var(--ifm-pre-padding)",minHeight:70},toggles:{position:"absolute",flexDirection:"row",right:0,top:0,borderBottom:"1px solid var(--ifm-contents-border-color)"},button:{border:0,borderLeft:"1px solid var(--ifm-contents-border-color)",borderRadius:0,cursor:"pointer",display:"inline-flex",fontSize:12,margin:0,padding:"4px 8px",color:"inherit",background:"none",MozAppearance:"none",WebkitAppearance:"none"},error:{margin:24,color:"#A12027"}}},66715:(e,n,t)=>{t.d(n,{A:()=>s});t(96540);var a=t(74848);const i="#3F51B5";function s(e){let{routes:n,root:t=!0}=e;return(0,a.jsx)("div",{style:Object.assign({},r.container,t?{overflowX:"auto",padding:"calc(var(--ifm-pre-padding) / 2)"}:null),children:n.map(((e,n)=>(0,a.jsxs)("div",{style:r.item,children:[(0,a.jsxs)("div",{style:r.route,children:[(0,a.jsxs)("div",{style:r.name,children:[e.name,t?null:0===n?(0,a.jsx)("div",{style:r.connectLeft}):(0,a.jsx)("div",{style:r.connectUpLeft})]}),e.params?(0,a.jsxs)("div",{style:r.paramsContainer,children:[(0,a.jsx)("table",{style:r.params,children:(0,a.jsx)("tbody",{children:Object.entries(e.params).map((e=>{let[n,t]=e;return(0,a.jsxs)("tr",{style:r.row,children:[(0,a.jsx)("td",{style:r.key,children:n}),(0,a.jsx)("td",{style:r.colon,children:":"}),(0,a.jsx)("td",{style:r.value,children:JSON.stringify(t)})]},n)}))})}),(0,a.jsx)("div",{style:r.connectUp})]}):null]}),e.state?(0,a.jsx)(s,{routes:e.state.routes,root:!1}):null]},e.name)))})}const r={container:{display:"flex",flexDirection:"column"},item:{display:"flex",flexDirection:"row",alignItems:"flex-start"},route:{minWidth:160},name:{backgroundColor:i,color:"white",fontSize:"var(--ifm-code-font-size)",margin:"calc(var(--ifm-pre-padding) / 2)",padding:"calc(var(--ifm-pre-padding) / 2) var(--ifm-pre-padding)",borderRadius:4,position:"relative",textAlign:"center"},paramsContainer:{position:"relative"},params:{backgroundColor:"rgba(3, 169, 244, 0.08)",border:"1px solid "+i,fontFamily:"var(--ifm-font-family-monospace)",fontSize:"var(--ifm-code-font-size)",margin:"var(--ifm-pre-padding) calc(var(--ifm-pre-padding) / 2)",borderRadius:4,padding:3,width:"auto",overflow:"visible"},row:{border:0,background:"none"},key:{color:"#009688",border:0,padding:"4px 6px",textAlign:"right"},value:{color:"#E91E63",padding:"4px 6px",border:0},colon:{color:"inherit",opacity:.3,border:0,padding:0},connectLeft:{position:"absolute",width:16,height:1,backgroundColor:i,right:"100%",top:"50%"},connectUpLeft:{position:"absolute",width:9,height:52,border:"1px solid "+i,borderRadius:"0 0 0 3px",borderRight:0,borderTop:0,right:"100%",bottom:"50%"},connectUp:{position:"absolute",width:1,height:16,backgroundColor:i,right:"50%",bottom:"100%"}}}}]);