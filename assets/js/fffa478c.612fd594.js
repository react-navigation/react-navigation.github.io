"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[26344],{99111:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"tab-view","title":"React Native Tab View","description":"React Native Tab View is a cross-platform Tab View component for React Native implemented using react-native-pager-view on Android & iOS, and PanResponder on Web, macOS, and Windows.","source":"@site/versioned_docs/version-7.x/tab-view.md","sourceDirName":".","slug":"/tab-view","permalink":"/docs/tab-view","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/tab-view.md","tags":[],"version":"7.x","frontMatter":{"id":"tab-view","title":"React Native Tab View","sidebar_label":"Tab View"},"sidebar":"docs","previous":{"title":"Elements","permalink":"/docs/elements"},"next":{"title":"Drawer Layout","permalink":"/docs/drawer-layout"}}');var o=t(74848),i=t(28453),r=t(11470),s=t(19365);const l={id:"tab-view",title:"React Native Tab View",sidebar_label:"Tab View",rawMarkdown:"---\nid: tab-view\ntitle: React Native Tab View\nsidebar_label: Tab View\n---\n\nReact Native Tab View is a cross-platform Tab View component for React Native implemented using [`react-native-pager-view`](https://github.com/callstack/react-native-viewpager) on Android & iOS, and [PanResponder](https://reactnative.dev/docs/panresponder) on Web, macOS, and Windows.\n\nIt follows material design guidelines by default, but you can also use your own custom tab bar or position the tab bar at the bottom.\n\n<video playsInline autoPlay muted loop>\n  <source src=\"/assets/7.x/tab-view.mp4\" />\n</video>\n\nThis package doesn't integrate with React Navigation. If you want to integrate the tab view with React Navigation's navigation system, e.g. want to show screens in the tab bar and be able to navigate between them using `navigation.navigate` etc, use [Material Top Tab Navigator](material-top-tab-navigator.md) instead.\n\n## Installation\n\nTo use this package, open a Terminal in the project root and run:\n\n```bash npm2yarn\nnpm install react-native-tab-view\n```\n\nThe library depends on [`react-native-pager-view`](https://github.com/callstack/react-native-pager-view) for rendering the pages.\n\n<Tabs groupId='framework' queryString=\"framework\">\n<TabItem value='expo' label='Expo' default>\n\nIf you have a Expo managed project, in your project directory, run:\n\n```bash\nnpx expo install react-native-pager-view\n```\n\n</TabItem>\n<TabItem value='community-cli' label='Community CLI'>\n\nIf you have a bare React Native project, in your project directory, run:\n\n```bash npm2yarn\nnpm install react-native-pager-view\n```\n\n</TabItem>\n</Tabs>\n\nIf you're on a Mac and developing for iOS, you also need to install [pods](https://cocoapods.org/) to complete the linking.\n\n```bash\nnpx pod-install ios\n```\n\n## Quick start\n\n```js name=\"React Native Tab View\" snack\n// codeblock-focus-start\nimport * as React from 'react';\nimport { View, useWindowDimensions } from 'react-native';\nimport { TabView, SceneMap } from 'react-native-tab-view';\n\n// codeblock-focus-end\nconst FirstRoute = () => (\n  <View style={{ flex: 1, backgroundColor: '#ff4081' }} />\n);\n\nconst SecondRoute = () => (\n  <View style={{ flex: 1, backgroundColor: '#673ab7' }} />\n);\n\n// codeblock-focus-start\nconst renderScene = SceneMap({\n  first: FirstRoute,\n  second: SecondRoute,\n});\n\nconst routes = [\n  { key: 'first', title: 'First' },\n  { key: 'second', title: 'Second' },\n];\n\nexport default function TabViewExample() {\n  const layout = useWindowDimensions();\n  const [index, setIndex] = React.useState(0);\n\n  return (\n    <TabView\n      navigationState={{ index, routes }}\n      renderScene={renderScene}\n      onIndexChange={setIndex}\n      initialLayout={{ width: layout.width }}\n    />\n  );\n}\n// codeblock-focus-end\n```\n\n## More examples on Snack\n\n- [Custom Tab Bar](https://snack.expo.io/@satya164/react-native-tab-view-custom-tabbar)\n- [Lazy Load](https://snack.expo.io/@satya164/react-native-tab-view-lazy-load)\n\n## API reference\n\nThe package exports a `TabView` component which is the one you'd use to render the tab view, and a `TabBar` component which is the default tab bar implementation.\n\n### `TabView`\n\nContainer component responsible for rendering and managing tabs. Follows material design styles by default.\n\nBasic usage look like this:\n\n```js\n<TabView\n  navigationState={{ index, routes }}\n  onIndexChange={setIndex}\n  renderScene={SceneMap({\n    first: FirstRoute,\n    second: SecondRoute,\n  })}\n/>\n```\n\n#### TabView Props\n\n##### `navigationState` (`required`)\n\nState for the tab view. The state should contain the following properties:\n\n- `index`: a number representing the index of the active route in the `routes` array\n- `routes`: an array containing a list of route objects used for rendering the tabs\n\nEach route object should contain the following properties:\n\n- `key`: a unique key to identify the route (required)\n- `title`: title for the route to display in the tab bar\n- `icon`: icon for the route to display in the tab bar\n- `accessibilityLabel`: accessibility label for the tab button\n- `testID`: test id for the tab button\n\nExample:\n\n```js\n{\n  index: 1,\n  routes: [\n    { key: 'music', title: 'Music' },\n    { key: 'albums', title: 'Albums' },\n    { key: 'recents', title: 'Recents' },\n    { key: 'purchased', title: 'Purchased' },\n  ]\n}\n```\n\n`TabView` is a controlled component, which means the `index` needs to be updated via the `onIndexChange` callback.\n\n##### `onIndexChange` (`required`)\n\nCallback which is called on tab change, receives the index of the new tab as argument.\nThe navigation state needs to be updated when it's called, otherwise the change is dropped.\n\n##### `renderScene` (`required`)\n\nCallback which returns a react element to render as the page for the tab. Receives an object containing the route as the argument:\n\n```js\nconst renderScene = ({ route, jumpTo }) => {\n  switch (route.key) {\n    case 'music':\n      return <MusicRoute jumpTo={jumpTo} />;\n    case 'albums':\n      return <AlbumsRoute jumpTo={jumpTo} />;\n  }\n};\n```\n\nYou need to make sure that your individual routes implement a `shouldComponentUpdate` to improve the performance. To make it easier to specify the components, you can use the `SceneMap` helper.\n\n`SceneMap` takes an object with the mapping of `route.key` to React components and returns a function to use with `renderScene` prop.\n\n```js\nimport { SceneMap } from 'react-native-tab-view';\n\n...\n\nconst renderScene = SceneMap({\n  music: MusicRoute,\n  albums: AlbumsRoute,\n});\n```\n\nSpecifying the components this way is easier and takes care of implementing a `shouldComponentUpdate` method.\n\nEach scene receives the following props:\n\n- `route`: the current route rendered by the component\n- `jumpTo`: method to jump to other tabs, takes a `route.key` as it's argument\n- `position`: animated node which represents the current position\n\nThe `jumpTo` method can be used to navigate to other tabs programmatically:\n\n```js\nprops.jumpTo('albums');\n```\n\nAll the scenes rendered with `SceneMap` are optimized using `React.PureComponent` and don't re-render when parent's props or states change. If you need more control over how your scenes update (e.g. - triggering a re-render even if the `navigationState` didn't change), use `renderScene` directly instead of using `SceneMap`.\n\n**IMPORTANT:** **Do not** pass inline functions to `SceneMap`, for example, don't do the following:\n\n```js\nSceneMap({\n  first: () => <FirstRoute foo={props.foo} />,\n  second: SecondRoute,\n});\n```\n\nAlways define your components elsewhere in the top level of the file. If you pass inline functions, it'll re-create the component every render, which will cause the entire route to unmount and remount every change. It's very bad for performance and will also cause any local state to be lost.\n\nIf you need to pass additional props, use a custom `renderScene` function:\n\n```js\nconst renderScene = ({ route }) => {\n  switch (route.key) {\n    case 'first':\n      return <FirstRoute foo={this.props.foo} />;\n    case 'second':\n      return <SecondRoute />;\n    default:\n      return null;\n  }\n};\n```\n\n##### `renderTabBar`\n\nCallback which returns a custom React Element to use as the tab bar:\n\n```js\nimport { TabBar } from 'react-native-tab-view';\n\n...\n\n<TabView\n  renderTabBar={props => <TabBar {...props} />}\n  ...\n/>\n```\n\nIf this is not specified, the default tab bar is rendered. You pass this props to customize the default tab bar, provide your own tab bar, or disable the tab bar completely.\n\n```js\n<TabView\n  renderTabBar={() => null}\n  ...\n/>\n```\n\n##### `tabBarPosition`\n\nPosition of the tab bar in the tab view. Possible values are `'top'` and `'bottom'`. Defaults to `'top'`.\n\n##### `lazy`\n\nFunction which takes an object with the current route and returns a boolean to indicate whether to lazily render the scenes.\n\nBy default all scenes are rendered to provide a smoother swipe experience. But you might want to defer the rendering of unfocused scenes until the user sees them. To enable lazy rendering for a particular scene, return `true` from `lazy` for that `route`:\n\n```js\n<TabView\n  lazy={({ route }) => route.name === 'Albums'}\n  ...\n/>\n```\n\nWhen you enable lazy rendering for a screen, it will usually take some time to render when it comes into focus. You can use the `renderLazyPlaceholder` prop to customize what the user sees during this short period.\n\nYou can also pass a boolean to enable lazy for all of the scenes:\n\n```js\n<TabView lazy />\n```\n\n##### `lazyPreloadDistance`\n\nWhen `lazy` is enabled, you can specify how many adjacent routes should be preloaded with this prop. This value defaults to `0` which means lazy pages are loaded as they come into the viewport.\n\n##### `renderLazyPlaceholder`\n\nCallback which returns a custom React Element to render for routes that haven't been rendered yet. Receives an object containing the route as the argument. The `lazy` prop also needs to be enabled.\n\nThis view is usually only shown for a split second. Keep it lightweight.\n\nBy default, this renders `null`.\n\n##### `keyboardDismissMode`\n\nString indicating whether the keyboard gets dismissed in response to a drag gesture. Possible values are:\n\n- `'auto'` (default): the keyboard is dismissed when the index changes.\n- `'on-drag'`: the keyboard is dismissed when a drag begins.\n- `'none'`: drags do not dismiss the keyboard.\n\n##### `overScrollMode`\n\nUsed to override default value of pager's overScroll mode.\n\nPossible values:\n\n- `'auto'` (default): Allow a user to over-scroll this view only if the content is large enough to meaningfully scroll.\n- `'always'`: Always allow a user to over-scroll this view.\n- `'never'`: Never allow a user to over-scroll this view.\n\nOnly supported on Android.\n\n##### `swipeEnabled`\n\nBoolean indicating whether to enable swipe gestures. Swipe gestures are enabled by default. Passing `false` will disable swipe gestures, but the user can still switch tabs by pressing the tab bar.\n\n#### `animationEnabled`\n\nEnables animation when changing tab. By default it's true.\n\n##### `onSwipeStart`\n\nCallback which is called when the swipe gesture starts, i.e. the user touches the screen and moves it.\n\n##### `onSwipeEnd`\n\nCallback which is called when the swipe gesture ends, i.e. the user lifts their finger from the screen after the swipe gesture.\n\n##### `initialLayout`\n\nObject containing the initial height and width of the screens. Passing this will improve the initial rendering performance. For most apps, this is a good default:\n\n```js\n<TabView\n  initialLayout={{ width: Dimensions.get('window').width }}\n  ...\n/>\n```\n\n##### `pagerStyle`\n\nStyle to apply to the pager view wrapping all the scenes.\n\n##### `style`\n\nStyle to apply to the tab view container.\n\n### `TabBar`\n\nMaterial design themed tab bar. To customize the tab bar, you'd need to use the `renderTabBar` prop of `TabView` to render the `TabBar` and pass additional props.\n\nFor example, to customize the indicator color and the tab bar background color, you can pass `indicatorStyle` and `style` props to the `TabBar` respectively:\n\n```js\nconst renderTabBar = props => (\n  <TabBar\n    {...props}\n    indicatorStyle={{ backgroundColor: 'white' }}\n    style={{ backgroundColor: 'pink' }}\n  />\n);\n\n//...\n\n\nreturn (\n  <TabView\n    renderTabBar={renderTabBar}\n    ...\n  />\n);\n```\n\n#### TabBar Props\n\n##### `renderTabBarItem`\n\nFunction which takes a `TabBarItemProps` object and returns a custom React Element to be used as a tab button.\n\n##### `renderIndicator`\n\nFunction which takes an object with the current route and returns a custom React Element to be used as a tab indicator.\n\n##### `onTabPress`\n\nFunction to execute on tab press. It receives the scene for the pressed tab, useful for things like scroll to top.\n\nBy default, tab press also switches the tab. To prevent this behavior, you can call `preventDefault`:\n\n```js\n<TabBar\n  onTabPress={({ route, preventDefault }) => {\n    if (route.key === 'home') {\n      preventDefault();\n\n      // Do something else\n    }\n  }}\n  ...\n/>\n```\n\n##### `onTabLongPress`\n\nFunction to execute on tab long press, use for things like showing a menu with more options\n\n##### `activeColor`\n\nCustom color for icon and label in the active tab.\n\n##### `inactiveColor`\n\nCustom color for icon and label in the inactive tab.\n\n##### `pressColor`\n\nColor for material ripple (Android >= 5.0 only).\n\n##### `pressOpacity`\n\nOpacity for pressed tab (iOS and Android < 5.0 only).\n\n##### `scrollEnabled`\n\nBoolean indicating whether to make the tab bar scrollable.\n\nIf you set `scrollEnabled` to `true`, you should also specify a `width` in `tabStyle` to improve the initial render.\n\n##### `bounces`\n\nBoolean indicating whether the tab bar bounces when scrolling.\n\n##### `tabStyle`\n\nStyle to apply to the individual tab items in the tab bar.\n\nBy default, all tab items take up the same pre-calculated width based on the width of the container. If you want them to take their original width, you can specify `width: 'auto'` in `tabStyle`.\n\n##### `indicatorStyle`\n\nStyle to apply to the active indicator.\n\n##### `indicatorContainerStyle`\n\nStyle to apply to the container view for the indicator.\n\n##### `contentContainerStyle`\n\nStyle to apply to the inner container for tabs.\n\n##### `style` (`TabBar`)\n\nStyle to apply to the tab bar container.\n\n##### `gap`\n\nSpacing between the tab items.\n\n##### `testID` (`TabBar`)\n\nTest ID for the tab bar. Can be used for scrolling the tab bar in tests\n\n#### Options\n\nOptions describe how each tab should be configured. There are 2 ways to specify options:\n\n- `commonOptions`: Options that apply to all tabs.\n- `options`: Options that apply to specific tabs. It has the route key as the key and the object with options.\n\nExample:\n\n```js\n<TabView\n  commonOptions={{\n    icon: ({ route, focused, color }) => (\n      <Icon name={route.icon} color={color} />\n    ),\n  }}\n  options={{\n    albums: {\n      labelText: 'Albums',\n    },\n    profile: {\n      labelText: 'Profile',\n    },\n  }}\n/>\n```\n\nThe following options are available:\n\n##### `accessibilityLabel`\n\nAccessibility label for the tab button. Uses `route.accessibilityLabel` by default if specified, otherwise uses the route title.\n\n##### `accessible`\n\nWhether to mark the tab as `accessible`. Defaults to `true`.\n\n##### `testID`\n\nTest ID for the tab button. Uses `route.testID` by default.\n\n##### `labelText`\n\nLabel text for the tab button. Uses `route.title` by default.\n\n##### `labelAllowFontScaling`\n\nWhether label font should scale to respect Text Size accessibility settings. Defaults to `true`.\n\n##### `href`\n\nURL to use for the anchor tag for the tab button on the Web.\n\n##### `label`\n\nA function that returns a custom React Element to be used as a label. The function receives an object with the following properties:\n\n- `route` - The route object for the tab.\n- `labelText` - The label text for the tab specified in the `labelText` option or the `route title`.\n- `focused` - Whether the label is for the focused state.\n- `color` - The color of the label.\n- `allowFontScaling` - Whether label font should scale to respect Text Size accessibility settings.\n- `style` - The style object for the label.\n\n```js\nlabel: ({ route, labelText, focused, color }) => (\n  <Text style={{ color, margin: 8 }}>{labelText ?? route.name}</Text>\n);\n```\n\n##### `labelStyle`\n\nStyle to apply to the tab item label.\n\n##### `icon`\n\nA function that returns a custom React Element to be used as an icon. The function receives an object with the following properties:\n\n- `route` - The route object for the tab.\n- `focused` - Whether the icon is for the focused state.\n- `color` - The color of the icon.\n- `size` - The size of the icon.\n\n```js\nicon: ({ route, focused, color }) => (\n  <Icon name={focused ? 'albums' : 'albums-outlined'} color={color} />\n);\n```\n\n##### `badge`\n\nA function that returns a custom React Element to be used as a badge. The function receives an object with the following properties:\n\n- `route` - The route object for the tab.\n\n```js\nbadge: ({ route }) => (\n  <View\n    style={{ backgroundColor: 'red', width: 20, height: 20, borderRadius: 10 }}\n  />\n);\n```\n\n##### `sceneStyle`\n\nStyle to apply to the view wrapping each screen. You can pass this to override some default styles such as overflow clipping.\n\n## Optimization Tips\n\n### Avoid unnecessary re-renders\n\nThe `renderScene` function is called every time the index changes. If your `renderScene` function is expensive, it's good idea move each route to a separate component if they don't depend on the index, and use `shouldComponentUpdate` or `React.memo` in your route components to prevent unnecessary re-renders.\n\nFor example, instead of:\n\n```js\nconst renderScene = ({ route }) => {\n  switch (route.key) {\n    case 'home':\n      return (\n        <View style={styles.page}>\n          <Avatar />\n          <NewsFeed />\n        </View>\n      );\n    default:\n      return null;\n  }\n};\n```\n\nDo the following:\n\n```js\nconst renderScene = ({ route }) => {\n  switch (route.key) {\n    case 'home':\n      return <HomeComponent />;\n    default:\n      return null;\n  }\n};\n```\n\nWhere `<HomeComponent />` is a `PureComponent` if you're using class components:\n\n```js\nexport default class HomeComponent extends React.PureComponent {\n  render() {\n    return (\n      <View style={styles.page}>\n        <Avatar />\n        <NewsFeed />\n      </View>\n    );\n  }\n}\n```\n\nOr, wrapped in `React.memo` if you're using function components:\n\n```js\nfunction HomeComponent() {\n  return (\n    <View style={styles.page}>\n      <Avatar />\n      <NewsFeed />\n    </View>\n  );\n}\n\nexport default React.memo(HomeComponent);\n```\n\n### Avoid one frame delay\n\nWe need to measure the width of the container and hence need to wait before rendering some elements on the screen. If you know the initial width upfront, you can pass it in and we won't need to wait for measuring it. Most of the time, it's just the window width.\n\nFor example, pass the following `initialLayout` to `TabView`:\n\n```js\nconst initialLayout = {\n  height: 0,\n  width: Dimensions.get('window').width,\n};\n```\n\nThe tab view will still react to changes in the dimension and adjust accordingly to accommodate things like orientation change.\n\n### Optimize large number of routes\n\nIf you've a large number of routes, especially images, it can slow the animation down a lot. You can instead render a limited number of routes.\n\nFor example, do the following to render only 2 routes on each side:\n\n```js\nconst renderScene = ({ route }) => {\n  if (Math.abs(index - routes.indexOf(route)) > 2) {\n    return <View />;\n  }\n\n  return <MySceneComponent route={route} />;\n};\n```\n\n### Avoid rendering TabView inside ScrollView\n\nNesting the `TabView` inside a vertical `ScrollView` will disable the optimizations in the `FlatList` components rendered inside the `TabView`. So avoid doing it if possible.\n\n### Use `lazy` and `renderLazyPlaceholder` props to render routes as needed\n\nThe `lazy` option is disabled by default to provide a smoother tab switching experience, but you can enable it and provide a placeholder component for a better lazy loading experience. Enabling `lazy` can improve initial load performance by rendering routes only when they come into view. Refer the [prop reference](#lazy) for more details.\n"},c=void 0,d={},h=[{value:"Installation",id:"installation",level:2},{value:"Quick start",id:"quick-start",level:2},{value:"More examples on Snack",id:"more-examples-on-snack",level:2},{value:"API reference",id:"api-reference",level:2},{value:"<code>TabView</code>",id:"tabview",level:3},{value:"TabView Props",id:"tabview-props",level:4},{value:"<code>navigationState</code> (<code>required</code>)",id:"navigationstate-required",level:5},{value:"<code>onIndexChange</code> (<code>required</code>)",id:"onindexchange-required",level:5},{value:"<code>renderScene</code> (<code>required</code>)",id:"renderscene-required",level:5},{value:"<code>renderTabBar</code>",id:"rendertabbar",level:5},{value:"<code>tabBarPosition</code>",id:"tabbarposition",level:5},{value:"<code>lazy</code>",id:"lazy",level:5},{value:"<code>lazyPreloadDistance</code>",id:"lazypreloaddistance",level:5},{value:"<code>renderLazyPlaceholder</code>",id:"renderlazyplaceholder",level:5},{value:"<code>keyboardDismissMode</code>",id:"keyboarddismissmode",level:5},{value:"<code>overScrollMode</code>",id:"overscrollmode",level:5},{value:"<code>swipeEnabled</code>",id:"swipeenabled",level:5},{value:"<code>animationEnabled</code>",id:"animationenabled",level:4},{value:"<code>onSwipeStart</code>",id:"onswipestart",level:5},{value:"<code>onSwipeEnd</code>",id:"onswipeend",level:5},{value:"<code>initialLayout</code>",id:"initiallayout",level:5},{value:"<code>pagerStyle</code>",id:"pagerstyle",level:5},{value:"<code>style</code>",id:"style",level:5},{value:"<code>TabBar</code>",id:"tabbar",level:3},{value:"TabBar Props",id:"tabbar-props",level:4},{value:"<code>renderTabBarItem</code>",id:"rendertabbaritem",level:5},{value:"<code>renderIndicator</code>",id:"renderindicator",level:5},{value:"<code>onTabPress</code>",id:"ontabpress",level:5},{value:"<code>onTabLongPress</code>",id:"ontablongpress",level:5},{value:"<code>activeColor</code>",id:"activecolor",level:5},{value:"<code>inactiveColor</code>",id:"inactivecolor",level:5},{value:"<code>pressColor</code>",id:"presscolor",level:5},{value:"<code>pressOpacity</code>",id:"pressopacity",level:5},{value:"<code>scrollEnabled</code>",id:"scrollenabled",level:5},{value:"<code>bounces</code>",id:"bounces",level:5},{value:"<code>tabStyle</code>",id:"tabstyle",level:5},{value:"<code>indicatorStyle</code>",id:"indicatorstyle",level:5},{value:"<code>indicatorContainerStyle</code>",id:"indicatorcontainerstyle",level:5},{value:"<code>contentContainerStyle</code>",id:"contentcontainerstyle",level:5},{value:"<code>style</code> (<code>TabBar</code>)",id:"style-tabbar",level:5},{value:"<code>gap</code>",id:"gap",level:5},{value:"<code>testID</code> (<code>TabBar</code>)",id:"testid-tabbar",level:5},{value:"Options",id:"options",level:4},{value:"<code>accessibilityLabel</code>",id:"accessibilitylabel",level:5},{value:"<code>accessible</code>",id:"accessible",level:5},{value:"<code>testID</code>",id:"testid",level:5},{value:"<code>labelText</code>",id:"labeltext",level:5},{value:"<code>labelAllowFontScaling</code>",id:"labelallowfontscaling",level:5},{value:"<code>href</code>",id:"href",level:5},{value:"<code>label</code>",id:"label",level:5},{value:"<code>labelStyle</code>",id:"labelstyle",level:5},{value:"<code>icon</code>",id:"icon",level:5},{value:"<code>badge</code>",id:"badge",level:5},{value:"<code>sceneStyle</code>",id:"scenestyle",level:5},{value:"Optimization Tips",id:"optimization-tips",level:2},{value:"Avoid unnecessary re-renders",id:"avoid-unnecessary-re-renders",level:3},{value:"Avoid one frame delay",id:"avoid-one-frame-delay",level:3},{value:"Optimize large number of routes",id:"optimize-large-number-of-routes",level:3},{value:"Avoid rendering TabView inside ScrollView",id:"avoid-rendering-tabview-inside-scrollview",level:3},{value:"Use <code>lazy</code> and <code>renderLazyPlaceholder</code> props to render routes as needed",id:"use-lazy-and-renderlazyplaceholder-props-to-render-routes-as-needed",level:3}];function u(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["React Native Tab View is a cross-platform Tab View component for React Native implemented using ",(0,o.jsx)(n.a,{href:"https://github.com/callstack/react-native-viewpager",children:(0,o.jsx)(n.code,{children:"react-native-pager-view"})})," on Android & iOS, and ",(0,o.jsx)(n.a,{href:"https://reactnative.dev/docs/panresponder",children:"PanResponder"})," on Web, macOS, and Windows."]}),"\n",(0,o.jsx)(n.p,{children:"It follows material design guidelines by default, but you can also use your own custom tab bar or position the tab bar at the bottom."}),"\n",(0,o.jsx)("video",{playsInline:!0,autoPlay:!0,muted:!0,loop:!0,style:{aspectRatio:.47465437788018433},children:(0,o.jsx)("source",{src:"/assets/7.x/tab-view.mp4"})}),"\n",(0,o.jsxs)(n.p,{children:["This package doesn't integrate with React Navigation. If you want to integrate the tab view with React Navigation's navigation system, e.g. want to show screens in the tab bar and be able to navigate between them using ",(0,o.jsx)(n.code,{children:"navigation.navigate"})," etc, use ",(0,o.jsx)(n.a,{href:"/docs/material-top-tab-navigator",children:"Material Top Tab Navigator"})," instead."]}),"\n",(0,o.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,o.jsx)(n.p,{children:"To use this package, open a Terminal in the project root and run:"}),"\n",(0,o.jsxs)(r.A,{groupId:"npm2yarn",children:[(0,o.jsx)(s.A,{value:"npm",label:(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.img,{className:"pm-icon",src:"/assets/pm/npm.svg",alt:""}),"npm"]}),children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npm install react-native-tab-view\n"})})}),(0,o.jsx)(s.A,{value:"yarn",label:(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.img,{className:"pm-icon",src:"/assets/pm/yarn.svg",alt:""}),"yarn"]}),children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"yarn add react-native-tab-view\n"})})}),(0,o.jsx)(s.A,{value:"pnpm",label:(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.img,{className:"pm-icon",src:"/assets/pm/pnpm.svg",alt:""}),"pnpm"]}),children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"pnpm add react-native-tab-view\n"})})}),(0,o.jsx)(s.A,{value:"bun",label:(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.img,{className:"pm-icon",src:"/assets/pm/bun.svg",alt:""}),"bun"]}),children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"bun add react-native-tab-view\n"})})})]}),"\n",(0,o.jsxs)(n.p,{children:["The library depends on ",(0,o.jsx)(n.a,{href:"https://github.com/callstack/react-native-pager-view",children:(0,o.jsx)(n.code,{children:"react-native-pager-view"})})," for rendering the pages."]}),"\n",(0,o.jsxs)(r.A,{groupId:"framework",queryString:"framework",children:[(0,o.jsxs)(s.A,{value:"expo",label:"Expo",default:!0,children:[(0,o.jsx)(n.p,{children:"If you have a Expo managed project, in your project directory, run:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npx expo install react-native-pager-view\n"})})]}),(0,o.jsxs)(s.A,{value:"community-cli",label:"Community CLI",children:[(0,o.jsx)(n.p,{children:"If you have a bare React Native project, in your project directory, run:"}),(0,o.jsxs)(r.A,{groupId:"npm2yarn",children:[(0,o.jsx)(s.A,{value:"npm",label:(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.img,{className:"pm-icon",src:"/assets/pm/npm.svg",alt:""}),"npm"]}),children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npm install react-native-pager-view\n"})})}),(0,o.jsx)(s.A,{value:"yarn",label:(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.img,{className:"pm-icon",src:"/assets/pm/yarn.svg",alt:""}),"yarn"]}),children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"yarn add react-native-pager-view\n"})})}),(0,o.jsx)(s.A,{value:"pnpm",label:(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.img,{className:"pm-icon",src:"/assets/pm/pnpm.svg",alt:""}),"pnpm"]}),children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"pnpm add react-native-pager-view\n"})})}),(0,o.jsx)(s.A,{value:"bun",label:(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.img,{className:"pm-icon",src:"/assets/pm/bun.svg",alt:""}),"bun"]}),children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"bun add react-native-pager-view\n"})})})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["If you're on a Mac and developing for iOS, you also need to install ",(0,o.jsx)(n.a,{href:"https://cocoapods.org/",children:"pods"})," to complete the linking."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npx pod-install ios\n"})}),"\n",(0,o.jsx)(n.h2,{id:"quick-start",children:"Quick start"}),"\n",(0,o.jsx)(n.pre,{"data-name":"React Native Tab View","data-snack":"true",children:(0,o.jsx)(n.code,{className:"language-js",metastring:'name="React Native Tab View" snack',children:"// codeblock-focus-start\nimport * as React from 'react';\nimport { View, useWindowDimensions } from 'react-native';\nimport { TabView, SceneMap } from 'react-native-tab-view';\n\n// codeblock-focus-end\nconst FirstRoute = () => (\n  <View style={{ flex: 1, backgroundColor: '#ff4081' }} />\n);\n\nconst SecondRoute = () => (\n  <View style={{ flex: 1, backgroundColor: '#673ab7' }} />\n);\n\n// codeblock-focus-start\nconst renderScene = SceneMap({\n  first: FirstRoute,\n  second: SecondRoute,\n});\n\nconst routes = [\n  { key: 'first', title: 'First' },\n  { key: 'second', title: 'Second' },\n];\n\nexport default function TabViewExample() {\n  const layout = useWindowDimensions();\n  const [index, setIndex] = React.useState(0);\n\n  return (\n    <TabView\n      navigationState={{ index, routes }}\n      renderScene={renderScene}\n      onIndexChange={setIndex}\n      initialLayout={{ width: layout.width }}\n    />\n  );\n}\n// codeblock-focus-end\n"})}),"\n",(0,o.jsx)(n.h2,{id:"more-examples-on-snack",children:"More examples on Snack"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://snack.expo.io/@satya164/react-native-tab-view-custom-tabbar",children:"Custom Tab Bar"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://snack.expo.io/@satya164/react-native-tab-view-lazy-load",children:"Lazy Load"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"api-reference",children:"API reference"}),"\n",(0,o.jsxs)(n.p,{children:["The package exports a ",(0,o.jsx)(n.code,{children:"TabView"})," component which is the one you'd use to render the tab view, and a ",(0,o.jsx)(n.code,{children:"TabBar"})," component which is the default tab bar implementation."]}),"\n",(0,o.jsx)(n.h3,{id:"tabview",children:(0,o.jsx)(n.code,{children:"TabView"})}),"\n",(0,o.jsx)(n.p,{children:"Container component responsible for rendering and managing tabs. Follows material design styles by default."}),"\n",(0,o.jsx)(n.p,{children:"Basic usage look like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"<TabView\n  navigationState={{ index, routes }}\n  onIndexChange={setIndex}\n  renderScene={SceneMap({\n    first: FirstRoute,\n    second: SecondRoute,\n  })}\n/>\n"})}),"\n",(0,o.jsx)(n.h4,{id:"tabview-props",children:"TabView Props"}),"\n",(0,o.jsxs)(n.h5,{id:"navigationstate-required",children:[(0,o.jsx)(n.code,{children:"navigationState"})," (",(0,o.jsx)(n.code,{children:"required"}),")"]}),"\n",(0,o.jsx)(n.p,{children:"State for the tab view. The state should contain the following properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"index"}),": a number representing the index of the active route in the ",(0,o.jsx)(n.code,{children:"routes"})," array"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"routes"}),": an array containing a list of route objects used for rendering the tabs"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Each route object should contain the following properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"key"}),": a unique key to identify the route (required)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"title"}),": title for the route to display in the tab bar"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"icon"}),": icon for the route to display in the tab bar"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"accessibilityLabel"}),": accessibility label for the tab button"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"testID"}),": test id for the tab button"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"{\n  index: 1,\n  routes: [\n    { key: 'music', title: 'Music' },\n    { key: 'albums', title: 'Albums' },\n    { key: 'recents', title: 'Recents' },\n    { key: 'purchased', title: 'Purchased' },\n  ]\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"TabView"})," is a controlled component, which means the ",(0,o.jsx)(n.code,{children:"index"})," needs to be updated via the ",(0,o.jsx)(n.code,{children:"onIndexChange"})," callback."]}),"\n",(0,o.jsxs)(n.h5,{id:"onindexchange-required",children:[(0,o.jsx)(n.code,{children:"onIndexChange"})," (",(0,o.jsx)(n.code,{children:"required"}),")"]}),"\n",(0,o.jsx)(n.p,{children:"Callback which is called on tab change, receives the index of the new tab as argument.\nThe navigation state needs to be updated when it's called, otherwise the change is dropped."}),"\n",(0,o.jsxs)(n.h5,{id:"renderscene-required",children:[(0,o.jsx)(n.code,{children:"renderScene"})," (",(0,o.jsx)(n.code,{children:"required"}),")"]}),"\n",(0,o.jsx)(n.p,{children:"Callback which returns a react element to render as the page for the tab. Receives an object containing the route as the argument:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const renderScene = ({ route, jumpTo }) => {\n  switch (route.key) {\n    case 'music':\n      return <MusicRoute jumpTo={jumpTo} />;\n    case 'albums':\n      return <AlbumsRoute jumpTo={jumpTo} />;\n  }\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You need to make sure that your individual routes implement a ",(0,o.jsx)(n.code,{children:"shouldComponentUpdate"})," to improve the performance. To make it easier to specify the components, you can use the ",(0,o.jsx)(n.code,{children:"SceneMap"})," helper."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"SceneMap"})," takes an object with the mapping of ",(0,o.jsx)(n.code,{children:"route.key"})," to React components and returns a function to use with ",(0,o.jsx)(n.code,{children:"renderScene"})," prop."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { SceneMap } from 'react-native-tab-view';\n\n...\n\nconst renderScene = SceneMap({\n  music: MusicRoute,\n  albums: AlbumsRoute,\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Specifying the components this way is easier and takes care of implementing a ",(0,o.jsx)(n.code,{children:"shouldComponentUpdate"})," method."]}),"\n",(0,o.jsx)(n.p,{children:"Each scene receives the following props:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"route"}),": the current route rendered by the component"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"jumpTo"}),": method to jump to other tabs, takes a ",(0,o.jsx)(n.code,{children:"route.key"})," as it's argument"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"position"}),": animated node which represents the current position"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"jumpTo"})," method can be used to navigate to other tabs programmatically:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"props.jumpTo('albums');\n"})}),"\n",(0,o.jsxs)(n.p,{children:["All the scenes rendered with ",(0,o.jsx)(n.code,{children:"SceneMap"})," are optimized using ",(0,o.jsx)(n.code,{children:"React.PureComponent"})," and don't re-render when parent's props or states change. If you need more control over how your scenes update (e.g. - triggering a re-render even if the ",(0,o.jsx)(n.code,{children:"navigationState"})," didn't change), use ",(0,o.jsx)(n.code,{children:"renderScene"})," directly instead of using ",(0,o.jsx)(n.code,{children:"SceneMap"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"IMPORTANT:"})," ",(0,o.jsx)(n.strong,{children:"Do not"})," pass inline functions to ",(0,o.jsx)(n.code,{children:"SceneMap"}),", for example, don't do the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"SceneMap({\n  first: () => <FirstRoute foo={props.foo} />,\n  second: SecondRoute,\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"Always define your components elsewhere in the top level of the file. If you pass inline functions, it'll re-create the component every render, which will cause the entire route to unmount and remount every change. It's very bad for performance and will also cause any local state to be lost."}),"\n",(0,o.jsxs)(n.p,{children:["If you need to pass additional props, use a custom ",(0,o.jsx)(n.code,{children:"renderScene"})," function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const renderScene = ({ route }) => {\n  switch (route.key) {\n    case 'first':\n      return <FirstRoute foo={this.props.foo} />;\n    case 'second':\n      return <SecondRoute />;\n    default:\n      return null;\n  }\n};\n"})}),"\n",(0,o.jsx)(n.h5,{id:"rendertabbar",children:(0,o.jsx)(n.code,{children:"renderTabBar"})}),"\n",(0,o.jsx)(n.p,{children:"Callback which returns a custom React Element to use as the tab bar:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { TabBar } from 'react-native-tab-view';\n\n...\n\n<TabView\n  renderTabBar={props => <TabBar {...props} />}\n  ...\n/>\n"})}),"\n",(0,o.jsx)(n.p,{children:"If this is not specified, the default tab bar is rendered. You pass this props to customize the default tab bar, provide your own tab bar, or disable the tab bar completely."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"<TabView\n  renderTabBar={() => null}\n  ...\n/>\n"})}),"\n",(0,o.jsx)(n.h5,{id:"tabbarposition",children:(0,o.jsx)(n.code,{children:"tabBarPosition"})}),"\n",(0,o.jsxs)(n.p,{children:["Position of the tab bar in the tab view. Possible values are ",(0,o.jsx)(n.code,{children:"'top'"})," and ",(0,o.jsx)(n.code,{children:"'bottom'"}),". Defaults to ",(0,o.jsx)(n.code,{children:"'top'"}),"."]}),"\n",(0,o.jsx)(n.h5,{id:"lazy",children:(0,o.jsx)(n.code,{children:"lazy"})}),"\n",(0,o.jsx)(n.p,{children:"Function which takes an object with the current route and returns a boolean to indicate whether to lazily render the scenes."}),"\n",(0,o.jsxs)(n.p,{children:["By default all scenes are rendered to provide a smoother swipe experience. But you might want to defer the rendering of unfocused scenes until the user sees them. To enable lazy rendering for a particular scene, return ",(0,o.jsx)(n.code,{children:"true"})," from ",(0,o.jsx)(n.code,{children:"lazy"})," for that ",(0,o.jsx)(n.code,{children:"route"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"<TabView\n  lazy={({ route }) => route.name === 'Albums'}\n  ...\n/>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When you enable lazy rendering for a screen, it will usually take some time to render when it comes into focus. You can use the ",(0,o.jsx)(n.code,{children:"renderLazyPlaceholder"})," prop to customize what the user sees during this short period."]}),"\n",(0,o.jsx)(n.p,{children:"You can also pass a boolean to enable lazy for all of the scenes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"<TabView lazy />\n"})}),"\n",(0,o.jsx)(n.h5,{id:"lazypreloaddistance",children:(0,o.jsx)(n.code,{children:"lazyPreloadDistance"})}),"\n",(0,o.jsxs)(n.p,{children:["When ",(0,o.jsx)(n.code,{children:"lazy"})," is enabled, you can specify how many adjacent routes should be preloaded with this prop. This value defaults to ",(0,o.jsx)(n.code,{children:"0"})," which means lazy pages are loaded as they come into the viewport."]}),"\n",(0,o.jsx)(n.h5,{id:"renderlazyplaceholder",children:(0,o.jsx)(n.code,{children:"renderLazyPlaceholder"})}),"\n",(0,o.jsxs)(n.p,{children:["Callback which returns a custom React Element to render for routes that haven't been rendered yet. Receives an object containing the route as the argument. The ",(0,o.jsx)(n.code,{children:"lazy"})," prop also needs to be enabled."]}),"\n",(0,o.jsx)(n.p,{children:"This view is usually only shown for a split second. Keep it lightweight."}),"\n",(0,o.jsxs)(n.p,{children:["By default, this renders ",(0,o.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,o.jsx)(n.h5,{id:"keyboarddismissmode",children:(0,o.jsx)(n.code,{children:"keyboardDismissMode"})}),"\n",(0,o.jsx)(n.p,{children:"String indicating whether the keyboard gets dismissed in response to a drag gesture. Possible values are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"'auto'"})," (default): the keyboard is dismissed when the index changes."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"'on-drag'"}),": the keyboard is dismissed when a drag begins."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"'none'"}),": drags do not dismiss the keyboard."]}),"\n"]}),"\n",(0,o.jsx)(n.h5,{id:"overscrollmode",children:(0,o.jsx)(n.code,{children:"overScrollMode"})}),"\n",(0,o.jsx)(n.p,{children:"Used to override default value of pager's overScroll mode."}),"\n",(0,o.jsx)(n.p,{children:"Possible values:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"'auto'"})," (default): Allow a user to over-scroll this view only if the content is large enough to meaningfully scroll."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"'always'"}),": Always allow a user to over-scroll this view."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"'never'"}),": Never allow a user to over-scroll this view."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Only supported on Android."}),"\n",(0,o.jsx)(n.h5,{id:"swipeenabled",children:(0,o.jsx)(n.code,{children:"swipeEnabled"})}),"\n",(0,o.jsxs)(n.p,{children:["Boolean indicating whether to enable swipe gestures. Swipe gestures are enabled by default. Passing ",(0,o.jsx)(n.code,{children:"false"})," will disable swipe gestures, but the user can still switch tabs by pressing the tab bar."]}),"\n",(0,o.jsx)(n.h4,{id:"animationenabled",children:(0,o.jsx)(n.code,{children:"animationEnabled"})}),"\n",(0,o.jsx)(n.p,{children:"Enables animation when changing tab. By default it's true."}),"\n",(0,o.jsx)(n.h5,{id:"onswipestart",children:(0,o.jsx)(n.code,{children:"onSwipeStart"})}),"\n",(0,o.jsx)(n.p,{children:"Callback which is called when the swipe gesture starts, i.e. the user touches the screen and moves it."}),"\n",(0,o.jsx)(n.h5,{id:"onswipeend",children:(0,o.jsx)(n.code,{children:"onSwipeEnd"})}),"\n",(0,o.jsx)(n.p,{children:"Callback which is called when the swipe gesture ends, i.e. the user lifts their finger from the screen after the swipe gesture."}),"\n",(0,o.jsx)(n.h5,{id:"initiallayout",children:(0,o.jsx)(n.code,{children:"initialLayout"})}),"\n",(0,o.jsx)(n.p,{children:"Object containing the initial height and width of the screens. Passing this will improve the initial rendering performance. For most apps, this is a good default:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"<TabView\n  initialLayout={{ width: Dimensions.get('window').width }}\n  ...\n/>\n"})}),"\n",(0,o.jsx)(n.h5,{id:"pagerstyle",children:(0,o.jsx)(n.code,{children:"pagerStyle"})}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the pager view wrapping all the scenes."}),"\n",(0,o.jsx)(n.h5,{id:"style",children:(0,o.jsx)(n.code,{children:"style"})}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the tab view container."}),"\n",(0,o.jsx)(n.h3,{id:"tabbar",children:(0,o.jsx)(n.code,{children:"TabBar"})}),"\n",(0,o.jsxs)(n.p,{children:["Material design themed tab bar. To customize the tab bar, you'd need to use the ",(0,o.jsx)(n.code,{children:"renderTabBar"})," prop of ",(0,o.jsx)(n.code,{children:"TabView"})," to render the ",(0,o.jsx)(n.code,{children:"TabBar"})," and pass additional props."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, to customize the indicator color and the tab bar background color, you can pass ",(0,o.jsx)(n.code,{children:"indicatorStyle"})," and ",(0,o.jsx)(n.code,{children:"style"})," props to the ",(0,o.jsx)(n.code,{children:"TabBar"})," respectively:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const renderTabBar = props => (\n  <TabBar\n    {...props}\n    indicatorStyle={{ backgroundColor: 'white' }}\n    style={{ backgroundColor: 'pink' }}\n  />\n);\n\n//...\n\n\nreturn (\n  <TabView\n    renderTabBar={renderTabBar}\n    ...\n  />\n);\n"})}),"\n",(0,o.jsx)(n.h4,{id:"tabbar-props",children:"TabBar Props"}),"\n",(0,o.jsx)(n.h5,{id:"rendertabbaritem",children:(0,o.jsx)(n.code,{children:"renderTabBarItem"})}),"\n",(0,o.jsxs)(n.p,{children:["Function which takes a ",(0,o.jsx)(n.code,{children:"TabBarItemProps"})," object and returns a custom React Element to be used as a tab button."]}),"\n",(0,o.jsx)(n.h5,{id:"renderindicator",children:(0,o.jsx)(n.code,{children:"renderIndicator"})}),"\n",(0,o.jsx)(n.p,{children:"Function which takes an object with the current route and returns a custom React Element to be used as a tab indicator."}),"\n",(0,o.jsx)(n.h5,{id:"ontabpress",children:(0,o.jsx)(n.code,{children:"onTabPress"})}),"\n",(0,o.jsx)(n.p,{children:"Function to execute on tab press. It receives the scene for the pressed tab, useful for things like scroll to top."}),"\n",(0,o.jsxs)(n.p,{children:["By default, tab press also switches the tab. To prevent this behavior, you can call ",(0,o.jsx)(n.code,{children:"preventDefault"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"<TabBar\n  onTabPress={({ route, preventDefault }) => {\n    if (route.key === 'home') {\n      preventDefault();\n\n      // Do something else\n    }\n  }}\n  ...\n/>\n"})}),"\n",(0,o.jsx)(n.h5,{id:"ontablongpress",children:(0,o.jsx)(n.code,{children:"onTabLongPress"})}),"\n",(0,o.jsx)(n.p,{children:"Function to execute on tab long press, use for things like showing a menu with more options"}),"\n",(0,o.jsx)(n.h5,{id:"activecolor",children:(0,o.jsx)(n.code,{children:"activeColor"})}),"\n",(0,o.jsx)(n.p,{children:"Custom color for icon and label in the active tab."}),"\n",(0,o.jsx)(n.h5,{id:"inactivecolor",children:(0,o.jsx)(n.code,{children:"inactiveColor"})}),"\n",(0,o.jsx)(n.p,{children:"Custom color for icon and label in the inactive tab."}),"\n",(0,o.jsx)(n.h5,{id:"presscolor",children:(0,o.jsx)(n.code,{children:"pressColor"})}),"\n",(0,o.jsx)(n.p,{children:"Color for material ripple (Android >= 5.0 only)."}),"\n",(0,o.jsx)(n.h5,{id:"pressopacity",children:(0,o.jsx)(n.code,{children:"pressOpacity"})}),"\n",(0,o.jsx)(n.p,{children:"Opacity for pressed tab (iOS and Android < 5.0 only)."}),"\n",(0,o.jsx)(n.h5,{id:"scrollenabled",children:(0,o.jsx)(n.code,{children:"scrollEnabled"})}),"\n",(0,o.jsx)(n.p,{children:"Boolean indicating whether to make the tab bar scrollable."}),"\n",(0,o.jsxs)(n.p,{children:["If you set ",(0,o.jsx)(n.code,{children:"scrollEnabled"})," to ",(0,o.jsx)(n.code,{children:"true"}),", you should also specify a ",(0,o.jsx)(n.code,{children:"width"})," in ",(0,o.jsx)(n.code,{children:"tabStyle"})," to improve the initial render."]}),"\n",(0,o.jsx)(n.h5,{id:"bounces",children:(0,o.jsx)(n.code,{children:"bounces"})}),"\n",(0,o.jsx)(n.p,{children:"Boolean indicating whether the tab bar bounces when scrolling."}),"\n",(0,o.jsx)(n.h5,{id:"tabstyle",children:(0,o.jsx)(n.code,{children:"tabStyle"})}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the individual tab items in the tab bar."}),"\n",(0,o.jsxs)(n.p,{children:["By default, all tab items take up the same pre-calculated width based on the width of the container. If you want them to take their original width, you can specify ",(0,o.jsx)(n.code,{children:"width: 'auto'"})," in ",(0,o.jsx)(n.code,{children:"tabStyle"}),"."]}),"\n",(0,o.jsx)(n.h5,{id:"indicatorstyle",children:(0,o.jsx)(n.code,{children:"indicatorStyle"})}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the active indicator."}),"\n",(0,o.jsx)(n.h5,{id:"indicatorcontainerstyle",children:(0,o.jsx)(n.code,{children:"indicatorContainerStyle"})}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the container view for the indicator."}),"\n",(0,o.jsx)(n.h5,{id:"contentcontainerstyle",children:(0,o.jsx)(n.code,{children:"contentContainerStyle"})}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the inner container for tabs."}),"\n",(0,o.jsxs)(n.h5,{id:"style-tabbar",children:[(0,o.jsx)(n.code,{children:"style"})," (",(0,o.jsx)(n.code,{children:"TabBar"}),")"]}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the tab bar container."}),"\n",(0,o.jsx)(n.h5,{id:"gap",children:(0,o.jsx)(n.code,{children:"gap"})}),"\n",(0,o.jsx)(n.p,{children:"Spacing between the tab items."}),"\n",(0,o.jsxs)(n.h5,{id:"testid-tabbar",children:[(0,o.jsx)(n.code,{children:"testID"})," (",(0,o.jsx)(n.code,{children:"TabBar"}),")"]}),"\n",(0,o.jsx)(n.p,{children:"Test ID for the tab bar. Can be used for scrolling the tab bar in tests"}),"\n",(0,o.jsx)(n.h4,{id:"options",children:"Options"}),"\n",(0,o.jsx)(n.p,{children:"Options describe how each tab should be configured. There are 2 ways to specify options:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"commonOptions"}),": Options that apply to all tabs."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"options"}),": Options that apply to specific tabs. It has the route key as the key and the object with options."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"<TabView\n  commonOptions={{\n    icon: ({ route, focused, color }) => (\n      <Icon name={route.icon} color={color} />\n    ),\n  }}\n  options={{\n    albums: {\n      labelText: 'Albums',\n    },\n    profile: {\n      labelText: 'Profile',\n    },\n  }}\n/>\n"})}),"\n",(0,o.jsx)(n.p,{children:"The following options are available:"}),"\n",(0,o.jsx)(n.h5,{id:"accessibilitylabel",children:(0,o.jsx)(n.code,{children:"accessibilityLabel"})}),"\n",(0,o.jsxs)(n.p,{children:["Accessibility label for the tab button. Uses ",(0,o.jsx)(n.code,{children:"route.accessibilityLabel"})," by default if specified, otherwise uses the route title."]}),"\n",(0,o.jsx)(n.h5,{id:"accessible",children:(0,o.jsx)(n.code,{children:"accessible"})}),"\n",(0,o.jsxs)(n.p,{children:["Whether to mark the tab as ",(0,o.jsx)(n.code,{children:"accessible"}),". Defaults to ",(0,o.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,o.jsx)(n.h5,{id:"testid",children:(0,o.jsx)(n.code,{children:"testID"})}),"\n",(0,o.jsxs)(n.p,{children:["Test ID for the tab button. Uses ",(0,o.jsx)(n.code,{children:"route.testID"})," by default."]}),"\n",(0,o.jsx)(n.h5,{id:"labeltext",children:(0,o.jsx)(n.code,{children:"labelText"})}),"\n",(0,o.jsxs)(n.p,{children:["Label text for the tab button. Uses ",(0,o.jsx)(n.code,{children:"route.title"})," by default."]}),"\n",(0,o.jsx)(n.h5,{id:"labelallowfontscaling",children:(0,o.jsx)(n.code,{children:"labelAllowFontScaling"})}),"\n",(0,o.jsxs)(n.p,{children:["Whether label font should scale to respect Text Size accessibility settings. Defaults to ",(0,o.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,o.jsx)(n.h5,{id:"href",children:(0,o.jsx)(n.code,{children:"href"})}),"\n",(0,o.jsx)(n.p,{children:"URL to use for the anchor tag for the tab button on the Web."}),"\n",(0,o.jsx)(n.h5,{id:"label",children:(0,o.jsx)(n.code,{children:"label"})}),"\n",(0,o.jsx)(n.p,{children:"A function that returns a custom React Element to be used as a label. The function receives an object with the following properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"route"})," - The route object for the tab."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"labelText"})," - The label text for the tab specified in the ",(0,o.jsx)(n.code,{children:"labelText"})," option or the ",(0,o.jsx)(n.code,{children:"route title"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"focused"})," - Whether the label is for the focused state."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"color"})," - The color of the label."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"allowFontScaling"})," - Whether label font should scale to respect Text Size accessibility settings."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"style"})," - The style object for the label."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"label: ({ route, labelText, focused, color }) => (\n  <Text style={{ color, margin: 8 }}>{labelText ?? route.name}</Text>\n);\n"})}),"\n",(0,o.jsx)(n.h5,{id:"labelstyle",children:(0,o.jsx)(n.code,{children:"labelStyle"})}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the tab item label."}),"\n",(0,o.jsx)(n.h5,{id:"icon",children:(0,o.jsx)(n.code,{children:"icon"})}),"\n",(0,o.jsx)(n.p,{children:"A function that returns a custom React Element to be used as an icon. The function receives an object with the following properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"route"})," - The route object for the tab."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"focused"})," - Whether the icon is for the focused state."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"color"})," - The color of the icon."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"size"})," - The size of the icon."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"icon: ({ route, focused, color }) => (\n  <Icon name={focused ? 'albums' : 'albums-outlined'} color={color} />\n);\n"})}),"\n",(0,o.jsx)(n.h5,{id:"badge",children:(0,o.jsx)(n.code,{children:"badge"})}),"\n",(0,o.jsx)(n.p,{children:"A function that returns a custom React Element to be used as a badge. The function receives an object with the following properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"route"})," - The route object for the tab."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"badge: ({ route }) => (\n  <View\n    style={{ backgroundColor: 'red', width: 20, height: 20, borderRadius: 10 }}\n  />\n);\n"})}),"\n",(0,o.jsx)(n.h5,{id:"scenestyle",children:(0,o.jsx)(n.code,{children:"sceneStyle"})}),"\n",(0,o.jsx)(n.p,{children:"Style to apply to the view wrapping each screen. You can pass this to override some default styles such as overflow clipping."}),"\n",(0,o.jsx)(n.h2,{id:"optimization-tips",children:"Optimization Tips"}),"\n",(0,o.jsx)(n.h3,{id:"avoid-unnecessary-re-renders",children:"Avoid unnecessary re-renders"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"renderScene"})," function is called every time the index changes. If your ",(0,o.jsx)(n.code,{children:"renderScene"})," function is expensive, it's good idea move each route to a separate component if they don't depend on the index, and use ",(0,o.jsx)(n.code,{children:"shouldComponentUpdate"})," or ",(0,o.jsx)(n.code,{children:"React.memo"})," in your route components to prevent unnecessary re-renders."]}),"\n",(0,o.jsx)(n.p,{children:"For example, instead of:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const renderScene = ({ route }) => {\n  switch (route.key) {\n    case 'home':\n      return (\n        <View style={styles.page}>\n          <Avatar />\n          <NewsFeed />\n        </View>\n      );\n    default:\n      return null;\n  }\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"Do the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const renderScene = ({ route }) => {\n  switch (route.key) {\n    case 'home':\n      return <HomeComponent />;\n    default:\n      return null;\n  }\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Where ",(0,o.jsx)(n.code,{children:"<HomeComponent />"})," is a ",(0,o.jsx)(n.code,{children:"PureComponent"})," if you're using class components:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export default class HomeComponent extends React.PureComponent {\n  render() {\n    return (\n      <View style={styles.page}>\n        <Avatar />\n        <NewsFeed />\n      </View>\n    );\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Or, wrapped in ",(0,o.jsx)(n.code,{children:"React.memo"})," if you're using function components:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function HomeComponent() {\n  return (\n    <View style={styles.page}>\n      <Avatar />\n      <NewsFeed />\n    </View>\n  );\n}\n\nexport default React.memo(HomeComponent);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"avoid-one-frame-delay",children:"Avoid one frame delay"}),"\n",(0,o.jsx)(n.p,{children:"We need to measure the width of the container and hence need to wait before rendering some elements on the screen. If you know the initial width upfront, you can pass it in and we won't need to wait for measuring it. Most of the time, it's just the window width."}),"\n",(0,o.jsxs)(n.p,{children:["For example, pass the following ",(0,o.jsx)(n.code,{children:"initialLayout"})," to ",(0,o.jsx)(n.code,{children:"TabView"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const initialLayout = {\n  height: 0,\n  width: Dimensions.get('window').width,\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"The tab view will still react to changes in the dimension and adjust accordingly to accommodate things like orientation change."}),"\n",(0,o.jsx)(n.h3,{id:"optimize-large-number-of-routes",children:"Optimize large number of routes"}),"\n",(0,o.jsx)(n.p,{children:"If you've a large number of routes, especially images, it can slow the animation down a lot. You can instead render a limited number of routes."}),"\n",(0,o.jsx)(n.p,{children:"For example, do the following to render only 2 routes on each side:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const renderScene = ({ route }) => {\n  if (Math.abs(index - routes.indexOf(route)) > 2) {\n    return <View />;\n  }\n\n  return <MySceneComponent route={route} />;\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"avoid-rendering-tabview-inside-scrollview",children:"Avoid rendering TabView inside ScrollView"}),"\n",(0,o.jsxs)(n.p,{children:["Nesting the ",(0,o.jsx)(n.code,{children:"TabView"})," inside a vertical ",(0,o.jsx)(n.code,{children:"ScrollView"})," will disable the optimizations in the ",(0,o.jsx)(n.code,{children:"FlatList"})," components rendered inside the ",(0,o.jsx)(n.code,{children:"TabView"}),". So avoid doing it if possible."]}),"\n",(0,o.jsxs)(n.h3,{id:"use-lazy-and-renderlazyplaceholder-props-to-render-routes-as-needed",children:["Use ",(0,o.jsx)(n.code,{children:"lazy"})," and ",(0,o.jsx)(n.code,{children:"renderLazyPlaceholder"})," props to render routes as needed"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"lazy"})," option is disabled by default to provide a smoother tab switching experience, but you can enable it and provide a placeholder component for a better lazy loading experience. Enabling ",(0,o.jsx)(n.code,{children:"lazy"})," can improve initial load performance by rendering routes only when they come into view. Refer the ",(0,o.jsx)(n.a,{href:"#lazy",children:"prop reference"})," for more details."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>r});t(96540);var a=t(34164);const o={tabItem:"tabItem_Ymn6"};var i=t(74848);function r(e){let{children:n,hidden:t,className:r}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(o.tabItem,r),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>T});var a=t(96540),o=t(34164),i=t(17559),r=t(23104),s=t(56347),l=t(205),c=t(57485),d=t(31682),h=t(70679);function u(e){var n,t;return null!=(n=null==(t=a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:o}}=e;return{value:n,label:t,attributes:a,default:o}}))}(t);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function b(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const o=(0,s.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,c.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(o.location.search);n.set(i,e),o.replace(Object.assign({},o.location,{search:n.toString()}))}),[i,o])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,i=p(e),[r,s]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!b({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const o=null!=(n=a.find((e=>e.default)))?n:a[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:i}))),[c,d]=m({queryString:t,groupId:o}),[u,x]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[o,i]=(0,h.Dv)(t);return[o,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:o}),j=(()=>{const e=null!=c?c:u;return b({value:e,tabValues:i})?e:null})();(0,l.A)((()=>{j&&s(j)}),[j]);return{selectedValue:r,selectValue:(0,a.useCallback)((e=>{if(!b({value:e,tabValues:i}))throw new Error("Can't select invalid tab value="+e);s(e),d(e),x(e)}),[d,x,i]),tabValues:i}}var j=t(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=t(74848);function y(e){let{className:n,block:t,selectedValue:a,selectValue:i,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.a_)(),d=e=>{const n=e.currentTarget,t=l.indexOf(n),o=s[t].value;o!==a&&(c(n),i(o))},h=e=>{var n;let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var a;const n=l.indexOf(e.currentTarget)+1;t=null!=(a=l[n])?a:l[0];break}case"ArrowLeft":{var o;const n=l.indexOf(e.currentTarget)-1;t=null!=(o=l[n])?o:l[l.length-1];break}}null==(n=t)||n.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":t},n),children:s.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,g.jsx)("li",Object.assign({role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{l.push(e)},onKeyDown:h,onClick:d},i,{className:(0,o.A)("tabs__item",f.tabItem,null==i?void 0:i.className,{"tabs__item--active":a===n}),children:null!=t?t:n}),n)}))})}function v(e){let{lazy:n,children:t,selectedValue:i}=e;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function w(e){const n=x(e);return(0,g.jsxs)("div",{className:(0,o.A)(i.G.tabs.container,"tabs-container",f.tabList),children:[(0,g.jsx)(y,Object.assign({},n,e)),(0,g.jsx)(v,Object.assign({},n,e))]})}function T(e){const n=(0,j.A)();return(0,g.jsx)(w,Object.assign({},e,{children:u(e.children)}),String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(96540);const o={},i=a.createContext(o);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);