"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[21311],{45657:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"upgrading-from-7.x","title":"Upgrading from 7.x","description":"React Navigation 8 is still in pre-release stage. The API may still change before the stable release. Please provide any feedback or suggestions on GitHub Discussions.","source":"@site/versioned_docs/version-8.x/upgrading-from-7.x.md","sourceDirName":".","slug":"/upgrading-from-7.x","permalink":"/docs/8.x/upgrading-from-7.x","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-8.x/upgrading-from-7.x.md","tags":[],"version":"8.x","frontMatter":{"id":"upgrading-from-7.x","title":"Upgrading from 7.x","sidebar_label":"Upgrading from 7.x"},"sidebar":"docs","previous":{"title":"Troubleshooting","permalink":"/docs/8.x/troubleshooting"},"next":{"title":"Stack","permalink":"/docs/8.x/stack-navigator"}}');var o=t(74848),i=t(28453),r=t(11470),s=t(19365);const c={id:"upgrading-from-7.x",title:"Upgrading from 7.x",sidebar_label:"Upgrading from 7.x",rawMarkdown:"---\nid: upgrading-from-7.x\ntitle: Upgrading from 7.x\nsidebar_label: Upgrading from 7.x\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n:::warning\n\nReact Navigation 8 is still in pre-release stage. The API may still change before the stable release. Please provide any feedback or suggestions on [GitHub Discussions](https://github.com/react-navigation/react-navigation/discussions).\n\n:::\n\nThis guides lists all the breaking changes and new features in React Navigation 8 that you need to be aware of when upgrading from React Navigation 7.\n\n## Dependency changes\n\nThe minimum required version of React Native, Expo, and TypeScript have been bumped:\n\n- `react-native` >= 0.81 (planned to be bumped to 0.83)\n- `expo` >= 54 (planned to be bumped to 55)\n- `typescript` >= 5.9.2 (if you use TypeScript)\n\nThe minimum required version of various peer dependencies have also been bumped:\n\n- `react-native-screens` >= 4.20.0\n- `react-native-safe-area-context` >= 5.5.0\n- `react-native-reanimated` >= 4.0.0\n- `react-native-pager-view` >= 7.0.0 (8.0.0 is recommended)\n- `react-native-web` >= 0.21.0\n\nPreviously, many navigators worked without `react-native-screens`, but now it's required for all navigators.\n\nAdditionally, React Navigation now uses [`@callstack/liquid-glass`](https://github.com/callstack/liquid-glass) to implement liquid glass effect on iOS 26.\n\n:::warning\n\n[Expo Go](https://expo.dev/go) doesn't support React Navigation 8. So you need to create a [development build](https://docs.expo.dev/development/introduction/) of your app to use React Navigation 8 with Expo.\n\n:::\n\n## Breaking changes\n\n### Dropping support for old architecture\n\nReact Navigation 8 no longer supports the old architecture of React Native. The old architecture has been frozen since React Native 0.80 and removed in React Native 0.82.\n\nSo if you're still on the old architecture, you'll need to upgrade to the new architecture in order to use React Navigation 8.\n\n### Changes to TypeScript setup\n\nWe introduced a static API in React Navigation 7. However, some of the TypeScript types were not inferred and required manual annotations. In React Navigation 8, we reworked the TypeScript types to solve many of these issues.\n\n#### The root type now uses navigator type instead of param list\n\nPreviously the types for the root navigator were specified using `declare global` and `RootParamList`. Now, they can be specified with module augmentation of `@react-navigation/core` and use the navigator's type instead a param list:\n\n```diff lang=ts\n- type RootStackParamList = StaticParamList<typeof RootStack>;\n-\n- declare global {\n-   namespace ReactNavigation {\n-     interface RootParamList extends RootStackParamList {}\n-   }\n- }\n+ type RootStackType = typeof RootStack;\n+\n+ declare module '@react-navigation/core' {\n+   interface RootNavigator extends RootStackType {}\n+ }\n```\n\nUsing module augmentation is shorter, and avoids namespace usage - which ESLint may complain about in some configurations.\n\nUsing the navigator's type instead of a param list allows us to infer the type of navigators - primarily in case of static configuration.\n\n#### Common hooks no longer accept generics\n\nPreviously hooks such as `useNavigation`, `useRoute` and `useNavigationState` accepted a generic to override the default types. This is not type-safe as we cannot verify that the provided type matches the actual navigators, and we recommended minimizing such usage.\n\nIn React Navigation 8, we reworked the types to automatically determine the correct type [based on the name of the screen](#common-hooks-now-accept-name-of-the-screen) when using static config:\n\n```diff lang=ts\n- const navigation = useNavigation<StackNavigationProp<RootStackParamList, 'Profile'>>();\n+ const navigation = useNavigation('Profile');\n```\n\nIf you're using dynamic configuration, unfortunately we cannot currently infer the types automatically. So it still requires manual annotation. However, now you need to use `as` instead of generics to make it clearer that this is unsafe:\n\n```diff lang=ts\n- const navigation = useNavigation<StackNavigationProp<RootStackParamList, 'Profile'>>();\n+ const navigation = useNavigation() as StackNavigationProp<RootStackParamList, 'Profile'>;\n```\n\nThe `useRoute` type has been updated in the same way:\n\n```diff lang=ts\n- const route = useRoute<RouteProp<RootStackParamList, 'Profile'>>();\n+ const route = useRoute('Profile');\n```\n\nAnd if you're using dynamic configuration:\n\n```diff lang=ts\n- const route = useRoute<RouteProp<RootStackParamList, 'Profile'>>();\n+ const route = useRoute() as RouteProp<RootStackParamList, 'Profile'>;\n```\n\nSimilarly, the `useNavigationState` type has been updated to accept the name of the screen in addition to the selector:\n\n```diff lang=ts\n- const focusedRouteName = useNavigationState<RootStackParamList>((state) => state.routes[state.index].name);\n+ const focusedRouteName = useNavigationState('Settings', (state) => state.routes[state.index].name);\n```\n\nIf you're using dynamic configuration, you can use `as`:\n\n```diff lang=ts\n- const focusedRouteName = useNavigationState<RootStackParamList>((state) => state.routes[state.index].name);\n+ const focusedRouteName = useNavigationState((state) => state.routes[state.index].name as keyof RootStackParamList);\n```\n\n#### New `createXScreen` API for creating screen config\n\nOne of the limitations of the static config API is that the type of `route` object can't be inferred in screen callback, listeners callback etc. This made it difficult to use route params in these callbacks.\n\nTo address this, we added a new `createXScreen` API for each navigator to create screen config with proper types:\n\n```diff lang=js\nconst Stack = createStackNavigator({\n  screens: {\n-     Profile: {\n-       screen: ProfileScreen,\n-       options: ({ route }) => {\n-         const userId = route.params.userId; // Don't know the type of route params\n-\n-         return { title: `User ${userId}` };\n-       },\n-     },\n+     Profile: createStackScreen({\n+       screen: ProfileScreen,\n+       options: ({ route }) => {\n+         const userId = route.params.userId; // Now correctly inferred\n+\n+         return { title: `User ${userId}` };\n+       },\n+     });\n  }\n});\n```\n\nWhen using the `createXScreen` API, the type of params are automatically inferred based on the type annotation for the component specified in `screen` (e.g. `(props: StaticScreenProps<ProfileParams>)`) and the path pattern specified in the linking config (e.g. `linking: 'profile/:userId'`).\n\nEach navigator exports its own helper function, e.g. `createNativeStackScreen` for Native Stack Navigator, `createBottomTabScreen` for Bottom Tab Navigator, `createDrawerScreen` for Drawer Navigator etc.\n\n:::note\n\nThis is technically not a breaking change. It's not required to use this API and your existing code will continue to work as before. You can incrementally adopt this API for new screens to get proper types for `route` object in various callbacks such as `options`, `listeners`, etc.\n\n:::\n\nSee [Static configuration docs](static-configuration.md#createxscreen) for more details.\n\n#### Custom navigators now require overloads for types\n\nTo work with the reworked TypeScript types, custom navigators now need to provide overloads for static and dynamic configuration APIs, and an additional API to create screen config.\n\n```diff lang=ts\n- export function createMyNavigator<\n-   const ParamList extends ParamListBase,\n-   const NavigatorID extends string | undefined = string | undefined,\n-   const TypeBag extends NavigatorTypeBagBase = {\n-     ParamList: ParamList;\n-     NavigatorID: NavigatorID;\n-     State: TabNavigationState<ParamList>;\n-     ScreenOptions: MyNavigationOptions;\n-     EventMap: MyNavigationEventMap;\n-     NavigationList: {\n-       [RouteName in keyof ParamList]: MyNavigationProp<\n-         ParamList,\n-         RouteName,\n-         NavigatorID\n-       >;\n-     };\n-     Navigator: typeof MyNavigator;\n-   },\n-   const Config extends StaticConfig<TypeBag> = StaticConfig<TypeBag>,\n- >(config?: Config): TypedNavigator<TypeBag, Config> {\n-   return createNavigatorFactory(MyNavigator)(config);\n- }\n+ type MyTypeBag<ParamList extends {}> = {\n+   ParamList: ParamList;\n+   State: TabNavigationState<ParamList>;\n+   ScreenOptions: MyNavigationOptions;\n+   EventMap: MyNavigationEventMap;\n+   NavigationList: {\n+     [RouteName in keyof ParamList]: MyNavigationProp<\n+       ParamList,\n+       RouteName\n+     >;\n+   };\n+   Navigator: typeof MyNavigator;\n+ };\n+\n+ export function createMyNavigator<\n+   const ParamList extends ParamListBase,\n+ >(): TypedNavigator<MyTypeBag<ParamList>, undefined>;\n+ export function createMyNavigator<\n+   const Config extends StaticConfig<MyTypeBag<ParamListBase>>,\n+ >(\n+   config: Config\n+ ): TypedNavigator<\n+   MyTypeBag<StaticParamList<{ config: Config }>>,\n+   Config\n+ >;\n+ export function createMyNavigator(config?: unknown) {\n+   return createNavigatorFactory(MyNavigator)(config);\n+ }\n\n+ export function createMyScreen<\n+  const Linking extends StaticScreenConfigLinking,\n+  const Screen extends StaticScreenConfigScreen,\n+ >(\n+   config: StaticScreenConfig<\n+     Linking,\n+     Screen,\n+     TabNavigationState<ParamListBase>,\n+     MyNavigationOptions,\n+     MyNavigationEventMap,\n+     MyNavigationProp<ParamListBase>\n+   >\n+ ) {\n+   return config;\n+ }\n```\n\nSee [Custom navigators](custom-navigators.md) for more details.\n\n### Changes to navigators\n\n#### Native Bottom Tabs are now default\n\nPreviously, the Bottom Tab Navigator used a JavaScript-based implementation and a native implementation was available under `@react-navigation/bottom-tabs/unstable`. The `@react-navigation/bottom-tabs/unstable` entry point has been removed and it has been merged into the main package.\n\nNative bottom tabs are now used by default on iOS and Android. This allows us to match the new native design such as liquid glass effect on iOS 26.\n\nTo keep the previous behavior with JavaScript-based tabs, you can pass `implementation: 'custom'` to the navigator:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```diff lang=js\ncreateBottomTabNavigator({\n+   implementation: 'custom',\n  // ...\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```diff lang=js\n<Tab.Navigator\n+   implementation=\"custom\"\n  // ...\n>\n```\n\n</TabItem>\n</Tabs>\n\nAs part of this change, some of the options have changed to work with native tabs:\n\n- `tabBarShowLabel` is replaced with `tabBarLabelVisibilityMode` which accepts:\n  - `\"auto\"` (default)\n  - `\"selected\"`\n  - `\"labeled\"` - same as `tabBarShowLabel: true`\n  - `\"unlabeled\"` - same as `tabBarShowLabel: false`\n- `tabBarLabel` now only accepts a `string`\n- `tabBarIcon` now accepts an icon object or function that can return an icon object, returning a react element still works with `custom` implementation - so you don't need to change anything if you're using `custom` implementation.\n\nThe following props have been removed:\n\n- `safeAreaInsets` from the navigator props\n- `insets` from the bottom tab bar props\n- `layout` from the bottom tab bar props\n\nIf you use `insets` and `layout` in your custom tab bar, you can use [`useSafeAreaInsets`](https://appandflow.github.io/react-native-safe-area-context/api/use-safe-area-insets/) and [`useSafeAreaFrame`](https://appandflow.github.io/react-native-safe-area-context/api/use-safe-area-frame/) from [`react-native-safe-area-context`](https://github.com/th3rdwave/react-native-safe-area-context) instead to get the same values.\n\nSee the [Bottom Tab Navigator docs](bottom-tab-navigator.md) for all the available options.\n\n#### Bottom Tabs no longer shows header by default\n\nSince Bottom Tabs now renders native tabs by default, the header is no longer shown by default to match native look and feel. You can nest a [Native Stack Navigator](native-stack-navigator.md) inside each tab to show a header that integrates well with native tabs, e.g. [search tab on iOS 26+](bottom-tab-navigator.md#search-tab-on-ios-26).\n\nAlternatively, you can enable the built-in header by passing `headerShown: true` in `screenOptions` of the navigator:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```diff lang=js\ncreateBottomTabNavigator({\n  screenOptions: {\n+     headerShown: true,\n    // ...\n  },\n  // ...\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```diff lang=js\n<Tab.Navigator\n  screenOptions={{\n+     headerShown: true,\n    // ...\n  }}\n>\n```\n\n</TabItem>\n</Tabs>\n\n#### Preloaded screens now behave differently\n\nPreviously, when a screen was preloaded in Stack and Native Stack Navigators, there were a few restrictions:\n\n- Options could not be updated with [`setOptions`](navigation-object.md#setoptions) until the screen became active.\n- Adding listeners with [`addListener`](navigation-object.md#navigation-events) did nothing until the screen became active.\n- Preloaded screens could not contain nested navigators.\n\nIn addition, the `navigation` object received by preloaded screens was different from that of active screens. So it resulted in re-rendering the screen when it became active.\n\nWe have reworked the implementation of preloaded screens to make it more consistent with active screens:\n\n- Options can now be updated with `setOptions` even when the screen is preloaded.\n- Listeners added with `addListener` will now be called even when the screen is preloaded.\n- Preloaded screens can now contain nested navigators.\n- The `navigation` object now does not change when the screen becomes active.\n\nWhile this is a breaking change, your existing code will likely continue to work as before if you were not relying on any of the special behaviors of preloaded screens for your logic.\n\nIf your existing code checked `navigation.isFocused()` before calling `setOptions`, it will continue to work as before. However, you can now simplify such code by removing the check:\n\n```diff lang=js\n- if (navigation.isFocused()) {\n    navigation.setOptions({ title: 'New Title' });\n- }\n```\n\nSee [`navigation.preload`](navigation-object.md#preload) for usage details.\n\n#### Navigators no longer accept an `id` prop\n\nPreviously, navigators accepted an `id` prop to identify them - which was used with `navigation.getParent(id)` to get a parent navigator by id. However, there were a couple of issues with this approach:\n\n- It wasn't well integrated with TypeScript types, and required manual annotations.\n- The navigation object is specific to a screen, so using the navigator's id was inconsistent.\n- It was used for a very specific use case, so it added unnecessary complexity.\n\nIn React Navigation 8, we removed the `id` prop from navigators. Instead, you can use the screen's name to get a parent navigator:\n\n```diff lang=js\n- const parent = navigation.getParent('some-id');\n+ const parent = navigation.getParent('SomeScreenName');\n```\n\nIn this case, 'SomeScreenName' refers to the name of a parent screen that's used in the navigator.\n\nSee [navigation object docs](navigation-object.md#getparent) for more details.\n\n#### `setParams` no longer pushes to history in tab and drawer navigators when `backBehavior` is set to `fullHistory`\n\nPreviously, when using `setParams` in tab and drawer navigators with `backBehavior` set to `fullHistory`, it would push a new entry to the history stack.\n\nIn React Navigation 8, we [added a new `pushParams` action](#new-entry-can-be-added-to-history-stack-with-pushparams-action) that achieves this behavior. So `setParams` now only updates the params without affecting the history stack.\n\n```diff lang=js\n- navigation.setParams({ filter: 'new' });\n+ navigation.pushParams({ filter: 'new' });\n```\n\nThis way you have more control over how params are updated in tab and drawer navigators.\n\nSee [`setParams` action docs](navigation-actions.md#setparams) for more details.\n\n#### Navigators no longer use `InteractionManager`\n\nPreviously, various navigators used `InteractionManager` to mark when animations and gestures were in progress. This was primarily used to defer code that should run after transitions, such as loading data or rendering heavy components.\n\nHowever, `InteractionManager` has been deprecated in latest React Native versions, so we are removing support for this API in React Navigation 8. As an alternative, consumers can listen to events such as `transitionStart`, `transitionEnd` etc. when applicable:\n\n```diff lang=js\n- InteractionManager.runAfterInteractions(() => {\n-   // code to run after transition\n- });\n+ navigation.addListener('transitionEnd', () => {\n+   // code to run after transition\n+ });\n```\n\nKeep in mind that unlike `InteractionManager` which is global, the transition events are specific to a navigator.\n\nIf you have a use case that cannot be solved with transition events, please open a [discussion on GitHub](https://github.com/react-navigation/react-navigation/discussions).\n\n#### The color arguments in various navigators now accept `ColorValue`\n\nPreviously, color options in various navigators only accepted string values. In React Navigation 8, these options now accept `ColorValue` to match the [changes to theming](#themes-now-support-colorvalue-and-css-custom-properties).\n\nUnless you are using a custom theme with `PlatformColor` or `DynamicColorIOS` etc, this change only breaks TypeScript types:\n\n```diff lang=js\n- const tabBarIcon = ({ color, size }: { color: string, size: number }) => {\n+ const tabBarIcon = ({ color, size }: { color: ColorValue, size: number }) => {\n  // ...\n};\n```\n\nSee [Themes](themes.md#using-platform-colors) for more information about dynamic colors.\n\n#### Various components no longer receive layout related props\n\nPreviously, various components such as `Header`, `BottomTabBar`, and `DrawerContent` received layout related props such as `layout` - that contained the dimensions of the screen.\n\nThis meant that if the `layout` changed frequently, such as resizing the window on supported platforms (Web, Windows, macOS, iPadOS), it would need to re-render these components frequently - often not being able to keep up with the changes, leading to jank and poor performance.\n\nTo avoid this, we have removed layout related props from these components:\n\n- `layout` prop from `Header` component from `@react-navigation/elements`\n- `titleLayout` and `screenLayout` props from `HeaderBackButton` component from `@react-navigation/elements`\n- `layouts.title` and `layouts.leftLabel` parameters from `headerStyleInterpolator` in `@react-navigation/stack`\n- `layout` prop from `react-native-tab-view`\n- `layout` prop from `react-native-drawer-layout`\n\nSince React Native doesn't provide APIs to handle layout changes in styles, it may still be necessary to handle layout changes manually in some cases. So we have added a [`useFrameSize`](elements.md#useframesize) hook that takes a selector function to minimize re-renders:\n\n```js\nimport { useFrameSize } from '@react-navigation/elements';\n\n// ...\n\nconst isLandscape = useFrameSize((size) => size.width > size.height);\n```\n\n#### The `onChangeText` callback has been renamed to `onChange` for `headerSearchBarOptions`\n\nThe `onChangeText` option in `headerSearchBarOptions` was confusingly named after text input's\n`onChangeText`, but TextInput's `onChangeText` receives the new text as the first argument, whereas `headerSearchBarOptions.onChangeText` received an event object - similar to TextInput's `onChange`.\n\nTo avoid confusion due to this inconsistency, the option has been renamed to `onChange`. To upgrade, simply rename the option:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```diff lang=js\ncreateNativeStackNavigator({\n  screens: {\n    Search: {\n      screen: SearchScreen,\n      options: {\n        headerSearchBarOptions: {\n-           onChangeText: (event) => {\n+           onChange: (event) => {\n            const text = event.nativeEvent.text;\n            // ...\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```diff lang=js\n<Stack.Navigator>\n  <Stack.Screen\n    name=\"Search\"\n    component={SearchScreen}\n    options={{\n      headerSearchBarOptions: {\n-         onChangeText: (event) => {\n+         onChange: (event) => {\n          const text = event.nativeEvent.text;\n          // ...\n        },\n      },\n    }}\n  />\n</Stack.Navigator>\n```\n\n</TabItem>\n</Tabs>\n\nThis applies to all navigators that support `headerSearchBarOptions`, such as Native Stack Navigator with native header, and other navigators using `Header` from `@react-navigation/elements`.\n\nIf you're using `Header` from `@react-navigation/elements` directly, the same change applies.\n\n#### APIs for customizing Navigation bar and status bar colors are removed from Native Stack Navigator\n\nPreviously, Native Stack Navigator provided options to customize the appearance of the navigation bar and status bar on Android:\n\n- `navigationBarColor`\n- `navigationBarTranslucent`\n- `statusBarBackgroundColor`\n- `statusBarTranslucent`\n\nIn Android 15 and onwards, edge-to-edge is now the default behavior, and will likely be enforced in future versions. Therefore, these options have been removed in React Navigation 8.\n\nYou can use [`react-native-edge-to-edge`](https://github.com/zoontek/react-native-edge-to-edge) instead to configure status bar and navigation bar related settings.\n\nSee [Native Stack Navigator](native-stack-navigator.md) for all available options.\n\n#### Stack Navigator now accepts a number for `gestureResponseDistance`\n\nPreviously, the `gestureResponseDistance` option in Stack Navigator accepted an object with `horizontal` and `vertical` properties to specify the distance for gestures. Since it's not pssible to have both horizontal and vertical gestures at the same time, it now accepts a number to specify the distance for the current gesture direction:\n\n```diff lang=js\n- gestureResponseDistance: { horizontal: 50 }\n+ gestureResponseDistance: 50\n```\n\n#### Drawer Navigator now accepts `overlayStyle` instead of `overlayColor`\n\nPreviously, the Drawer Navigator accepted an `overlayColor` prop to customize the color of the overlay that appears when the drawer is open. It now accepts `overlayStyle` prop instead to provide more flexibility for styling the overlay:\n\n```diff lang=js\n- overlayColor=\"rgba(0, 0, 0, 0.5)\"\n+ overlayStyle={{ backgroundColor: 'rgba(0, 0, 0, 0.5)' }}\n```\n\nSee [Drawer Navigator](drawer-navigator.md) for more details.\n\n### Miscellaneous\n\n#### Various deprecated APIs have been removed\n\nThe following API that were marked as deprecated in React Navigation 7 have been removed:\n\n- `navigateDeprecated` from the navigation object has been removed. Use `navigate` instead. To preserve the previous behavior, you can pass `pop: true` as the third argument to `navigate`:\n\n  ```diff lang=js\n  - navigation.navigateDeprecated('Profile', { userId: 123 });\n  + navigation.navigate('Profile', { userId: 123 }, { pop: true });\n  ```\n\n- `getId` from the navigation object has been removed since the [`id` prop has been removed](#navigators-no-longer-accept-an-id-prop).\n\n- `navigationInChildEnabled` prop from `NavigationContainer` has been removed. This behavior is no longer supported.\n\n#### The linking config no longer requires a `prefixes` option\n\nPreviously, the linking configuration required a `prefixes` option to specify the URL prefixes that the app should handle. This historical reason for this is to support Expo Go which uses a custom URL scheme.\n\nSince then, the recommended way to develop with Expo has been to use [Development Builds](https://docs.expo.dev/develop/development-builds/introduction/), which use the app's own URL scheme. So the `prefixes` option is not needed for most use cases.\n\nYou can now omit the `prefixes` option in the linking configuration unless you're using Expo Go:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```diff lang=js\n<Navigation\n  linking={{\n-     prefixes: ['myapp://', 'https://myapp.com'],\n    enabled: 'auto',\n  }}\n>\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```diff lang=js\n<NavigationContainer\n  linking={{\n-     prefixes: ['myapp://', 'https://myapp.com'],\n    config: { /* ... */ }\n  }}\n>\n```\n\n</TabItem>\n</Tabs>\n\nThe `prefixes` default to `['*']`, which will match any host starting with `http`, `https`, and custom schemes such as `myapp://`.\n\nSee [Configuring links](configuring-links.md) for more details.\n\n#### Deep links are now enabled by default in Static Configuration\n\nPreviously, deep linking needs to be explicitly enabled by setting `linking.enabled` to `auto` or by passing a `linking` prop. The additional step was necessary since we also needed `prefixes` to be specified in the linking config.\n\nIn React Navigation 8, it now defaults to `auto`, so deep linking is enabled by default with automatic path generation based on screen names when using static configuration:\n\nIf you don't want to enable deep linking, you can set `linking.enabled` to `false`:\n\n```diff lang=js\n<Navigation\n+   linking={{\n+     enabled: false,\n+   }}\n>\n```\n\n#### Some exports are removed from `@react-navigation/elements`\n\nThe `@react-navigation/elements` package has exported some components that were primarily intended for internal usage. These components have been removed from the public API:\n\n- `Background`\n\n  Background color can instead be applied by using it from `useTheme`.\n\n  ```diff lang=js\n  - import { Background } from '@react-navigation/elements';\n  + import { useTheme } from '@react-navigation/native';\n  // ...\n  - <Background>{children}</Background>\n  + const { colors } = useTheme();\n  +\n  + <View style={{ backgroundColor: colors.background }}>{children}</View>\n  ```\n\n- `Screen`\n\n  You can render the `Header` component directly instead.\n\n- `SafeAreaProviderCompat`\n\n  You can use `SafeAreaProvider` from [`react-native-safe-area-context`](https://github.com/AppAndFlow/react-native-safe-area-context) directly instead.\n\n- `MissingIcon`\n\n  You can copy the implementation from the [source code](https://github.com/react-navigation/react-navigation/blob/main/packages/elements/src/MissingIcon.tsx) if you need a placeholder icon.\n\nSome of these components are still available and exported at `@react-navigation/elements/internal`, so you can continue using them if you really need. However, since they are not part of the public API, they don't follow semver and may change without warning in future releases.\n\n#### The `getDefaultHeaderHeight` utility now accepts an object instead of positional arguments\n\nThe `getDefaultHeaderHeight` utility from `@react-navigation/elements` now accepts an object with named properties instead of positional arguments to improve readability\"\n\n```diff lang=js\n- getDefaultHeaderHeight(layout, false, statusBarHeight);\n+ getDefaultHeaderHeight({\n+   landscape: false,\n+   modalPresentation: false,\n+   topInset: statusBarHeight\n+ });\n```\n\nSee [Elements docs](elements.md#getdefaultheaderheight) for more details.\n\n## New features\n\n### Common hooks now accept name of the screen\n\nThe `useNavigation`, `useRoute`, and `useNavigationState` hooks can now optionally accept the name of the screen:\n\n```js\nconst route = useRoute('Profile');\n```\n\nThe name of the screen can be for the current screen or any of its parent screens. This makes it possible to get params and navigation state for a parent screen without needing to setup context to pass them down.\n\nIf the provided screen name does not exist in any of the parent screens, it will throw an error, so any mistakes are caught early.\n\nWhen using static configuration, the types are automatically inferred based on the name of the screen.\n\nIt's still possible to use these hooks without passing the screen name, same as before, and it will return the navigation or route for the current screen.\n\nSee [`useNavigation`](use-navigation.md), [`useRoute`](use-route.md), and [`useNavigationState`](use-navigation-state.md) for more details.\n\n### New entry can be added to history stack with `pushParams` action\n\nThe `pushParams` action updates the params and pushes a new entry to the history stack:\n\n```js\nnavigation.pushParams({ filter: 'new' });\n```\n\nUnlike `setParams`, this does not merge the new params with the existing ones. Instead, it uses the new params object as-is.\n\nThe action works in all navigators, such as stack, tab, and drawer. This allows to add a new entry to the history stack without needing to push a new screen instance.\n\nThis can be useful in various scenario:\n\n- A product listing page with filters, where changing filters should create a new history entry so that users can go back to previous filter states.\n- A screen with a custom modal component, where the modal is not a separate screen in the navigator, but its state should be reflected in the URL and history.\n\nSee [`pushParams` docs](navigation-actions.md#pushparams) for more details.\n\n### Themes now support `ColorValue` and CSS custom properties\n\nPreviously, theme colors only supported string values. In React Navigation 8, theme colors now support `PlatformColor`, `DynamicColorIOS` on native, and CSS custom properties on Web for more flexibility.\n\nExample theme using `PlatformColor`:\n\n```js\nconst MyTheme = {\n  ...DefaultTheme,\n  colors: Platform.select({\n    ios: () => ({\n      primary: PlatformColor('systemRed'),\n      background: PlatformColor('systemGroupedBackground'),\n      card: PlatformColor('tertiarySystemBackground'),\n      text: PlatformColor('label'),\n      border: PlatformColor('separator'),\n      notification: PlatformColor('systemRed'),\n    }),\n    android: () => ({\n      primary: PlatformColor('@android:color/system_primary_light'),\n      background: PlatformColor(\n        '@android:color/system_surface_container_light'\n      ),\n      card: PlatformColor('@android:color/system_background_light'),\n      text: PlatformColor('@android:color/system_on_surface_light'),\n      border: PlatformColor('@android:color/system_outline_variant_light'),\n      notification: PlatformColor('@android:color/holo_red_light'),\n    }),\n    default: () => DefaultTheme.colors,\n  })(),\n};\n```\n\nSee [Themes](themes.md#using-platform-colors) for more details.\n\n### Groups now support `linking` option in static configuration\n\nThe `linking` option can now be specified for groups in static configuration to define nested paths:\n\n```js\nconst Stack = createStackNavigator({\n  groups: {\n    Settings: {\n      linking: { path: 'settings' },\n      screens: {\n        UserSettings: 'user',\n        AppSettings: 'app',\n      },\n    },\n  },\n});\n```\n\nThis lets you prefix the paths of the screens in the group with a common prefix, e.g. `settings/` for `settings/user` and `settings/app`.\n\nSee [Group](group.md) for more details.\n\n### Deep linking to screens behind conditional screens is now supported\n\nPreviously, if a screen was conditionally rendered based on some state (e.g. authentication status), deep linking to that screen wouldn't work since the screen wouldn't exist in the navigator when the app was opened via a deep link.\n\nIn React Navigation 7, we added an experimental `UNSTABLE_routeNamesChangeBehavior` option to enable remembering such unhandled actions and re-attempting them when the list of route names changed after the conditions changed by setting the option to `lastUnhandled`.\n\nIn React Navigation 8, we have dropped the `UNSTABLE_` prefix and made it a stable API.\n\n```js static2dynamic\nconst Stack = createNativeStackNavigator({\n  // highlight-start\n  routeNamesChangeBehavior: 'lastUnhandled',\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\n### Navigators now accept a `router` prop\n\nA router defines how the navigator updates its state based on navigation actions. Previously, custom routers could only be used by [creating a custom navigator](custom-navigators.md#extending-navigators).\n\nWe later added an experimental `UNSTABLE_router` prop to various navigators to customize the router without needing to create a custom navigator. In React Navigation 8, we have dropped the `UNSTABLE_` prefix and made it a stable API.\n\n```js static2dynamic\nconst MyStack = createNativeStackNavigator({\n  // highlight-start\n  router: (original) => ({\n    getStateForAction(state, action) {\n      if (action.type === 'NAVIGATE') {\n        // Custom logic for NAVIGATE action\n      }\n\n      // Fallback to original behavior\n      return original.getStateForAction(state, action);\n    },\n  }),\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n```\n\nSee [`Navigator` docs](navigator.md#router) for more details.\n\n### State persistence is simplified with the `persistor` prop\n\nPreviously, state persistence could be implemented with `initialState` and `onStateChange` props, however it required some boilerplates and handling edge cases.\n\nThe new `persistor` prop simplifies state persistence by reducing the boilerplate code needed to persist and restore state:\n\n<Tabs groupId=\"config\" queryString=\"config\">\n<TabItem value=\"static\" label=\"Static\" default>\n\n```js\nexport default function App() {\n  return (\n    <Navigation\n      persistor={{\n        async persist(state) {\n          await AsyncStorage.setItem(\n            'NAVIGATION_STATE_V1',\n            JSON.stringify(state)\n          );\n        },\n        async restore() {\n          const state = await AsyncStorage.getItem('NAVIGATION_STATE_V1');\n\n          return state ? JSON.parse(state) : undefined;\n        },\n      }}\n    />\n  );\n}\n```\n\n</TabItem>\n<TabItem value=\"dynamic\" label=\"Dynamic\">\n\n```js\nexport default function App() {\n  return (\n    <NavigationContainer\n      persistor={{\n        async persist(state) {\n          await AsyncStorage.setItem(\n            'NAVIGATION_STATE_V1',\n            JSON.stringify(state)\n          );\n        },\n        async restore() {\n          const state = await AsyncStorage.getItem('NAVIGATION_STATE_V1');\n\n          return state ? JSON.parse(state) : undefined;\n        },\n      }}\n    >\n      {/* ... */}\n    </NavigationContainer>\n  );\n}\n```\n\n</TabItem>\n</Tabs>\n\nSee [State persistence docs](state-persistence.md) for more details.\n\n### `Header` from `@react-navigation/elements` has been reworked\n\nThe `Header` component from `@react-navigation/elements` has been reworked with various improvements:\n\n- It uses the new liquid glass effect on iOS 26\n- It supports `ColorValue` and CSS custom properties for colors\n- It supports `headerBlurEffect` on Web (previously only supported on iOS in Native Stack Navigator)\n- It no longer needs the layout of the screen to render correctly\n\nTo match the iOS 26 design, the back button title is no longer shown by default on iOS 26.\n\nSee [Elements](elements.md) for more details.\n\n### Bottom Tab Navigator now supports Material Symbols & SF Symbols icons\n\nThe Bottom Tab Navigator now supports using [Material Symbols](https://fonts.google.com/icons) on Android and [SF Symbols](https://developer.apple.com/sf-symbols/) on iOS for tab bar icons.\n\nYou can specify the icon as an object in `tabBarIcon` option:\n\n```js\ntabBarIcon: Platform.select({\n  ios: {\n    type: 'sfSymbol',\n    name: 'house',\n  },\n  android: {\n    type: 'materialSymbol',\n    name: 'home',\n  },\n}),\n```\n\nThis is supported both in `native` and `custom` implementations of Bottom Tab Navigator.\n\nSee [Bottom Tab Navigator docs](bottom-tab-navigator.md#tabbaricon) for more details.\n\n### `react-native-tab-view` now supports a `renderAdapter` prop for custom adapters\n\nBy default, `react-native-tab-view` uses [`react-native-pager-view`](https://github.com/callstack/react-native-pager-view) for rendering pages on Android and iOS. However, it may not be suitable for all use cases.\n\nSo it now supports a `renderAdapter` prop to provide a custom adapter for rendering pages. For example, you can use `ScrollViewAdapter` to use a `ScrollView` for rendering pages:\n\n```js\nimport React from 'react';\nimport { TabView, ScrollViewAdapter } from 'react-native-tab-view';\n\nexport default function TabViewExample() {\n  const [index, setIndex] = React.useState(0);\n\n  return (\n    <TabView\n      navigationState={{ index, routes }}\n      renderScene={renderScene}\n      onIndexChange={setIndex}\n      renderAdapter={ScrollViewAdapter}\n    />\n  );\n}\n```\n\nYou can also create your own custom adapter by implementing the required interface. See the [`react-native-tab-view` docs](tab-view.md) for more information.\n"},d=void 0,l={},h=[{value:"Dependency changes",id:"dependency-changes",level:2},{value:"Breaking changes",id:"breaking-changes",level:2},{value:"Dropping support for old architecture",id:"dropping-support-for-old-architecture",level:3},{value:"Changes to TypeScript setup",id:"changes-to-typescript-setup",level:3},{value:"The root type now uses navigator type instead of param list",id:"the-root-type-now-uses-navigator-type-instead-of-param-list",level:4},{value:"Common hooks no longer accept generics",id:"common-hooks-no-longer-accept-generics",level:4},{value:"New <code>createXScreen</code> API for creating screen config",id:"new-createxscreen-api-for-creating-screen-config",level:4},{value:"Custom navigators now require overloads for types",id:"custom-navigators-now-require-overloads-for-types",level:4},{value:"Changes to navigators",id:"changes-to-navigators",level:3},{value:"Native Bottom Tabs are now default",id:"native-bottom-tabs-are-now-default",level:4},{value:"Bottom Tabs no longer shows header by default",id:"bottom-tabs-no-longer-shows-header-by-default",level:4},{value:"Preloaded screens now behave differently",id:"preloaded-screens-now-behave-differently",level:4},{value:"Navigators no longer accept an <code>id</code> prop",id:"navigators-no-longer-accept-an-id-prop",level:4},{value:"<code>setParams</code> no longer pushes to history in tab and drawer navigators when <code>backBehavior</code> is set to <code>fullHistory</code>",id:"setparams-no-longer-pushes-to-history-in-tab-and-drawer-navigators-when-backbehavior-is-set-to-fullhistory",level:4},{value:"Navigators no longer use <code>InteractionManager</code>",id:"navigators-no-longer-use-interactionmanager",level:4},{value:"The color arguments in various navigators now accept <code>ColorValue</code>",id:"the-color-arguments-in-various-navigators-now-accept-colorvalue",level:4},{value:"Various components no longer receive layout related props",id:"various-components-no-longer-receive-layout-related-props",level:4},{value:"The <code>onChangeText</code> callback has been renamed to <code>onChange</code> for <code>headerSearchBarOptions</code>",id:"the-onchangetext-callback-has-been-renamed-to-onchange-for-headersearchbaroptions",level:4},{value:"APIs for customizing Navigation bar and status bar colors are removed from Native Stack Navigator",id:"apis-for-customizing-navigation-bar-and-status-bar-colors-are-removed-from-native-stack-navigator",level:4},{value:"Stack Navigator now accepts a number for <code>gestureResponseDistance</code>",id:"stack-navigator-now-accepts-a-number-for-gestureresponsedistance",level:4},{value:"Drawer Navigator now accepts <code>overlayStyle</code> instead of <code>overlayColor</code>",id:"drawer-navigator-now-accepts-overlaystyle-instead-of-overlaycolor",level:4},{value:"Miscellaneous",id:"miscellaneous",level:3},{value:"Various deprecated APIs have been removed",id:"various-deprecated-apis-have-been-removed",level:4},{value:"The linking config no longer requires a <code>prefixes</code> option",id:"the-linking-config-no-longer-requires-a-prefixes-option",level:4},{value:"Deep links are now enabled by default in Static Configuration",id:"deep-links-are-now-enabled-by-default-in-static-configuration",level:4},{value:"Some exports are removed from <code>@react-navigation/elements</code>",id:"some-exports-are-removed-from-react-navigationelements",level:4},{value:"The <code>getDefaultHeaderHeight</code> utility now accepts an object instead of positional arguments",id:"the-getdefaultheaderheight-utility-now-accepts-an-object-instead-of-positional-arguments",level:4},{value:"New features",id:"new-features",level:2},{value:"Common hooks now accept name of the screen",id:"common-hooks-now-accept-name-of-the-screen",level:3},{value:"New entry can be added to history stack with <code>pushParams</code> action",id:"new-entry-can-be-added-to-history-stack-with-pushparams-action",level:3},{value:"Themes now support <code>ColorValue</code> and CSS custom properties",id:"themes-now-support-colorvalue-and-css-custom-properties",level:3},{value:"Groups now support <code>linking</code> option in static configuration",id:"groups-now-support-linking-option-in-static-configuration",level:3},{value:"Deep linking to screens behind conditional screens is now supported",id:"deep-linking-to-screens-behind-conditional-screens-is-now-supported",level:3},{value:"Navigators now accept a <code>router</code> prop",id:"navigators-now-accept-a-router-prop",level:3},{value:"State persistence is simplified with the <code>persistor</code> prop",id:"state-persistence-is-simplified-with-the-persistor-prop",level:3},{value:"<code>Header</code> from <code>@react-navigation/elements</code> has been reworked",id:"header-from-react-navigationelements-has-been-reworked",level:3},{value:"Bottom Tab Navigator now supports Material Symbols &amp; SF Symbols icons",id:"bottom-tab-navigator-now-supports-material-symbols--sf-symbols-icons",level:3},{value:"<code>react-native-tab-view</code> now supports a <code>renderAdapter</code> prop for custom adapters",id:"react-native-tab-view-now-supports-a-renderadapter-prop-for-custom-adapters",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["React Navigation 8 is still in pre-release stage. The API may still change before the stable release. Please provide any feedback or suggestions on ",(0,o.jsx)(n.a,{href:"https://github.com/react-navigation/react-navigation/discussions",children:"GitHub Discussions"}),"."]})}),"\n",(0,o.jsx)(n.p,{children:"This guides lists all the breaking changes and new features in React Navigation 8 that you need to be aware of when upgrading from React Navigation 7."}),"\n",(0,o.jsx)(n.h2,{id:"dependency-changes",children:"Dependency changes"}),"\n",(0,o.jsx)(n.p,{children:"The minimum required version of React Native, Expo, and TypeScript have been bumped:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"react-native"})," >= 0.81 (planned to be bumped to 0.83)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"expo"})," >= 54 (planned to be bumped to 55)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"typescript"})," >= 5.9.2 (if you use TypeScript)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The minimum required version of various peer dependencies have also been bumped:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"react-native-screens"})," >= 4.20.0"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"react-native-safe-area-context"})," >= 5.5.0"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"react-native-reanimated"})," >= 4.0.0"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"react-native-pager-view"})," >= 7.0.0 (8.0.0 is recommended)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"react-native-web"})," >= 0.21.0"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, many navigators worked without ",(0,o.jsx)(n.code,{children:"react-native-screens"}),", but now it's required for all navigators."]}),"\n",(0,o.jsxs)(n.p,{children:["Additionally, React Navigation now uses ",(0,o.jsx)(n.a,{href:"https://github.com/callstack/liquid-glass",children:(0,o.jsx)(n.code,{children:"@callstack/liquid-glass"})})," to implement liquid glass effect on iOS 26."]}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://expo.dev/go",children:"Expo Go"})," doesn't support React Navigation 8. So you need to create a ",(0,o.jsx)(n.a,{href:"https://docs.expo.dev/development/introduction/",children:"development build"})," of your app to use React Navigation 8 with Expo."]})}),"\n",(0,o.jsx)(n.h2,{id:"breaking-changes",children:"Breaking changes"}),"\n",(0,o.jsx)(n.h3,{id:"dropping-support-for-old-architecture",children:"Dropping support for old architecture"}),"\n",(0,o.jsx)(n.p,{children:"React Navigation 8 no longer supports the old architecture of React Native. The old architecture has been frozen since React Native 0.80 and removed in React Native 0.82."}),"\n",(0,o.jsx)(n.p,{children:"So if you're still on the old architecture, you'll need to upgrade to the new architecture in order to use React Navigation 8."}),"\n",(0,o.jsx)(n.h3,{id:"changes-to-typescript-setup",children:"Changes to TypeScript setup"}),"\n",(0,o.jsx)(n.p,{children:"We introduced a static API in React Navigation 7. However, some of the TypeScript types were not inferred and required manual annotations. In React Navigation 8, we reworked the TypeScript types to solve many of these issues."}),"\n",(0,o.jsx)(n.h4,{id:"the-root-type-now-uses-navigator-type-instead-of-param-list",children:"The root type now uses navigator type instead of param list"}),"\n",(0,o.jsxs)(n.p,{children:["Previously the types for the root navigator were specified using ",(0,o.jsx)(n.code,{children:"declare global"})," and ",(0,o.jsx)(n.code,{children:"RootParamList"}),". Now, they can be specified with module augmentation of ",(0,o.jsx)(n.code,{children:"@react-navigation/core"})," and use the navigator's type instead a param list:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"ts",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=ts",children:"- type RootStackParamList = StaticParamList<typeof RootStack>;\n-\n- declare global {\n-   namespace ReactNavigation {\n-     interface RootParamList extends RootStackParamList {}\n-   }\n- }\n+ type RootStackType = typeof RootStack;\n+\n+ declare module '@react-navigation/core' {\n+   interface RootNavigator extends RootStackType {}\n+ }\n"})}),"\n",(0,o.jsx)(n.p,{children:"Using module augmentation is shorter, and avoids namespace usage - which ESLint may complain about in some configurations."}),"\n",(0,o.jsx)(n.p,{children:"Using the navigator's type instead of a param list allows us to infer the type of navigators - primarily in case of static configuration."}),"\n",(0,o.jsx)(n.h4,{id:"common-hooks-no-longer-accept-generics",children:"Common hooks no longer accept generics"}),"\n",(0,o.jsxs)(n.p,{children:["Previously hooks such as ",(0,o.jsx)(n.code,{children:"useNavigation"}),", ",(0,o.jsx)(n.code,{children:"useRoute"})," and ",(0,o.jsx)(n.code,{children:"useNavigationState"})," accepted a generic to override the default types. This is not type-safe as we cannot verify that the provided type matches the actual navigators, and we recommended minimizing such usage."]}),"\n",(0,o.jsxs)(n.p,{children:["In React Navigation 8, we reworked the types to automatically determine the correct type ",(0,o.jsx)(n.a,{href:"#common-hooks-now-accept-name-of-the-screen",children:"based on the name of the screen"})," when using static config:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"ts",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=ts",children:"- const navigation = useNavigation<StackNavigationProp<RootStackParamList, 'Profile'>>();\n+ const navigation = useNavigation('Profile');\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you're using dynamic configuration, unfortunately we cannot currently infer the types automatically. So it still requires manual annotation. However, now you need to use ",(0,o.jsx)(n.code,{children:"as"})," instead of generics to make it clearer that this is unsafe:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"ts",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=ts",children:"- const navigation = useNavigation<StackNavigationProp<RootStackParamList, 'Profile'>>();\n+ const navigation = useNavigation() as StackNavigationProp<RootStackParamList, 'Profile'>;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useRoute"})," type has been updated in the same way:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"ts",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=ts",children:"- const route = useRoute<RouteProp<RootStackParamList, 'Profile'>>();\n+ const route = useRoute('Profile');\n"})}),"\n",(0,o.jsx)(n.p,{children:"And if you're using dynamic configuration:"}),"\n",(0,o.jsx)(n.pre,{"data-lang":"ts",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=ts",children:"- const route = useRoute<RouteProp<RootStackParamList, 'Profile'>>();\n+ const route = useRoute() as RouteProp<RootStackParamList, 'Profile'>;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Similarly, the ",(0,o.jsx)(n.code,{children:"useNavigationState"})," type has been updated to accept the name of the screen in addition to the selector:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"ts",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=ts",children:"- const focusedRouteName = useNavigationState<RootStackParamList>((state) => state.routes[state.index].name);\n+ const focusedRouteName = useNavigationState('Settings', (state) => state.routes[state.index].name);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you're using dynamic configuration, you can use ",(0,o.jsx)(n.code,{children:"as"}),":"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"ts",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=ts",children:"- const focusedRouteName = useNavigationState<RootStackParamList>((state) => state.routes[state.index].name);\n+ const focusedRouteName = useNavigationState((state) => state.routes[state.index].name as keyof RootStackParamList);\n"})}),"\n",(0,o.jsxs)(n.h4,{id:"new-createxscreen-api-for-creating-screen-config",children:["New ",(0,o.jsx)(n.code,{children:"createXScreen"})," API for creating screen config"]}),"\n",(0,o.jsxs)(n.p,{children:["One of the limitations of the static config API is that the type of ",(0,o.jsx)(n.code,{children:"route"})," object can't be inferred in screen callback, listeners callback etc. This made it difficult to use route params in these callbacks."]}),"\n",(0,o.jsxs)(n.p,{children:["To address this, we added a new ",(0,o.jsx)(n.code,{children:"createXScreen"})," API for each navigator to create screen config with proper types:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"const Stack = createStackNavigator({\n  screens: {\n-     Profile: {\n-       screen: ProfileScreen,\n-       options: ({ route }) => {\n-         const userId = route.params.userId; // Don't know the type of route params\n-\n-         return { title: `User ${userId}` };\n-       },\n-     },\n+     Profile: createStackScreen({\n+       screen: ProfileScreen,\n+       options: ({ route }) => {\n+         const userId = route.params.userId; // Now correctly inferred\n+\n+         return { title: `User ${userId}` };\n+       },\n+     });\n  }\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When using the ",(0,o.jsx)(n.code,{children:"createXScreen"})," API, the type of params are automatically inferred based on the type annotation for the component specified in ",(0,o.jsx)(n.code,{children:"screen"})," (e.g. ",(0,o.jsx)(n.code,{children:"(props: StaticScreenProps<ProfileParams>)"}),") and the path pattern specified in the linking config (e.g. ",(0,o.jsx)(n.code,{children:"linking: 'profile/:userId'"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:["Each navigator exports its own helper function, e.g. ",(0,o.jsx)(n.code,{children:"createNativeStackScreen"})," for Native Stack Navigator, ",(0,o.jsx)(n.code,{children:"createBottomTabScreen"})," for Bottom Tab Navigator, ",(0,o.jsx)(n.code,{children:"createDrawerScreen"})," for Drawer Navigator etc."]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["This is technically not a breaking change. It's not required to use this API and your existing code will continue to work as before. You can incrementally adopt this API for new screens to get proper types for ",(0,o.jsx)(n.code,{children:"route"})," object in various callbacks such as ",(0,o.jsx)(n.code,{children:"options"}),", ",(0,o.jsx)(n.code,{children:"listeners"}),", etc."]})}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/static-configuration#createxscreen",children:"Static configuration docs"})," for more details."]}),"\n",(0,o.jsx)(n.h4,{id:"custom-navigators-now-require-overloads-for-types",children:"Custom navigators now require overloads for types"}),"\n",(0,o.jsx)(n.p,{children:"To work with the reworked TypeScript types, custom navigators now need to provide overloads for static and dynamic configuration APIs, and an additional API to create screen config."}),"\n",(0,o.jsx)(n.pre,{"data-lang":"ts",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=ts",children:"- export function createMyNavigator<\n-   const ParamList extends ParamListBase,\n-   const NavigatorID extends string | undefined = string | undefined,\n-   const TypeBag extends NavigatorTypeBagBase = {\n-     ParamList: ParamList;\n-     NavigatorID: NavigatorID;\n-     State: TabNavigationState<ParamList>;\n-     ScreenOptions: MyNavigationOptions;\n-     EventMap: MyNavigationEventMap;\n-     NavigationList: {\n-       [RouteName in keyof ParamList]: MyNavigationProp<\n-         ParamList,\n-         RouteName,\n-         NavigatorID\n-       >;\n-     };\n-     Navigator: typeof MyNavigator;\n-   },\n-   const Config extends StaticConfig<TypeBag> = StaticConfig<TypeBag>,\n- >(config?: Config): TypedNavigator<TypeBag, Config> {\n-   return createNavigatorFactory(MyNavigator)(config);\n- }\n+ type MyTypeBag<ParamList extends {}> = {\n+   ParamList: ParamList;\n+   State: TabNavigationState<ParamList>;\n+   ScreenOptions: MyNavigationOptions;\n+   EventMap: MyNavigationEventMap;\n+   NavigationList: {\n+     [RouteName in keyof ParamList]: MyNavigationProp<\n+       ParamList,\n+       RouteName\n+     >;\n+   };\n+   Navigator: typeof MyNavigator;\n+ };\n+\n+ export function createMyNavigator<\n+   const ParamList extends ParamListBase,\n+ >(): TypedNavigator<MyTypeBag<ParamList>, undefined>;\n+ export function createMyNavigator<\n+   const Config extends StaticConfig<MyTypeBag<ParamListBase>>,\n+ >(\n+   config: Config\n+ ): TypedNavigator<\n+   MyTypeBag<StaticParamList<{ config: Config }>>,\n+   Config\n+ >;\n+ export function createMyNavigator(config?: unknown) {\n+   return createNavigatorFactory(MyNavigator)(config);\n+ }\n\n+ export function createMyScreen<\n+  const Linking extends StaticScreenConfigLinking,\n+  const Screen extends StaticScreenConfigScreen,\n+ >(\n+   config: StaticScreenConfig<\n+     Linking,\n+     Screen,\n+     TabNavigationState<ParamListBase>,\n+     MyNavigationOptions,\n+     MyNavigationEventMap,\n+     MyNavigationProp<ParamListBase>\n+   >\n+ ) {\n+   return config;\n+ }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/custom-navigators",children:"Custom navigators"})," for more details."]}),"\n",(0,o.jsx)(n.h3,{id:"changes-to-navigators",children:"Changes to navigators"}),"\n",(0,o.jsx)(n.h4,{id:"native-bottom-tabs-are-now-default",children:"Native Bottom Tabs are now default"}),"\n",(0,o.jsxs)(n.p,{children:["Previously, the Bottom Tab Navigator used a JavaScript-based implementation and a native implementation was available under ",(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs/unstable"}),". The ",(0,o.jsx)(n.code,{children:"@react-navigation/bottom-tabs/unstable"})," entry point has been removed and it has been merged into the main package."]}),"\n",(0,o.jsx)(n.p,{children:"Native bottom tabs are now used by default on iOS and Android. This allows us to match the new native design such as liquid glass effect on iOS 26."}),"\n",(0,o.jsxs)(n.p,{children:["To keep the previous behavior with JavaScript-based tabs, you can pass ",(0,o.jsx)(n.code,{children:"implementation: 'custom'"})," to the navigator:"]}),"\n",(0,o.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,o.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"createBottomTabNavigator({\n+   implementation: 'custom',\n  // ...\n});\n"})})}),(0,o.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:'<Tab.Navigator\n+   implementation="custom"\n  // ...\n>\n'})})})]}),"\n",(0,o.jsx)(n.p,{children:"As part of this change, some of the options have changed to work with native tabs:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tabBarShowLabel"})," is replaced with ",(0,o.jsx)(n.code,{children:"tabBarLabelVisibilityMode"})," which accepts:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'"auto"'})," (default)"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:'"selected"'})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'"labeled"'})," - same as ",(0,o.jsx)(n.code,{children:"tabBarShowLabel: true"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'"unlabeled"'})," - same as ",(0,o.jsx)(n.code,{children:"tabBarShowLabel: false"})]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tabBarLabel"})," now only accepts a ",(0,o.jsx)(n.code,{children:"string"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tabBarIcon"})," now accepts an icon object or function that can return an icon object, returning a react element still works with ",(0,o.jsx)(n.code,{children:"custom"})," implementation - so you don't need to change anything if you're using ",(0,o.jsx)(n.code,{children:"custom"})," implementation."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The following props have been removed:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"safeAreaInsets"})," from the navigator props"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"insets"})," from the bottom tab bar props"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"layout"})," from the bottom tab bar props"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["If you use ",(0,o.jsx)(n.code,{children:"insets"})," and ",(0,o.jsx)(n.code,{children:"layout"})," in your custom tab bar, you can use ",(0,o.jsx)(n.a,{href:"https://appandflow.github.io/react-native-safe-area-context/api/use-safe-area-insets/",children:(0,o.jsx)(n.code,{children:"useSafeAreaInsets"})})," and ",(0,o.jsx)(n.a,{href:"https://appandflow.github.io/react-native-safe-area-context/api/use-safe-area-frame/",children:(0,o.jsx)(n.code,{children:"useSafeAreaFrame"})})," from ",(0,o.jsx)(n.a,{href:"https://github.com/th3rdwave/react-native-safe-area-context",children:(0,o.jsx)(n.code,{children:"react-native-safe-area-context"})})," instead to get the same values."]}),"\n",(0,o.jsxs)(n.p,{children:["See the ",(0,o.jsx)(n.a,{href:"/docs/8.x/bottom-tab-navigator",children:"Bottom Tab Navigator docs"})," for all the available options."]}),"\n",(0,o.jsx)(n.h4,{id:"bottom-tabs-no-longer-shows-header-by-default",children:"Bottom Tabs no longer shows header by default"}),"\n",(0,o.jsxs)(n.p,{children:["Since Bottom Tabs now renders native tabs by default, the header is no longer shown by default to match native look and feel. You can nest a ",(0,o.jsx)(n.a,{href:"/docs/8.x/native-stack-navigator",children:"Native Stack Navigator"})," inside each tab to show a header that integrates well with native tabs, e.g. ",(0,o.jsx)(n.a,{href:"/docs/8.x/bottom-tab-navigator#search-tab-on-ios-26",children:"search tab on iOS 26+"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Alternatively, you can enable the built-in header by passing ",(0,o.jsx)(n.code,{children:"headerShown: true"})," in ",(0,o.jsx)(n.code,{children:"screenOptions"})," of the navigator:"]}),"\n",(0,o.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,o.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"createBottomTabNavigator({\n  screenOptions: {\n+     headerShown: true,\n    // ...\n  },\n  // ...\n});\n"})})}),(0,o.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"<Tab.Navigator\n  screenOptions={{\n+     headerShown: true,\n    // ...\n  }}\n>\n"})})})]}),"\n",(0,o.jsx)(n.h4,{id:"preloaded-screens-now-behave-differently",children:"Preloaded screens now behave differently"}),"\n",(0,o.jsx)(n.p,{children:"Previously, when a screen was preloaded in Stack and Native Stack Navigators, there were a few restrictions:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Options could not be updated with ",(0,o.jsx)(n.a,{href:"/docs/8.x/navigation-object#setoptions",children:(0,o.jsx)(n.code,{children:"setOptions"})})," until the screen became active."]}),"\n",(0,o.jsxs)(n.li,{children:["Adding listeners with ",(0,o.jsx)(n.a,{href:"/docs/8.x/navigation-object#navigation-events",children:(0,o.jsx)(n.code,{children:"addListener"})})," did nothing until the screen became active."]}),"\n",(0,o.jsx)(n.li,{children:"Preloaded screens could not contain nested navigators."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In addition, the ",(0,o.jsx)(n.code,{children:"navigation"})," object received by preloaded screens was different from that of active screens. So it resulted in re-rendering the screen when it became active."]}),"\n",(0,o.jsx)(n.p,{children:"We have reworked the implementation of preloaded screens to make it more consistent with active screens:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Options can now be updated with ",(0,o.jsx)(n.code,{children:"setOptions"})," even when the screen is preloaded."]}),"\n",(0,o.jsxs)(n.li,{children:["Listeners added with ",(0,o.jsx)(n.code,{children:"addListener"})," will now be called even when the screen is preloaded."]}),"\n",(0,o.jsx)(n.li,{children:"Preloaded screens can now contain nested navigators."}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"navigation"})," object now does not change when the screen becomes active."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"While this is a breaking change, your existing code will likely continue to work as before if you were not relying on any of the special behaviors of preloaded screens for your logic."}),"\n",(0,o.jsxs)(n.p,{children:["If your existing code checked ",(0,o.jsx)(n.code,{children:"navigation.isFocused()"})," before calling ",(0,o.jsx)(n.code,{children:"setOptions"}),", it will continue to work as before. However, you can now simplify such code by removing the check:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- if (navigation.isFocused()) {\n    navigation.setOptions({ title: 'New Title' });\n- }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/navigation-object#preload",children:(0,o.jsx)(n.code,{children:"navigation.preload"})})," for usage details."]}),"\n",(0,o.jsxs)(n.h4,{id:"navigators-no-longer-accept-an-id-prop",children:["Navigators no longer accept an ",(0,o.jsx)(n.code,{children:"id"})," prop"]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, navigators accepted an ",(0,o.jsx)(n.code,{children:"id"})," prop to identify them - which was used with ",(0,o.jsx)(n.code,{children:"navigation.getParent(id)"})," to get a parent navigator by id. However, there were a couple of issues with this approach:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"It wasn't well integrated with TypeScript types, and required manual annotations."}),"\n",(0,o.jsx)(n.li,{children:"The navigation object is specific to a screen, so using the navigator's id was inconsistent."}),"\n",(0,o.jsx)(n.li,{children:"It was used for a very specific use case, so it added unnecessary complexity."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In React Navigation 8, we removed the ",(0,o.jsx)(n.code,{children:"id"})," prop from navigators. Instead, you can use the screen's name to get a parent navigator:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- const parent = navigation.getParent('some-id');\n+ const parent = navigation.getParent('SomeScreenName');\n"})}),"\n",(0,o.jsx)(n.p,{children:"In this case, 'SomeScreenName' refers to the name of a parent screen that's used in the navigator."}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/navigation-object#getparent",children:"navigation object docs"})," for more details."]}),"\n",(0,o.jsxs)(n.h4,{id:"setparams-no-longer-pushes-to-history-in-tab-and-drawer-navigators-when-backbehavior-is-set-to-fullhistory",children:[(0,o.jsx)(n.code,{children:"setParams"})," no longer pushes to history in tab and drawer navigators when ",(0,o.jsx)(n.code,{children:"backBehavior"})," is set to ",(0,o.jsx)(n.code,{children:"fullHistory"})]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, when using ",(0,o.jsx)(n.code,{children:"setParams"})," in tab and drawer navigators with ",(0,o.jsx)(n.code,{children:"backBehavior"})," set to ",(0,o.jsx)(n.code,{children:"fullHistory"}),", it would push a new entry to the history stack."]}),"\n",(0,o.jsxs)(n.p,{children:["In React Navigation 8, we ",(0,o.jsxs)(n.a,{href:"#new-entry-can-be-added-to-history-stack-with-pushparams-action",children:["added a new ",(0,o.jsx)(n.code,{children:"pushParams"})," action"]})," that achieves this behavior. So ",(0,o.jsx)(n.code,{children:"setParams"})," now only updates the params without affecting the history stack."]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- navigation.setParams({ filter: 'new' });\n+ navigation.pushParams({ filter: 'new' });\n"})}),"\n",(0,o.jsx)(n.p,{children:"This way you have more control over how params are updated in tab and drawer navigators."}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsxs)(n.a,{href:"/docs/8.x/navigation-actions#setparams",children:[(0,o.jsx)(n.code,{children:"setParams"})," action docs"]})," for more details."]}),"\n",(0,o.jsxs)(n.h4,{id:"navigators-no-longer-use-interactionmanager",children:["Navigators no longer use ",(0,o.jsx)(n.code,{children:"InteractionManager"})]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, various navigators used ",(0,o.jsx)(n.code,{children:"InteractionManager"})," to mark when animations and gestures were in progress. This was primarily used to defer code that should run after transitions, such as loading data or rendering heavy components."]}),"\n",(0,o.jsxs)(n.p,{children:["However, ",(0,o.jsx)(n.code,{children:"InteractionManager"})," has been deprecated in latest React Native versions, so we are removing support for this API in React Navigation 8. As an alternative, consumers can listen to events such as ",(0,o.jsx)(n.code,{children:"transitionStart"}),", ",(0,o.jsx)(n.code,{children:"transitionEnd"})," etc. when applicable:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- InteractionManager.runAfterInteractions(() => {\n-   // code to run after transition\n- });\n+ navigation.addListener('transitionEnd', () => {\n+   // code to run after transition\n+ });\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Keep in mind that unlike ",(0,o.jsx)(n.code,{children:"InteractionManager"})," which is global, the transition events are specific to a navigator."]}),"\n",(0,o.jsxs)(n.p,{children:["If you have a use case that cannot be solved with transition events, please open a ",(0,o.jsx)(n.a,{href:"https://github.com/react-navigation/react-navigation/discussions",children:"discussion on GitHub"}),"."]}),"\n",(0,o.jsxs)(n.h4,{id:"the-color-arguments-in-various-navigators-now-accept-colorvalue",children:["The color arguments in various navigators now accept ",(0,o.jsx)(n.code,{children:"ColorValue"})]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, color options in various navigators only accepted string values. In React Navigation 8, these options now accept ",(0,o.jsx)(n.code,{children:"ColorValue"})," to match the ",(0,o.jsx)(n.a,{href:"#themes-now-support-colorvalue-and-css-custom-properties",children:"changes to theming"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Unless you are using a custom theme with ",(0,o.jsx)(n.code,{children:"PlatformColor"})," or ",(0,o.jsx)(n.code,{children:"DynamicColorIOS"})," etc, this change only breaks TypeScript types:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- const tabBarIcon = ({ color, size }: { color: string, size: number }) => {\n+ const tabBarIcon = ({ color, size }: { color: ColorValue, size: number }) => {\n  // ...\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/themes#using-platform-colors",children:"Themes"})," for more information about dynamic colors."]}),"\n",(0,o.jsx)(n.h4,{id:"various-components-no-longer-receive-layout-related-props",children:"Various components no longer receive layout related props"}),"\n",(0,o.jsxs)(n.p,{children:["Previously, various components such as ",(0,o.jsx)(n.code,{children:"Header"}),", ",(0,o.jsx)(n.code,{children:"BottomTabBar"}),", and ",(0,o.jsx)(n.code,{children:"DrawerContent"})," received layout related props such as ",(0,o.jsx)(n.code,{children:"layout"})," - that contained the dimensions of the screen."]}),"\n",(0,o.jsxs)(n.p,{children:["This meant that if the ",(0,o.jsx)(n.code,{children:"layout"})," changed frequently, such as resizing the window on supported platforms (Web, Windows, macOS, iPadOS), it would need to re-render these components frequently - often not being able to keep up with the changes, leading to jank and poor performance."]}),"\n",(0,o.jsx)(n.p,{children:"To avoid this, we have removed layout related props from these components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"layout"})," prop from ",(0,o.jsx)(n.code,{children:"Header"})," component from ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"titleLayout"})," and ",(0,o.jsx)(n.code,{children:"screenLayout"})," props from ",(0,o.jsx)(n.code,{children:"HeaderBackButton"})," component from ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"layouts.title"})," and ",(0,o.jsx)(n.code,{children:"layouts.leftLabel"})," parameters from ",(0,o.jsx)(n.code,{children:"headerStyleInterpolator"})," in ",(0,o.jsx)(n.code,{children:"@react-navigation/stack"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"layout"})," prop from ",(0,o.jsx)(n.code,{children:"react-native-tab-view"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"layout"})," prop from ",(0,o.jsx)(n.code,{children:"react-native-drawer-layout"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Since React Native doesn't provide APIs to handle layout changes in styles, it may still be necessary to handle layout changes manually in some cases. So we have added a ",(0,o.jsx)(n.a,{href:"/docs/8.x/elements#useframesize",children:(0,o.jsx)(n.code,{children:"useFrameSize"})})," hook that takes a selector function to minimize re-renders:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { useFrameSize } from '@react-navigation/elements';\n\n// ...\n\nconst isLandscape = useFrameSize((size) => size.width > size.height);\n"})}),"\n",(0,o.jsxs)(n.h4,{id:"the-onchangetext-callback-has-been-renamed-to-onchange-for-headersearchbaroptions",children:["The ",(0,o.jsx)(n.code,{children:"onChangeText"})," callback has been renamed to ",(0,o.jsx)(n.code,{children:"onChange"})," for ",(0,o.jsx)(n.code,{children:"headerSearchBarOptions"})]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"onChangeText"})," option in ",(0,o.jsx)(n.code,{children:"headerSearchBarOptions"})," was confusingly named after text input's\n",(0,o.jsx)(n.code,{children:"onChangeText"}),", but TextInput's ",(0,o.jsx)(n.code,{children:"onChangeText"})," receives the new text as the first argument, whereas ",(0,o.jsx)(n.code,{children:"headerSearchBarOptions.onChangeText"})," received an event object - similar to TextInput's ",(0,o.jsx)(n.code,{children:"onChange"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["To avoid confusion due to this inconsistency, the option has been renamed to ",(0,o.jsx)(n.code,{children:"onChange"}),". To upgrade, simply rename the option:"]}),"\n",(0,o.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,o.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"createNativeStackNavigator({\n  screens: {\n    Search: {\n      screen: SearchScreen,\n      options: {\n        headerSearchBarOptions: {\n-           onChangeText: (event) => {\n+           onChange: (event) => {\n            const text = event.nativeEvent.text;\n            // ...\n          },\n        },\n      },\n    },\n  },\n});\n"})})}),(0,o.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:'<Stack.Navigator>\n  <Stack.Screen\n    name="Search"\n    component={SearchScreen}\n    options={{\n      headerSearchBarOptions: {\n-         onChangeText: (event) => {\n+         onChange: (event) => {\n          const text = event.nativeEvent.text;\n          // ...\n        },\n      },\n    }}\n  />\n</Stack.Navigator>\n'})})})]}),"\n",(0,o.jsxs)(n.p,{children:["This applies to all navigators that support ",(0,o.jsx)(n.code,{children:"headerSearchBarOptions"}),", such as Native Stack Navigator with native header, and other navigators using ",(0,o.jsx)(n.code,{children:"Header"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If you're using ",(0,o.jsx)(n.code,{children:"Header"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"})," directly, the same change applies."]}),"\n",(0,o.jsx)(n.h4,{id:"apis-for-customizing-navigation-bar-and-status-bar-colors-are-removed-from-native-stack-navigator",children:"APIs for customizing Navigation bar and status bar colors are removed from Native Stack Navigator"}),"\n",(0,o.jsx)(n.p,{children:"Previously, Native Stack Navigator provided options to customize the appearance of the navigation bar and status bar on Android:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"navigationBarColor"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"navigationBarTranslucent"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"statusBarBackgroundColor"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"statusBarTranslucent"})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In Android 15 and onwards, edge-to-edge is now the default behavior, and will likely be enforced in future versions. Therefore, these options have been removed in React Navigation 8."}),"\n",(0,o.jsxs)(n.p,{children:["You can use ",(0,o.jsx)(n.a,{href:"https://github.com/zoontek/react-native-edge-to-edge",children:(0,o.jsx)(n.code,{children:"react-native-edge-to-edge"})})," instead to configure status bar and navigation bar related settings."]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/native-stack-navigator",children:"Native Stack Navigator"})," for all available options."]}),"\n",(0,o.jsxs)(n.h4,{id:"stack-navigator-now-accepts-a-number-for-gestureresponsedistance",children:["Stack Navigator now accepts a number for ",(0,o.jsx)(n.code,{children:"gestureResponseDistance"})]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, the ",(0,o.jsx)(n.code,{children:"gestureResponseDistance"})," option in Stack Navigator accepted an object with ",(0,o.jsx)(n.code,{children:"horizontal"})," and ",(0,o.jsx)(n.code,{children:"vertical"})," properties to specify the distance for gestures. Since it's not pssible to have both horizontal and vertical gestures at the same time, it now accepts a number to specify the distance for the current gesture direction:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- gestureResponseDistance: { horizontal: 50 }\n+ gestureResponseDistance: 50\n"})}),"\n",(0,o.jsxs)(n.h4,{id:"drawer-navigator-now-accepts-overlaystyle-instead-of-overlaycolor",children:["Drawer Navigator now accepts ",(0,o.jsx)(n.code,{children:"overlayStyle"})," instead of ",(0,o.jsx)(n.code,{children:"overlayColor"})]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, the Drawer Navigator accepted an ",(0,o.jsx)(n.code,{children:"overlayColor"})," prop to customize the color of the overlay that appears when the drawer is open. It now accepts ",(0,o.jsx)(n.code,{children:"overlayStyle"})," prop instead to provide more flexibility for styling the overlay:"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- overlayColor=\"rgba(0, 0, 0, 0.5)\"\n+ overlayStyle={{ backgroundColor: 'rgba(0, 0, 0, 0.5)' }}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/drawer-navigator",children:"Drawer Navigator"})," for more details."]}),"\n",(0,o.jsx)(n.h3,{id:"miscellaneous",children:"Miscellaneous"}),"\n",(0,o.jsx)(n.h4,{id:"various-deprecated-apis-have-been-removed",children:"Various deprecated APIs have been removed"}),"\n",(0,o.jsx)(n.p,{children:"The following API that were marked as deprecated in React Navigation 7 have been removed:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"navigateDeprecated"})," from the navigation object has been removed. Use ",(0,o.jsx)(n.code,{children:"navigate"})," instead. To preserve the previous behavior, you can pass ",(0,o.jsx)(n.code,{children:"pop: true"})," as the third argument to ",(0,o.jsx)(n.code,{children:"navigate"}),":"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- navigation.navigateDeprecated('Profile', { userId: 123 });\n+ navigation.navigate('Profile', { userId: 123 }, { pop: true });\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"getId"})," from the navigation object has been removed since the ",(0,o.jsxs)(n.a,{href:"#navigators-no-longer-accept-an-id-prop",children:[(0,o.jsx)(n.code,{children:"id"})," prop has been removed"]}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"navigationInChildEnabled"})," prop from ",(0,o.jsx)(n.code,{children:"NavigationContainer"})," has been removed. This behavior is no longer supported."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.h4,{id:"the-linking-config-no-longer-requires-a-prefixes-option",children:["The linking config no longer requires a ",(0,o.jsx)(n.code,{children:"prefixes"})," option"]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, the linking configuration required a ",(0,o.jsx)(n.code,{children:"prefixes"})," option to specify the URL prefixes that the app should handle. This historical reason for this is to support Expo Go which uses a custom URL scheme."]}),"\n",(0,o.jsxs)(n.p,{children:["Since then, the recommended way to develop with Expo has been to use ",(0,o.jsx)(n.a,{href:"https://docs.expo.dev/develop/development-builds/introduction/",children:"Development Builds"}),", which use the app's own URL scheme. So the ",(0,o.jsx)(n.code,{children:"prefixes"})," option is not needed for most use cases."]}),"\n",(0,o.jsxs)(n.p,{children:["You can now omit the ",(0,o.jsx)(n.code,{children:"prefixes"})," option in the linking configuration unless you're using Expo Go:"]}),"\n",(0,o.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,o.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"<Navigation\n  linking={{\n-     prefixes: ['myapp://', 'https://myapp.com'],\n    enabled: 'auto',\n  }}\n>\n"})})}),(0,o.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"<NavigationContainer\n  linking={{\n-     prefixes: ['myapp://', 'https://myapp.com'],\n    config: { /* ... */ }\n  }}\n>\n"})})})]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"prefixes"})," default to ",(0,o.jsx)(n.code,{children:"['*']"}),", which will match any host starting with ",(0,o.jsx)(n.code,{children:"http"}),", ",(0,o.jsx)(n.code,{children:"https"}),", and custom schemes such as ",(0,o.jsx)(n.code,{children:"myapp://"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/configuring-links",children:"Configuring links"})," for more details."]}),"\n",(0,o.jsx)(n.h4,{id:"deep-links-are-now-enabled-by-default-in-static-configuration",children:"Deep links are now enabled by default in Static Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["Previously, deep linking needs to be explicitly enabled by setting ",(0,o.jsx)(n.code,{children:"linking.enabled"})," to ",(0,o.jsx)(n.code,{children:"auto"})," or by passing a ",(0,o.jsx)(n.code,{children:"linking"})," prop. The additional step was necessary since we also needed ",(0,o.jsx)(n.code,{children:"prefixes"})," to be specified in the linking config."]}),"\n",(0,o.jsxs)(n.p,{children:["In React Navigation 8, it now defaults to ",(0,o.jsx)(n.code,{children:"auto"}),", so deep linking is enabled by default with automatic path generation based on screen names when using static configuration:"]}),"\n",(0,o.jsxs)(n.p,{children:["If you don't want to enable deep linking, you can set ",(0,o.jsx)(n.code,{children:"linking.enabled"})," to ",(0,o.jsx)(n.code,{children:"false"}),":"]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"<Navigation\n+   linking={{\n+     enabled: false,\n+   }}\n>\n"})}),"\n",(0,o.jsxs)(n.h4,{id:"some-exports-are-removed-from-react-navigationelements",children:["Some exports are removed from ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"})]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"})," package has exported some components that were primarily intended for internal usage. These components have been removed from the public API:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"Background"})}),"\n",(0,o.jsxs)(n.p,{children:["Background color can instead be applied by using it from ",(0,o.jsx)(n.code,{children:"useTheme"}),"."]}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- import { Background } from '@react-navigation/elements';\n+ import { useTheme } from '@react-navigation/native';\n// ...\n- <Background>{children}</Background>\n+ const { colors } = useTheme();\n+\n+ <View style={{ backgroundColor: colors.background }}>{children}</View>\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"Screen"})}),"\n",(0,o.jsxs)(n.p,{children:["You can render the ",(0,o.jsx)(n.code,{children:"Header"})," component directly instead."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"SafeAreaProviderCompat"})}),"\n",(0,o.jsxs)(n.p,{children:["You can use ",(0,o.jsx)(n.code,{children:"SafeAreaProvider"})," from ",(0,o.jsx)(n.a,{href:"https://github.com/AppAndFlow/react-native-safe-area-context",children:(0,o.jsx)(n.code,{children:"react-native-safe-area-context"})})," directly instead."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"MissingIcon"})}),"\n",(0,o.jsxs)(n.p,{children:["You can copy the implementation from the ",(0,o.jsx)(n.a,{href:"https://github.com/react-navigation/react-navigation/blob/main/packages/elements/src/MissingIcon.tsx",children:"source code"})," if you need a placeholder icon."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Some of these components are still available and exported at ",(0,o.jsx)(n.code,{children:"@react-navigation/elements/internal"}),", so you can continue using them if you really need. However, since they are not part of the public API, they don't follow semver and may change without warning in future releases."]}),"\n",(0,o.jsxs)(n.h4,{id:"the-getdefaultheaderheight-utility-now-accepts-an-object-instead-of-positional-arguments",children:["The ",(0,o.jsx)(n.code,{children:"getDefaultHeaderHeight"})," utility now accepts an object instead of positional arguments"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"getDefaultHeaderHeight"})," utility from ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"}),' now accepts an object with named properties instead of positional arguments to improve readability"']}),"\n",(0,o.jsx)(n.pre,{"data-lang":"js",children:(0,o.jsx)(n.code,{className:"language-diff",metastring:"lang=js",children:"- getDefaultHeaderHeight(layout, false, statusBarHeight);\n+ getDefaultHeaderHeight({\n+   landscape: false,\n+   modalPresentation: false,\n+   topInset: statusBarHeight\n+ });\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/elements#getdefaultheaderheight",children:"Elements docs"})," for more details."]}),"\n",(0,o.jsx)(n.h2,{id:"new-features",children:"New features"}),"\n",(0,o.jsx)(n.h3,{id:"common-hooks-now-accept-name-of-the-screen",children:"Common hooks now accept name of the screen"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useNavigation"}),", ",(0,o.jsx)(n.code,{children:"useRoute"}),", and ",(0,o.jsx)(n.code,{children:"useNavigationState"})," hooks can now optionally accept the name of the screen:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const route = useRoute('Profile');\n"})}),"\n",(0,o.jsx)(n.p,{children:"The name of the screen can be for the current screen or any of its parent screens. This makes it possible to get params and navigation state for a parent screen without needing to setup context to pass them down."}),"\n",(0,o.jsx)(n.p,{children:"If the provided screen name does not exist in any of the parent screens, it will throw an error, so any mistakes are caught early."}),"\n",(0,o.jsx)(n.p,{children:"When using static configuration, the types are automatically inferred based on the name of the screen."}),"\n",(0,o.jsx)(n.p,{children:"It's still possible to use these hooks without passing the screen name, same as before, and it will return the navigation or route for the current screen."}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation",children:(0,o.jsx)(n.code,{children:"useNavigation"})}),", ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-route",children:(0,o.jsx)(n.code,{children:"useRoute"})}),", and ",(0,o.jsx)(n.a,{href:"/docs/8.x/use-navigation-state",children:(0,o.jsx)(n.code,{children:"useNavigationState"})})," for more details."]}),"\n",(0,o.jsxs)(n.h3,{id:"new-entry-can-be-added-to-history-stack-with-pushparams-action",children:["New entry can be added to history stack with ",(0,o.jsx)(n.code,{children:"pushParams"})," action"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"pushParams"})," action updates the params and pushes a new entry to the history stack:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"navigation.pushParams({ filter: 'new' });\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Unlike ",(0,o.jsx)(n.code,{children:"setParams"}),", this does not merge the new params with the existing ones. Instead, it uses the new params object as-is."]}),"\n",(0,o.jsx)(n.p,{children:"The action works in all navigators, such as stack, tab, and drawer. This allows to add a new entry to the history stack without needing to push a new screen instance."}),"\n",(0,o.jsx)(n.p,{children:"This can be useful in various scenario:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A product listing page with filters, where changing filters should create a new history entry so that users can go back to previous filter states."}),"\n",(0,o.jsx)(n.li,{children:"A screen with a custom modal component, where the modal is not a separate screen in the navigator, but its state should be reflected in the URL and history."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsxs)(n.a,{href:"/docs/8.x/navigation-actions#pushparams",children:[(0,o.jsx)(n.code,{children:"pushParams"})," docs"]})," for more details."]}),"\n",(0,o.jsxs)(n.h3,{id:"themes-now-support-colorvalue-and-css-custom-properties",children:["Themes now support ",(0,o.jsx)(n.code,{children:"ColorValue"})," and CSS custom properties"]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, theme colors only supported string values. In React Navigation 8, theme colors now support ",(0,o.jsx)(n.code,{children:"PlatformColor"}),", ",(0,o.jsx)(n.code,{children:"DynamicColorIOS"})," on native, and CSS custom properties on Web for more flexibility."]}),"\n",(0,o.jsxs)(n.p,{children:["Example theme using ",(0,o.jsx)(n.code,{children:"PlatformColor"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const MyTheme = {\n  ...DefaultTheme,\n  colors: Platform.select({\n    ios: () => ({\n      primary: PlatformColor('systemRed'),\n      background: PlatformColor('systemGroupedBackground'),\n      card: PlatformColor('tertiarySystemBackground'),\n      text: PlatformColor('label'),\n      border: PlatformColor('separator'),\n      notification: PlatformColor('systemRed'),\n    }),\n    android: () => ({\n      primary: PlatformColor('@android:color/system_primary_light'),\n      background: PlatformColor(\n        '@android:color/system_surface_container_light'\n      ),\n      card: PlatformColor('@android:color/system_background_light'),\n      text: PlatformColor('@android:color/system_on_surface_light'),\n      border: PlatformColor('@android:color/system_outline_variant_light'),\n      notification: PlatformColor('@android:color/holo_red_light'),\n    }),\n    default: () => DefaultTheme.colors,\n  })(),\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/themes#using-platform-colors",children:"Themes"})," for more details."]}),"\n",(0,o.jsxs)(n.h3,{id:"groups-now-support-linking-option-in-static-configuration",children:["Groups now support ",(0,o.jsx)(n.code,{children:"linking"})," option in static configuration"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"linking"})," option can now be specified for groups in static configuration to define nested paths:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const Stack = createStackNavigator({\n  groups: {\n    Settings: {\n      linking: { path: 'settings' },\n      screens: {\n        UserSettings: 'user',\n        AppSettings: 'app',\n      },\n    },\n  },\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This lets you prefix the paths of the screens in the group with a common prefix, e.g. ",(0,o.jsx)(n.code,{children:"settings/"})," for ",(0,o.jsx)(n.code,{children:"settings/user"})," and ",(0,o.jsx)(n.code,{children:"settings/app"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/group",children:"Group"})," for more details."]}),"\n",(0,o.jsx)(n.h3,{id:"deep-linking-to-screens-behind-conditional-screens-is-now-supported",children:"Deep linking to screens behind conditional screens is now supported"}),"\n",(0,o.jsx)(n.p,{children:"Previously, if a screen was conditionally rendered based on some state (e.g. authentication status), deep linking to that screen wouldn't work since the screen wouldn't exist in the navigator when the app was opened via a deep link."}),"\n",(0,o.jsxs)(n.p,{children:["In React Navigation 7, we added an experimental ",(0,o.jsx)(n.code,{children:"UNSTABLE_routeNamesChangeBehavior"})," option to enable remembering such unhandled actions and re-attempting them when the list of route names changed after the conditions changed by setting the option to ",(0,o.jsx)(n.code,{children:"lastUnhandled"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["In React Navigation 8, we have dropped the ",(0,o.jsx)(n.code,{children:"UNSTABLE_"})," prefix and made it a stable API."]}),"\n",(0,o.jsxs)(r.A,{groupId:"config",queryString:"config",children:["\n",(0,o.jsxs)(s.A,{value:"static",label:"Static",default:!0,children:["\n\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:"static2dynamic",children:"const Stack = createNativeStackNavigator({\n  // highlight-start\n  routeNamesChangeBehavior: 'lastUnhandled',\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})}),"\n\n"]}),"\n",(0,o.jsxs)(s.A,{value:"dynamic",label:"Dynamic",children:["\n\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:"static2dynamic",children:'const Stack = createNativeStackNavigator();\n\nfunction Stack() {\n  return (\n    // highlight-start\n    <Stack.Navigator routeNamesChangeBehavior="lastUnhandled">\n    // highlight-end\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}'})}),"\n\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"navigators-now-accept-a-router-prop",children:["Navigators now accept a ",(0,o.jsx)(n.code,{children:"router"})," prop"]}),"\n",(0,o.jsxs)(n.p,{children:["A router defines how the navigator updates its state based on navigation actions. Previously, custom routers could only be used by ",(0,o.jsx)(n.a,{href:"/docs/8.x/custom-navigators#extending-navigators",children:"creating a custom navigator"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["We later added an experimental ",(0,o.jsx)(n.code,{children:"UNSTABLE_router"})," prop to various navigators to customize the router without needing to create a custom navigator. In React Navigation 8, we have dropped the ",(0,o.jsx)(n.code,{children:"UNSTABLE_"})," prefix and made it a stable API."]}),"\n",(0,o.jsxs)(r.A,{groupId:"config",queryString:"config",children:["\n",(0,o.jsxs)(s.A,{value:"static",label:"Static",default:!0,children:["\n\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:"static2dynamic",children:"const MyStack = createNativeStackNavigator({\n  // highlight-start\n  router: (original) => ({\n    getStateForAction(state, action) {\n      if (action.type === 'NAVIGATE') {\n        // Custom logic for NAVIGATE action\n      }\n\n      // Fallback to original behavior\n      return original.getStateForAction(state, action);\n    },\n  }),\n  // highlight-end\n  screens: {\n    Home: HomeScreen,\n    Profile: ProfileScreen,\n  },\n});\n"})}),"\n\n"]}),"\n",(0,o.jsxs)(s.A,{value:"dynamic",label:"Dynamic",children:["\n\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:"static2dynamic",children:'const Stack = createNativeStackNavigator();\n\nfunction MyStack() {\n  return (\n    <Stack.Navigator\n      // highlight-start\n      router={(original) => ({\n        getStateForAction(state, action) {\n          if (action.type === \'NAVIGATE\') {\n            // Custom logic for NAVIGATE action\n          }\n\n          // Fallback to original behavior\n          return original.getStateForAction(state, action);\n        },\n      })}\n      // highlight-end\n    >\n      <Stack.Screen name="Home" component={HomeScreen} />\n      <Stack.Screen name="Profile" component={ProfileScreen} />\n    </Stack.Navigator>\n  );\n}'})}),"\n\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsxs)(n.a,{href:"/docs/8.x/navigator#router",children:[(0,o.jsx)(n.code,{children:"Navigator"})," docs"]})," for more details."]}),"\n",(0,o.jsxs)(n.h3,{id:"state-persistence-is-simplified-with-the-persistor-prop",children:["State persistence is simplified with the ",(0,o.jsx)(n.code,{children:"persistor"})," prop"]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, state persistence could be implemented with ",(0,o.jsx)(n.code,{children:"initialState"})," and ",(0,o.jsx)(n.code,{children:"onStateChange"})," props, however it required some boilerplates and handling edge cases."]}),"\n",(0,o.jsxs)(n.p,{children:["The new ",(0,o.jsx)(n.code,{children:"persistor"})," prop simplifies state persistence by reducing the boilerplate code needed to persist and restore state:"]}),"\n",(0,o.jsxs)(r.A,{groupId:"config",queryString:"config",children:[(0,o.jsx)(s.A,{value:"static",label:"Static",default:!0,children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export default function App() {\n  return (\n    <Navigation\n      persistor={{\n        async persist(state) {\n          await AsyncStorage.setItem(\n            'NAVIGATION_STATE_V1',\n            JSON.stringify(state)\n          );\n        },\n        async restore() {\n          const state = await AsyncStorage.getItem('NAVIGATION_STATE_V1');\n\n          return state ? JSON.parse(state) : undefined;\n        },\n      }}\n    />\n  );\n}\n"})})}),(0,o.jsx)(s.A,{value:"dynamic",label:"Dynamic",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export default function App() {\n  return (\n    <NavigationContainer\n      persistor={{\n        async persist(state) {\n          await AsyncStorage.setItem(\n            'NAVIGATION_STATE_V1',\n            JSON.stringify(state)\n          );\n        },\n        async restore() {\n          const state = await AsyncStorage.getItem('NAVIGATION_STATE_V1');\n\n          return state ? JSON.parse(state) : undefined;\n        },\n      }}\n    >\n      {/* ... */}\n    </NavigationContainer>\n  );\n}\n"})})})]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/state-persistence",children:"State persistence docs"})," for more details."]}),"\n",(0,o.jsxs)(n.h3,{id:"header-from-react-navigationelements-has-been-reworked",children:[(0,o.jsx)(n.code,{children:"Header"})," from ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"})," has been reworked"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Header"})," component from ",(0,o.jsx)(n.code,{children:"@react-navigation/elements"})," has been reworked with various improvements:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"It uses the new liquid glass effect on iOS 26"}),"\n",(0,o.jsxs)(n.li,{children:["It supports ",(0,o.jsx)(n.code,{children:"ColorValue"})," and CSS custom properties for colors"]}),"\n",(0,o.jsxs)(n.li,{children:["It supports ",(0,o.jsx)(n.code,{children:"headerBlurEffect"})," on Web (previously only supported on iOS in Native Stack Navigator)"]}),"\n",(0,o.jsx)(n.li,{children:"It no longer needs the layout of the screen to render correctly"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"To match the iOS 26 design, the back button title is no longer shown by default on iOS 26."}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/elements",children:"Elements"})," for more details."]}),"\n",(0,o.jsx)(n.h3,{id:"bottom-tab-navigator-now-supports-material-symbols--sf-symbols-icons",children:"Bottom Tab Navigator now supports Material Symbols & SF Symbols icons"}),"\n",(0,o.jsxs)(n.p,{children:["The Bottom Tab Navigator now supports using ",(0,o.jsx)(n.a,{href:"https://fonts.google.com/icons",children:"Material Symbols"})," on Android and ",(0,o.jsx)(n.a,{href:"https://developer.apple.com/sf-symbols/",children:"SF Symbols"})," on iOS for tab bar icons."]}),"\n",(0,o.jsxs)(n.p,{children:["You can specify the icon as an object in ",(0,o.jsx)(n.code,{children:"tabBarIcon"})," option:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"tabBarIcon: Platform.select({\n  ios: {\n    type: 'sfSymbol',\n    name: 'house',\n  },\n  android: {\n    type: 'materialSymbol',\n    name: 'home',\n  },\n}),\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This is supported both in ",(0,o.jsx)(n.code,{children:"native"})," and ",(0,o.jsx)(n.code,{children:"custom"})," implementations of Bottom Tab Navigator."]}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/docs/8.x/bottom-tab-navigator#tabbaricon",children:"Bottom Tab Navigator docs"})," for more details."]}),"\n",(0,o.jsxs)(n.h3,{id:"react-native-tab-view-now-supports-a-renderadapter-prop-for-custom-adapters",children:[(0,o.jsx)(n.code,{children:"react-native-tab-view"})," now supports a ",(0,o.jsx)(n.code,{children:"renderAdapter"})," prop for custom adapters"]}),"\n",(0,o.jsxs)(n.p,{children:["By default, ",(0,o.jsx)(n.code,{children:"react-native-tab-view"})," uses ",(0,o.jsx)(n.a,{href:"https://github.com/callstack/react-native-pager-view",children:(0,o.jsx)(n.code,{children:"react-native-pager-view"})})," for rendering pages on Android and iOS. However, it may not be suitable for all use cases."]}),"\n",(0,o.jsxs)(n.p,{children:["So it now supports a ",(0,o.jsx)(n.code,{children:"renderAdapter"})," prop to provide a custom adapter for rendering pages. For example, you can use ",(0,o.jsx)(n.code,{children:"ScrollViewAdapter"})," to use a ",(0,o.jsx)(n.code,{children:"ScrollView"})," for rendering pages:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import React from 'react';\nimport { TabView, ScrollViewAdapter } from 'react-native-tab-view';\n\nexport default function TabViewExample() {\n  const [index, setIndex] = React.useState(0);\n\n  return (\n    <TabView\n      navigationState={{ index, routes }}\n      renderScene={renderScene}\n      onIndexChange={setIndex}\n      renderAdapter={ScrollViewAdapter}\n    />\n  );\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can also create your own custom adapter by implementing the required interface. See the ",(0,o.jsxs)(n.a,{href:"/docs/8.x/tab-view",children:[(0,o.jsx)(n.code,{children:"react-native-tab-view"})," docs"]})," for more information."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>r});t(96540);var a=t(34164);const o={tabItem:"tabItem_Ymn6"};var i=t(74848);function r(e){let{children:n,hidden:t,className:r}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(o.tabItem,r),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>S});var a=t(96540),o=t(34164),i=t(17559),r=t(23104),s=t(56347),c=t(205),d=t(57485),l=t(31682),h=t(70679);function u(e){var n,t;return null!=(n=null==(t=a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:o}}=e;return{value:n,label:t,attributes:a,default:o}}))}(t);return function(e){const n=(0,l.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function g(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const o=(0,s.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,d.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(o.location.search);n.set(i,e),o.replace(Object.assign({},o.location,{search:n.toString()}))}),[i,o])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,i=p(e),[r,s]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!g({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const o=null!=(n=a.find((e=>e.default)))?n:a[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:i}))),[d,l]=m({queryString:t,groupId:o}),[u,f]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[o,i]=(0,h.Dv)(t);return[o,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:o}),v=(()=>{const e=null!=d?d:u;return g({value:e,tabValues:i})?e:null})();(0,c.A)((()=>{v&&s(v)}),[v]);return{selectedValue:r,selectValue:(0,a.useCallback)((e=>{if(!g({value:e,tabValues:i}))throw new Error("Can't select invalid tab value="+e);s(e),l(e),f(e)}),[l,f,i]),tabValues:i}}var v=t(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function y(e){let{className:n,block:t,selectedValue:a,selectValue:i,tabValues:s}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,r.a_)(),l=e=>{const n=e.currentTarget,t=c.indexOf(n),o=s[t].value;o!==a&&(d(n),i(o))},h=e=>{var n;let t=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{var a;const n=c.indexOf(e.currentTarget)+1;t=null!=(a=c[n])?a:c[0];break}case"ArrowLeft":{var o;const n=c.indexOf(e.currentTarget)-1;t=null!=(o=c[n])?o:c[c.length-1];break}}null==(n=t)||n.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":t},n),children:s.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,b.jsx)("li",Object.assign({role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{c.push(e)},onKeyDown:h,onClick:l},i,{className:(0,o.A)("tabs__item",x.tabItem,null==i?void 0:i.className,{"tabs__item--active":a===n}),children:null!=t?t:n}),n)}))})}function j(e){let{lazy:n,children:t,selectedValue:i}=e;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function w(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,o.A)(i.G.tabs.container,"tabs-container",x.tabList),children:[(0,b.jsx)(y,Object.assign({},n,e)),(0,b.jsx)(j,Object.assign({},n,e))]})}function S(e){const n=(0,v.A)();return(0,b.jsx)(w,Object.assign({},e,{children:u(e.children)}),String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(96540);const o={},i=a.createContext(o);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);